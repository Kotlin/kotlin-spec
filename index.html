<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.7.1">
<title>Kotlin Language Specification</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote::before{display:none}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{word-spacing:0;line-height:1.6}
.quoteblock.abstract blockquote::before,.quoteblock.abstract p::before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Kotlin Language Specification</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_purpose_and_format_of_this_specification">1. Purpose and Format of this Specification</a>
<ul class="sectlevel2">
<li><a href="#_general">1.1. General</a></li>
<li><a href="#_normative_and_informative_text">1.2. Normative and Informative Text</a></li>
<li><a href="#_notations">1.3. Notations</a></li>
<li><a href="#_glossary">1.4. Glossary</a></li>
<li><a href="#_referenced_specifications">1.5. Referenced Specifications</a>
<ul class="sectlevel3">
<li><a href="#_general_2">1.5.1. General</a></li>
<li><a href="#_unicode">1.5.2. Unicode</a></li>
<li><a href="#_ieee_754">1.5.3. IEEE 754</a></li>
<li><a href="#_java_virtual_machine">1.5.4. Java Virtual Machine</a></li>
<li><a href="#_ecmascript">1.5.5. ECMAScript</a></li>
</ul>
</li>
<li><a href="#_compatibility_policy">1.6. Compatibility Policy</a></li>
<li><a href="#_errata_policy">1.7. Errata Policy</a></li>
</ul>
</li>
<li><a href="#_language_overview">2. Language Overview</a></li>
<li><a href="#_compilation_process">3. Compilation Process</a>
<ul class="sectlevel2">
<li><a href="#_general_3">3.1. General</a></li>
<li><a href="#_compiler_input_and_output">3.2. Compiler Input and Output</a></li>
<li><a href="#_command_line">3.3. Command Line</a></li>
<li><a href="#_referenced_libraries">3.4. Referenced Libraries</a>
<ul class="sectlevel3">
<li><a href="#_general_4">3.4.1. General</a></li>
<li><a href="#_standard_library">3.4.2. Standard Library</a></li>
</ul>
</li>
<li><a href="#_source_files">3.5. Source Files</a>
<ul class="sectlevel3">
<li><a href="#_general_5">3.5.1. General</a></li>
<li><a href="#_supported_encodings">3.5.2. Supported Encodings</a></li>
<li><a href="#_ordering_of_source_files">3.5.3. Ordering of Source Files</a></li>
</ul>
</li>
<li><a href="#_parsing">3.6. Parsing</a></li>
<li><a href="#_target_platforms">3.7. Target Platforms</a>
<ul class="sectlevel3">
<li><a href="#_java_virtual_machine_2">3.7.1. Java Virtual Machine</a></li>
<li><a href="#_ecmascript_2">3.7.2. ECMAScript</a></li>
</ul>
</li>
<li><a href="#_errors_warnings_and_messages">3.8. Errors, Warnings and Messages</a>
<ul class="sectlevel3">
<li><a href="#_use_of_standard_output_and_standard_error_streams">3.8.1. Use of Standard Output and Standard Error Streams</a></li>
<li><a href="#_early_compilation_termination">3.8.2. Early Compilation Termination</a></li>
</ul>
</li>
<li><a href="#_implementation_limitations">3.9. Implementation Limitations</a></li>
</ul>
</li>
<li><a href="#_grammars_and_parsing">4. Grammars and Parsing</a>
<ul class="sectlevel2">
<li><a href="#_general_6">4.1. General</a></li>
<li><a href="#_lexical_grammar">4.2. Lexical Grammar</a>
<ul class="sectlevel3">
<li><a href="#_identifiers">4.2.1. Identifiers</a></li>
<li><a href="#_keywords">4.2.2. Keywords</a></li>
<li><a href="#_decimal_literals">4.2.3. Decimal Literals</a></li>
<li><a href="#_hexadecimal_literals">4.2.4. Hexadecimal Literals</a></li>
</ul>
</li>
<li><a href="#_syntax_grammar">4.3. Syntax Grammar</a>
<ul class="sectlevel3">
<li><a href="#_grammar_ambiguities">4.3.1. Grammar Ambiguities</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_symbols">5. Symbols</a>
<ul class="sectlevel2">
<li><a href="#_general_7">5.1. General</a></li>
<li><a href="#_declaring_symbol">5.2. Declaring Symbol</a></li>
<li><a href="#_implicit_declarations">5.3. Implicit Declarations</a></li>
<li><a href="#_modifiers">5.4. Modifiers</a></li>
<li><a href="#_visibility">5.5. Visibility</a>
<ul class="sectlevel3">
<li><a href="#_declared_visibility">5.5.1. Declared Visibility</a></li>
</ul>
</li>
<li><a href="#_packages">5.6. Packages</a></li>
<li><a href="#_classes">5.7. Classes</a></li>
<li><a href="#_interfaces">5.8. Interfaces</a></li>
<li><a href="#_properties_and_fields">5.9. Properties and Fields</a></li>
<li><a href="#_methods_and_functions">5.10. Methods and Functions</a>
<ul class="sectlevel3">
<li><a href="#_general_8">5.10.1. General</a></li>
<li><a href="#_type_parameter_list">5.10.2. Type-parameter List</a></li>
<li><a href="#_parameter_list">5.10.3. Parameter List</a></li>
<li><a href="#_generic_functions">5.10.4. Generic Functions</a></li>
<li><a href="#_local_and_top_level_functions">5.10.5. Local and Top-Level Functions</a></li>
</ul>
</li>
<li><a href="#_locals">5.11. Locals</a></li>
<li><a href="#_parameters">5.12. Parameters</a></li>
<li><a href="#_singleton_objects">5.13. Singleton Objects</a>
<ul class="sectlevel3">
<li><a href="#_companion_objects">5.13.1. Companion Objects</a></li>
<li><a href="#_labels">5.13.2. Labels</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_values_and_types">6. Values and Types</a>
<ul class="sectlevel2">
<li><a href="#_general_9">6.1. General</a></li>
<li><a href="#_syntax_for_types">6.2. Syntax for Types</a></li>
<li><a href="#_compile_time_and_run_time_types">6.3. Compile-time and Run-time Types</a></li>
<li><a href="#_reified_types">6.4. Reified Types</a>
<ul class="sectlevel3">
<li><a href="#_semantics_checks_and_restrictions">6.4.1. Semantics, Checks and Restrictions</a></li>
<li><a href="#_implementation_notes_for_the_jvm">6.4.2. Implementation notes for the JVM</a></li>
</ul>
</li>
<li><a href="#_nullable_types">6.5. Nullable Types</a></li>
<li><a href="#_primitive_and_special_types">6.6. Primitive and Special Types</a>
<ul class="sectlevel3">
<li><a href="#_the_kotlin_any_type">6.6.1. The kotlin.Any Type</a></li>
<li><a href="#_the_kotlin_nothing_type">6.6.2. The kotlin.Nothing Type</a></li>
<li><a href="#_the_kotlin_unit_type">6.6.3. The kotlin.Unit Type</a></li>
<li><a href="#_the_kotlin_byte_type">6.6.4. The kotlin.Byte Type</a></li>
<li><a href="#_the_kotlin_short_type">6.6.5. The kotlin.Short Type</a></li>
<li><a href="#_the_kotlin_int_type">6.6.6. The kotlin.Int Type</a></li>
<li><a href="#_the_kotlin_long_type">6.6.7. The kotlin.Long Type</a></li>
<li><a href="#_the_kotlin_char_type">6.6.8. The kotlin.Char Type</a></li>
<li><a href="#_the_kotlin_float_type">6.6.9. The kotlin.Float Type</a></li>
<li><a href="#_the_kotlin_double_type">6.6.10. The kotlin.Double Type</a></li>
<li><a href="#_the_kotlin_boolean_type">6.6.11. The kotlin.Boolean Type</a></li>
<li><a href="#_the_kotlin_arrayt_type">6.6.12. The kotlin.Array&lt;T&gt; Type</a></li>
<li><a href="#_kotlin_string_class">6.6.13. kotlin.String class</a></li>
<li><a href="#_kotlin_reflect_kclasst_class">6.6.14. kotlin.reflect.KClass&lt;T&gt; class</a></li>
<li><a href="#_the_dynamic_type">6.6.15. The dynamic Type</a></li>
</ul>
</li>
<li><a href="#_functional_types">6.7. Functional Types</a></li>
<li><a href="#_platform_types">6.8. Platform Types</a></li>
<li><a href="#_type_relationships">6.9. Type Relationships</a>
<ul class="sectlevel3">
<li><a href="#_restrictions">6.9.1. Restrictions</a></li>
<li><a href="#_single_instantiation_rule">6.9.2. Single Instantiation Rule</a></li>
</ul>
</li>
<li><a href="#_conversions">6.10. Conversions</a></li>
</ul>
</li>
<li><a href="#_generics">7. Generics</a>
<ul class="sectlevel2">
<li><a href="#_general_10">7.1. General</a></li>
<li><a href="#_type_parameters">7.2. Type-Parameters</a></li>
<li><a href="#_instantiation">7.3. Instantiation</a>
<ul class="sectlevel3">
<li><a href="#_general_11">7.3.1. General</a></li>
<li><a href="#_type_argument_list">7.3.2. Type-Argument List</a></li>
</ul>
</li>
<li><a href="#_substitution">7.4. Substitution</a></li>
<li><a href="#_bounds">7.5. Bounds</a></li>
<li><a href="#_variance">7.6. Variance</a></li>
<li><a href="#_projections">7.7. Projections</a></li>
<li><a href="#_type_inference">7.8. Type Inference</a></li>
<li><a href="#_restrictions_on_usage">7.9. Restrictions on Usage</a></li>
<li><a href="#_generic_functions_2">7.10. Generic functions</a></li>
<li><a href="#_generic_constraints">7.11. Generic constraints</a>
<ul class="sectlevel3">
<li><a href="#_type_projections">7.11.1. Type Projections</a></li>
<li><a href="#_extended_set_of_bounds">7.11.2. Extended Set of Bounds</a></li>
<li><a href="#_constituent_types">7.11.3. Constituent Types</a></li>
<li><a href="#_effectively_generic_types">7.11.4. Effectively Generic Types</a></li>
</ul>
</li>
<li><a href="#_restrictions_on_generic_types">7.12. Restrictions on Generic Types</a></li>
<li><a href="#_general_rules_and_definitions">7.13. General Rules and Definitions</a></li>
<li><a href="#_constituent_types_2">7.14. Constituent Types</a></li>
<li><a href="#_bounds_2">7.15. Bounds</a></li>
<li><a href="#_skolemization">7.16. Skolemization</a></li>
<li><a href="#_b_closure">7.17. B-Closure</a></li>
<li><a href="#_finite_bound_restriction">7.18. Finite Bound Restriction</a></li>
</ul>
</li>
<li><a href="#_control_and_data_flow">8. Control and Data Flow</a>
<ul class="sectlevel2">
<li><a href="#_general_12">8.1. General</a></li>
<li><a href="#_definite_assignment">8.2. Definite Assignment</a></li>
<li><a href="#_smart_casts">8.3. Smart-casts</a></li>
<li><a href="#_unreachable_code">8.4. Unreachable Code</a>
<ul class="sectlevel3">
<li><a href="#_effects_of_kotlin_nothing_type">8.4.1. Effects of kotlin.Nothing Type</a></li>
<li><a href="#_effects_on_nullability">8.4.2. Effects on Nullability</a></li>
<li><a href="#_effects_on_smart_casts">8.4.3. Effects on Smart-Casts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_application_life_cycle">9. Application Life Cycle</a>
<ul class="sectlevel2">
<li><a href="#_applications_vs_libraries">9.1. Applications vs. Libraries</a></li>
<li><a href="#_application_startup">9.2. Application Startup</a></li>
<li><a href="#_entry_point">9.3. Entry Point</a></li>
<li><a href="#_type_loading_and_initialization">9.4. Type Loading and Initialization</a></li>
<li><a href="#_threads">9.5. Threads</a>
<ul class="sectlevel3">
<li><a href="#_race_conditions">9.5.1. Race Conditions</a></li>
</ul>
</li>
<li><a href="#_unhandled_exceptions">9.6. Unhandled Exceptions</a></li>
<li><a href="#_runtime_limitations">9.7. Runtime Limitations</a>
<ul class="sectlevel3">
<li><a href="#_general_13">9.7.1. General</a></li>
<li><a href="#_stack_overflow">9.7.2. Stack Overflow</a></li>
<li><a href="#_out_of_memory_condition">9.7.3. Out of Memory Condition</a></li>
</ul>
</li>
<li><a href="#_application_termination">9.8. Application Termination</a></li>
<li><a href="#_garbage_collection">9.9. Garbage Collection</a></li>
<li><a href="#_finalization">9.10. Finalization</a></li>
</ul>
</li>
<li><a href="#_object_oriented_programming_features">10. Object-Oriented Programming Features</a>
<ul class="sectlevel2">
<li><a href="#_general_14">10.1. General</a></li>
<li><a href="#_inheritance">10.2. Inheritance</a></li>
<li><a href="#_interface_implementation">10.3. Interface Implementation</a></li>
<li><a href="#_visibility_2">10.4. Visibility</a></li>
<li><a href="#_overriding">10.5. Overriding</a></li>
<li><a href="#_delegation">10.6. Delegation</a></li>
<li><a href="#_extension_members">10.7. Extension Members</a></li>
<li><a href="#_object_construction">10.8. Object Construction</a></li>
<li><a href="#_runtime_virtual_invocation_dispatch">10.9. Runtime Virtual Invocation Dispatch</a></li>
<li><a href="#_singleton_objects_2">10.10. Singleton Objects</a></li>
</ul>
</li>
<li><a href="#_functional_programming_features">11. Functional Programming Features</a>
<ul class="sectlevel2">
<li><a href="#_general_15">11.1. General</a></li>
<li><a href="#_functional_values">11.2. Functional Values</a></li>
<li><a href="#_method_references">11.3. Method References</a></li>
<li><a href="#_anonymous_functions">11.4. Anonymous Functions</a>
<ul class="sectlevel3">
<li><a href="#_lambda_as_an_argument_to_an_invocation">11.4.1. Lambda as an Argument to an Invocation</a></li>
</ul>
</li>
<li><a href="#_function_inlining">11.5. Function Inlining</a>
<ul class="sectlevel3">
<li><a href="#_inline_functions">11.5.1. inline Functions</a></li>
</ul>
</li>
<li><a href="#_closures">11.6. Closures</a>
<ul class="sectlevel3">
<li><a href="#_instantiation_and_lifetime_of_captured_variables">11.6.1. Instantiation and Lifetime of Captured Variables</a></li>
<li><a href="#_implications_for_strong_references_and_garbage_collection">11.6.2. Implications for Strong References and Garbage Collection</a></li>
<li><a href="#_external_modifier">11.6.3. external Modifier</a></li>
<li><a href="#_tailrec_modifier">11.6.4. tailrec Modifier</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_compilation_units">12. Compilation Units</a>
<ul class="sectlevel2">
<li><a href="#_general_16">12.1. General</a></li>
<li><a href="#_file_level_annotations">12.2. File-Level Annotations</a></li>
<li><a href="#_package_specification">12.3. Package Specification</a></li>
<li><a href="#_import_directives">12.4. Import Directives</a></li>
<li><a href="#_type_and_object_declarations">12.5. Type and Object Declarations</a></li>
<li><a href="#_package_level_functions">12.6. Package-Level Functions</a></li>
</ul>
</li>
<li><a href="#_classes_2">13. Classes</a>
<ul class="sectlevel2">
<li><a href="#_general_17">13.1. General</a></li>
<li><a href="#_class_declarations">13.2. Class Declarations</a></li>
<li><a href="#_class_modifiers">13.3. Class Modifiers</a></li>
<li><a href="#_initialization_blocks">13.4. Initialization Blocks</a></li>
<li><a href="#_class_members">13.5. Class Members</a></li>
<li><a href="#_constructors">13.6. Constructors</a>
<ul class="sectlevel3">
<li><a href="#_secondary_constructors">13.6.1. Secondary constructors</a></li>
</ul>
</li>
<li><a href="#_methods">13.7. Methods</a></li>
<li><a href="#_properties">13.8. Properties</a>
<ul class="sectlevel3">
<li><a href="#_delegated_properties">13.8.1. Delegated Properties</a></li>
<li><a href="#_general_18">13.8.2. General</a></li>
<li><a href="#_properties_without_explicit_accessors">13.8.3. Properties without Explicit Accessors</a></li>
<li><a href="#_properties_with_explicit_accessors">13.8.4. Properties with Explicit Accessors</a></li>
</ul>
</li>
<li><a href="#_fields">13.9. Fields</a></li>
<li><a href="#_nested_and_inner_classes">13.10. Nested and Inner Classes</a></li>
<li><a href="#_sealed_classes">13.11. Sealed Classes</a></li>
<li><a href="#_local_classes">13.12. Local Classes</a></li>
<li><a href="#_anonymous_classes">13.13. Anonymous Classes</a></li>
<li><a href="#_enum_classes">13.14. Enum Classes</a></li>
<li><a href="#_data_classes">13.15. Data Classes</a></li>
</ul>
</li>
<li><a href="#_interfaces_2">14. Interfaces</a>
<ul class="sectlevel2">
<li><a href="#_general_19">14.1. General</a></li>
<li><a href="#_interface_declarations">14.2. Interface Declarations</a>
<ul class="sectlevel3">
<li><a href="#_methods_2">14.2.1. Methods</a></li>
<li><a href="#_properties_2">14.2.2. Properties</a></li>
</ul>
</li>
<li><a href="#_interfaces_vs_classes">14.3. Interfaces vs. Classes</a></li>
</ul>
</li>
<li><a href="#_annotations">15. Annotations</a>
<ul class="sectlevel2">
<li><a href="#_general_20">15.1. General</a></li>
<li><a href="#_declarations">15.2. Declarations</a>
<ul class="sectlevel3">
<li><a href="#_primary_constructor_parameters">15.2.1. Primary Constructor Parameters</a></li>
</ul>
</li>
<li><a href="#_annotation_targets">15.3. Annotation Targets</a></li>
<li><a href="#_applying_annotations">15.4. Applying Annotations</a></li>
<li><a href="#_retention_levels">15.5. Retention Levels</a></li>
<li><a href="#_predefined_annotations_significant_for_kotlin_compiler">15.6. Predefined Annotations Significant for Kotlin Compiler</a>
<ul class="sectlevel3">
<li><a href="#_general_21">15.6.1. General</a></li>
<li><a href="#_kotlin_suppress_annotation">15.6.2. <code>kotlin.Suppress</code> Annotation</a></li>
<li><a href="#_kotlin_deprecated_annotation">15.6.3. <code>kotlin.Deprecated</code> Annotation</a></li>
<li><a href="#_kotlin_annotation_retention_annotation">15.6.4. <code>kotlin.annotation.Retention</code> annotation</a></li>
<li><a href="#_kotlin_annotation_annotationretention_enum_class">15.6.5. <code>kotlin.annotation.AnnotationRetention</code> Enum Class</a></li>
<li><a href="#_kotlin_annotation_target_annotation">15.6.6. <code>kotlin.annotation.Target</code> Annotation</a></li>
<li><a href="#_kotlin_annotation_annotationtarget_enum_class">15.6.7. <code>kotlin.annotation.AnnotationTarget</code> Enum Class</a></li>
<li><a href="#_kotlin_jvm_synchronized_annotation">15.6.8. <code>kotlin.jvm.Synchronized</code> Annotation</a></li>
<li><a href="#_kotlin_jvm_strictfp_annotation">15.6.9. <code>kotlin.jvm.Strictfp</code> Annotation</a></li>
<li><a href="#_kotlin_jvm_volatile_annotation">15.6.10. <code>kotlin.jvm.Volatile</code> Annotation</a></li>
<li><a href="#_kotlin_jvm_transient_annotation">15.6.11. <code>kotlin.jvm.Transient</code> Annotation</a></li>
<li><a href="#_kotlin_jvm_jvmname_annotation">15.6.12. <code>kotlin.jvm.JvmName</code> Annotation</a></li>
<li><a href="#_kotlin_jvm_jvmstatic_annotation">15.6.13. <code>kotlin.jvm.JvmStatic</code> Annotation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_executable_code">16. Executable Code</a>
<ul class="sectlevel2">
<li><a href="#_general_22">16.1. General</a></li>
<li><a href="#_blocks">16.2. Blocks</a></li>
<li><a href="#_statements">16.3. Statements</a></li>
<li><a href="#_expression_statement">16.4. Expression Statement</a></li>
<li><a href="#_single_variable_declaration">16.5. Single-Variable Declaration</a></li>
<li><a href="#_multi_variable_declaration">16.6. Multi-Variable Declaration</a></li>
<li><a href="#_local_function_declaration">16.7. Local Function Declaration</a></li>
<li><a href="#_local_type_declaration">16.8. Local Type Declaration</a></li>
<li><a href="#_simple_assignment">16.9. Simple Assignment</a></li>
<li><a href="#_compound_assignment">16.10. Compound Assignment</a></li>
<li><a href="#_for_loop">16.11. for Loop</a>
<ul class="sectlevel3">
<li><a href="#_multi_declarations_in_for_loop">16.11.1. Multi-Declarations in for Loop</a></li>
</ul>
</li>
<li><a href="#_while_loop">16.12. while Loop</a></li>
<li><a href="#_literals">16.13. Literals</a></li>
<li><a href="#_simple_names">16.14. Simple Names</a></li>
<li><a href="#_invocation_expressions">16.15. Invocation Expressions</a></li>
<li><a href="#_this_expression">16.16. <code>this</code> Expression</a></li>
<li><a href="#_super_access">16.17. <code>super</code> Access</a></li>
<li><a href="#_class_expressions">16.18. <code>class</code> Expressions</a></li>
<li><a href="#_callable_references">16.19. Callable References</a></li>
<li><a href="#_operator_expressions">16.20. Operator Expressions</a></li>
<li><a href="#_range_expression">16.21. Range Expression</a></li>
<li><a href="#_return_expression">16.22. <code>return</code> Expression</a></li>
<li><a href="#_throw_expression">16.23. <code>throw</code> Expression</a></li>
<li><a href="#_is_is_operators">16.24. <code>is</code>, <code>!is</code> Operators</a></li>
<li><a href="#_in_in_operators">16.25. <code>in</code>, <code>!in</code> Operators</a></li>
<li><a href="#_as_as_expressions">16.26. <code>as</code>, <code>as?</code> Expressions</a></li>
<li><a href="#_member_access_operator">16.27. Member Access Operator</a></li>
<li><a href="#_safe_access_operator">16.28. Safe Access Operator <code>?.</code></a></li>
<li><a href="#_conditional_expression">16.29. Conditional Expression</a></li>
<li><a href="#_when_expression">16.30. when Expression</a></li>
<li><a href="#_object_expressions">16.31. Object Expressions</a></li>
<li><a href="#_anonymous_functions_2">16.32. Anonymous Functions</a>
<ul class="sectlevel3">
<li><a href="#_general_23">16.32.1. General</a></li>
<li><a href="#_function_expression">16.32.2. Function Expression</a></li>
<li><a href="#_function_literal">16.32.3. Function Literal</a></li>
</ul>
</li>
<li><a href="#_static_type_assertion_expression">16.33. Static Type Assertion Expression</a></li>
<li><a href="#_parenthesized_expression">16.34. Parenthesized Expression</a></li>
<li><a href="#_invocation_expression">16.35. Invocation Expression</a>
<ul class="sectlevel3">
<li><a href="#_passing_argument_as_a_trailing_function_literal">16.35.1. Passing Argument as a Trailing Function Literal</a></li>
<li><a href="#_implicit_invoke_method_invocations">16.35.2. Implicit invoke Method Invocations</a></li>
</ul>
</li>
<li><a href="#_indexer_access_expression">16.36. Indexer Access Expression</a></li>
<li><a href="#_anonymous_object_creation_expressions">16.37. Anonymous Object Creation Expressions</a></li>
<li><a href="#_try_expressions">16.38. try Expressions</a></li>
<li><a href="#_order_of_evaluation">16.39. Order of Evaluation</a></li>
</ul>
</li>
<li><a href="#_name_and_overload_resolution">17. Name and Overload Resolution</a>
<ul class="sectlevel2">
<li><a href="#_general_24">17.1. General</a></li>
<li><a href="#_simple_names_2">17.2. Simple Names</a></li>
<li><a href="#_qualified_names">17.3. Qualified Names</a></li>
<li><a href="#_name_lookup">17.4. Name Lookup</a></li>
<li><a href="#_argument_lists">17.5. Argument Lists</a></li>
<li><a href="#_positional_arguments">17.6. Positional Arguments</a></li>
<li><a href="#_named_arguments">17.7. Named Arguments</a></li>
<li><a href="#_default_parameter_values">17.8. Default Parameter Values</a></li>
<li><a href="#_vararg_invocations">17.9. vararg Invocations</a></li>
<li><a href="#_matching_arguments_with_parameters">17.10. Matching Arguments with Parameters</a></li>
<li><a href="#_candidate_method_search">17.11. Candidate Method Search</a></li>
<li><a href="#_potential_applicability">17.12. Potential Applicability</a></li>
<li><a href="#_actual_applicability">17.13. Actual Applicability</a></li>
<li><a href="#_overload_resolution">17.14. Overload Resolution</a>
<ul class="sectlevel3">
<li><a href="#_general_25">17.14.1. General</a></li>
<li><a href="#_better_conversion">17.14.2. Better Conversion</a></li>
<li><a href="#_better_candidate">17.14.3. Better Candidate</a></li>
<li><a href="#_best_candidate">17.14.4. Best Candidate</a></li>
</ul>
</li>
<li><a href="#_type_inference_2">17.15. Type Inference</a></li>
</ul>
</li>
<li><a href="#_threads_and_concurrency">18. Threads and Concurrency</a>
<ul class="sectlevel2">
<li><a href="#_general_26">18.1. General</a></li>
<li><a href="#_memory_model">18.2. Memory Model</a></li>
<li><a href="#_race_conditions_2">18.3. Race Conditions</a></li>
<li><a href="#_synchronization">18.4. Synchronization</a></li>
<li><a href="#_thread_creation_and_termination">18.5. Thread Creation and Termination</a></li>
</ul>
</li>
<li><a href="#_java_interoperability">19. Java Interoperability</a>
<ul class="sectlevel2">
<li><a href="#_general_27">19.1. General</a>
<ul class="sectlevel3">
<li><a href="#_waitnotify">19.1.1. wait()/notify()</a></li>
</ul>
</li>
<li><a href="#_mixed_projects">19.2. Mixed Projects</a></li>
<li><a href="#_platform_types_2">19.3. Platform Types</a></li>
<li><a href="#_sam_types">19.4. SAM Types</a></li>
<li><a href="#_optional_parameters">19.5. Optional Parameters</a></li>
<li><a href="#_using_predefined_types_from_java_lang_package">19.6. Using predefined types from java.lang package</a></li>
</ul>
</li>
<li><a href="#_reflection">20. Reflection</a></li>
<li><a href="#_standard_library_overview">21. Standard Library Overview</a></li>
<li><a href="#_documentation_comments">22. Documentation Comments</a></li>
<li><a href="#_miscellaneous">23. Miscellaneous</a>
<ul class="sectlevel2">
<li><a href="#_import_directive_priorities">23.1. Import Directive Priorities</a></li>
<li><a href="#_anonymous_types_in_public_api">23.2. Anonymous Types in Public API</a></li>
<li><a href="#_scripting">23.3. Scripting</a></li>
<li><a href="#_misc">23.4. Misc</a>
<ul class="sectlevel3">
<li><a href="#_method_overriding">23.4.1. Method Overriding</a></li>
<li><a href="#_intersection_types">23.4.2. Intersection types</a></li>
<li><a href="#_priority_of_candidates">23.4.3. Priority of candidates</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">A PDF version of this document is available <a href="kotlin-spec.pdf">here</a>.</div>

</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_purpose_and_format_of_this_specification">1. Purpose and Format of this Specification</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general">1.1. General</h3>
<div class="paragraph">
<p>Kotlin is a general-purpose, statically- and strongly-typed programming language. Kotlin supports imperative, object-oriented and functional programming styles. Its object-oriented system is based on single class inheritance and multiple interface inheritance. Only classes can contain data and initialization code, and interfaces can contain abstract functional members and, optionally, default implementations for them.</p>
</div>
<div class="paragraph">
<p>The Kotlin type system is based on nominal (rather than structural) subtyping with subtyping polymorphism (virtual functional members), with support of generics&#8201;&#8212;&#8201;a form of parametric polymorphism featuring constrained type-parameters, generic variance and type projections (a simple restricted form of existential types somewhat similar to Java wildcards).</p>
</div>
<div class="paragraph">
<p>Being a statically-typed means that every expression has a known compile-time type and that the language guarantees that at runtime the expression will evaluate to an instance of that type (except certain cases caused by generic type erasure and indicated by compiler warnings).</p>
</div>
<div class="paragraph">
<p>Being a strongly-typed means that any conversion between types that involves an evaluation, changes the value representation or may fail at runtime requires an explicit invocation of a conversion function or an explicit downcast&#8201;&#8212;&#8201;it never can implicitly occur in a simple assignment. Implicit conversions are reserved for safe upcasts enabled by subtyping and variance that do not change the state or identity of the object being converted, but simply allows to see through a reference of a different (but compatible) type. No user-defined implicit conversions are supported either.</p>
</div>
<div class="paragraph">
<p>Kotlin has a unified type system&#8201;&#8212;&#8201;it has a single root type <code>kotlin.Any?</code> and every other type is a subtype of this root type.</p>
</div>
<div class="paragraph">
<p>Types in Kotlin are not a purely compile-time concept. Some information about types is preserved at runtime, and any value can be dynamically queried for its exact type, and dynamically checked for compatibility with any given type. But runtime type information is not precise&#8201;&#8212;&#8201;it is not possible to distinguish between different instantiations of the same generic type (arrays being an exception), and between arrays of corresponding nullable and non-nullable types.</p>
</div>
<div class="paragraph">
<p>Although Kotlin provides a number of predefined types, some of them having a special meaning in the language, it is possible to declare used-defined types in the form of classes and interfaces.</p>
</div>
<div class="paragraph">
<p>Kotlin supports functional programming paradigm and so functions are considered to be first-class values&#8201;&#8212;&#8201;they have type, they can be passed as arguments, returned as return values, and stored in local variables, fields of classes and elements of arrays.</p>
</div>
<div class="paragraph">
<p>TODO: dynamic types, non-nullable types.</p>
</div>
<div class="paragraph">
<p>Kotlin syntax is intended to be concise, but without impeding readability. It supports traditional nested block structure based on curly braces, but also features implicit semicolon inference, relieving a user of typing trailing semicolons in most cases. Whitespace (except new lines) is generally insignificant (except within string and character literals), but in some cases it is required to separate certain tokens.</p>
</div>
<div class="paragraph">
<p>TODO: Describe main purposes, features and supported paradigms of Kotlin, general design principles.</p>
</div>
</div>
<div class="sect2">
<h3 id="_normative_and_informative_text">1.2. Normative and Informative Text</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_notations">1.3. Notations</h3>
<div class="paragraph">
<p>This section describes general notation rules and terminology used throughout this specification. Each rule describes a default meaning that can be explicitly overridden in a particular section of the specification. Thus, each rule shall be interpreted as if it ends with "&#8230;&#8203; unless it explicitly specified otherwise".</p>
</div>
<div class="paragraph">
<p>In this section, <strong>A</strong> and <strong>B</strong> are meta-variables that can be replaced with any propositions.</p>
</div>
<div class="paragraph">
<p>Logical connectives such as "or", "and", "not", "if &#8230;&#8203; then &#8230;&#8203;" have their usual meaning as in the classical two-valued logic. The connective "or" is not exclusive. The statement "either <strong>A</strong> or <strong>B</strong>" is equivalent to "<strong>A</strong> or <strong>B</strong>" and is not exlusive either. If an exclusive "or" is intended, it is specified explicitly, e.g. "exactly one of the following is true: &#8230;&#8203;", or "<strong>A</strong> or <strong>B</strong>, but not both".</p>
</div>
<div class="paragraph">
<p>An implication "if <strong>A</strong> then <strong>B</strong>" is exactly equivalent to "<strong>B</strong> or not <strong>A</strong>".</p>
</div>
<div class="paragraph">
<p>"<strong>A</strong> iff <strong>B</strong>" is a shorthand for the biconditional "<strong>A</strong> if and only if <strong>B</strong>".</p>
</div>
<div class="paragraph">
<p>"<strong>A</strong> is true" is an exact equivalent of just "<strong>A</strong>", and "<strong>A</strong> is false" is an exact equivalent of "not <strong>A</strong>".</p>
</div>
<div class="paragraph">
<p>All characters that can be potentially interpreted both as ASCII characters and as similarly looking characters from a different part of the Unicode character set shall be interpreted as printable characters in ASCII range (U+0020 - U+007E). Every whitespace shall be interpreted as a single SPACE (U+0020) character.</p>
</div>
<div class="paragraph">
<p>All numbers are given in decimal notation.</p>
</div>
<div class="paragraph">
<p>All ranges ("between &#8230;&#8203;", "up to &#8230;&#8203;", etc.) are assumed inclusive.</p>
</div>
<div class="paragraph">
<p>"An error" means "a compile-time error".</p>
</div>
<div class="paragraph">
<p>When the specification states that some condition "cannot occur", it means that it is a compile-time error if such condition occurs. When the specification states that some condition "is not significant", it means that the observable behavior of the program does not change when this condition changes.</p>
</div>
<div class="paragraph">
<p>When the specification refers to the "first" entry in some list originating in some syntactic representation in a source (e.g. "the first type-parameter of a function" or "the first statement in a block") it refers to the lexically leftmost entry (i.e. starting with the smallest offset in the source file). Similarly, the "second" means the leftmost to the right of the first, the "n-th" means the leftmost to the right of the (n-1)-th, and the "last" means the rightmost.</p>
</div>
</div>
<div class="sect2">
<h3 id="_glossary">1.4. Glossary</h3>
<div class="paragraph">
<p>This section gives definitions of some terms used in this specification.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ASCII characters&#8201;&#8212;&#8201;a subset of Unicode characters with code points from U+0000 to U+007F inclusive.</p>
</li>
<li>
<p>ASCII printable characters&#8201;&#8212;&#8201;a subset of ASCII characters with code points from U+0020 to U+007E inclusive.</p>
</li>
<li>
<p>Angle brackets&#8201;&#8212;&#8201;the ASCII characters <code>&lt;</code> LESS-THAN SIGN (U+003C) and <code>&gt;</code> GREATER-THAN SIGN (U+003E), in a context where they used as delimiters rather than operators.</p>
</li>
<li>
<p>Curly braces&#8201;&#8212;&#8201;the ASCII characters <code>{</code> LEFT CURLY BRACKET (U+007B) and <code>}</code> RIGHT CURLY BRACKET (U+007D).</p>
</li>
<li>
<p>Dot&#8201;&#8212;&#8201;the ASCII character <code>.</code> FULL STOP (U+002E).</p>
</li>
<li>
<p>Underscore&#8201;&#8212;&#8201;the ASCII character <code>_</code> LOW LINE (U+005F).</p>
</li>
<li>
<p>Backtick&#8201;&#8212;&#8201;the ASCII character <code>`</code> GRAVE ACCENT (U+0060).</p>
</li>
<li>
<p>Minus&#8201;&#8212;&#8201;the ASCII character <code>-</code> HYPHEN-MINUS (U+002D). <em>[Note:</em> Not to be confused with HYPHEN (U+2010), MINUS SIGN (U+2212) or other similarly looking or similarly named characters, that have no special meaning in the language. <em>End Note]</em></p>
</li>
<li>
<p>Zero&#8201;&#8212;&#8201;the ASCII character <code>0</code> DIGIT ZERO (U+0030), in a context where it is used as a character name.</p>
</li>
<li>
<p>Enclosed in parentheses/brackets/etc. - TODO</p>
</li>
<li>
<p>"&#8230;&#8203; in a textual order"&#8201;&#8212;&#8201;in the order of increasing offsets from the beginning of the file (i.e. top-to-bottom, and left-to-right within a line, assuming no RTL characters).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_referenced_specifications">1.5. Referenced Specifications</h3>
<div class="sect3">
<h4 id="_general_2">1.5.1. General</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_unicode">1.5.2. Unicode</h4>
<div class="paragraph">
<p>TODO: Specify what version of the Unicode Standard is supported, and what is the upgrade and compatibility policy is in effect as newer versions of the Standard are released.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ieee_754">1.5.3. IEEE 754</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_java_virtual_machine">1.5.4. Java Virtual Machine</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_ecmascript">1.5.5. ECMAScript</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compatibility_policy">1.6. Compatibility Policy</h3>
<div class="paragraph">
<p>TODO: Specify what the policy for the language evolution with respect to backwards compatibility is, and what the policy for compiler bug fixes is.</p>
</div>
</div>
<div class="sect2">
<h3 id="_errata_policy">1.7. Errata Policy</h3>
<div class="paragraph">
<p>This specification is intended to be free of contradictions and ambiguous language. But experience shows that for documents of such complexity it is not uncommon that some defects go unnoticed for some time. This sections outlines general principles that shall be used by implementers of a compiler or other language tool in case a contradiction or ambiguous language is discovered.
TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_language_overview">2. Language Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO: Non-normative language overview, with references to detailed normative specifications of all features.</p>
</div>
<div class="paragraph">
<p><em>[Informative text</em></p>
</div>
<div class="paragraph">
<p>A "Hello world" program is often used to introduce a programming language. In Kotlin it may looks as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun main(args: Array&lt;String&gt;) {
    println("Hello world")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>End of informative text]</em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compilation_process">3. Compilation Process</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_3">3.1. General</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_compiler_input_and_output">3.2. Compiler Input and Output</h3>
<div class="paragraph">
<p>TODO: Describe what files and streams can be input and output of the compiler.</p>
</div>
</div>
<div class="sect2">
<h3 id="_command_line">3.3. Command Line</h3>
<div class="paragraph">
<p>TODO: Describe encoding, parsing rules, syntax of the command line, and meaning of supported
options.</p>
</div>
</div>
<div class="sect2">
<h3 id="_referenced_libraries">3.4. Referenced Libraries</h3>
<div class="sect3">
<h4 id="_general_4">3.4.1. General</h4>
<div class="paragraph">
<p>TODO: Describe how libraries can be referenced from a compilation, how possible conflicts are handled, how ill-formed libraries are handled, and what is an effect (if any) of an order in which libraries are referenced.</p>
</div>
</div>
<div class="sect3">
<h4 id="_standard_library">3.4.2. Standard Library</h4>
<div class="paragraph">
<p>TODO: Describe what the standard library is, whether it has to be explicitly referenced, and what happens if it is ill-formed or does not contain some symbols that are assumed to exist in this specification.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_source_files">3.5. Source Files</h3>
<div class="sect3">
<h4 id="_general_5">3.5.1. General</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_supported_encodings">3.5.2. Supported Encodings</h4>
<div class="paragraph">
<p>TODO
An implementation may choose to represent all source files in UTF-16 and support only non-surrogate Unicode characters up to U+FFFF. Thus, characters that require a surrogate pair to be represented in UTF-16 would not be allowed on such implementations. For maximum portability, it is recommended that Kotlin programs do not use Unicode characters above U+FFFF.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ordering_of_source_files">3.5.3. Ordering of Source Files</h4>
<div class="paragraph">
<p>TODO: Describe what is an effect (if any) of an order in which source files are provided to the compiler.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parsing">3.6. Parsing</h3>
<div class="paragraph">
<p>TODO: Give an overview of a parsing process, with a reference to detailed specification in §?.</p>
</div>
</div>
<div class="sect2">
<h3 id="_target_platforms">3.7. Target Platforms</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_java_virtual_machine_2">3.7.1. Java Virtual Machine</h4>
<div class="paragraph">
<p>Platform Limitations</p>
</div>
<div class="paragraph">
<p>TODO: No dynamic type</p>
</div>
</div>
<div class="sect3">
<h4 id="_ecmascript_2">3.7.2. ECMAScript</h4>
<div class="paragraph">
<p>Platform Limitations</p>
</div>
<div class="paragraph">
<p>TODO: Different behavior of numeric types</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_errors_warnings_and_messages">3.8. Errors, Warnings and Messages</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p>A compiler warning can be suppressed by applying the <code>kotlin.Suppress</code> annotation to the compilation unit, declaration or expression that contains the warning.</p>
</div>
<div class="sect3">
<h4 id="_use_of_standard_output_and_standard_error_streams">3.8.1. Use of Standard Output and Standard Error Streams</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_early_compilation_termination">3.8.2. Early Compilation Termination</h4>
<div class="paragraph">
<p>Affected Files</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementation_limitations">3.9. Implementation Limitations</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_grammars_and_parsing">4. Grammars and Parsing</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_6">4.1. General</h3>
<div class="paragraph">
<p>A production from lexical grammar contains double colon after its name, a production from syntax grammar contains a single colon after its name. Each alternative is given on a separate line. If all alternatives are short (refer to only one production or terminal), they can be given on a single line after the words "one of". Subscript opt denotes that an element is optional. Terminals are given in bold monospace font.</p>
</div>
<div class="paragraph">
<p>TODO: Grammar notations used in this specification, and general parsing rules (longest match rule, etc.), trailing U+001A ?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the syntactic grammar, <code>&lt;nospace&gt;</code> between two terminals or grammar productions indicates that no characters (whitespace, comments, etc.) may appear between them.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_lexical_grammar">4.2. Lexical Grammar</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>input::</em></dt>
<dd>
<p><em>shebang<sub>opt</sub></em> <em>input-elements<sub>opt</sub></em> (TODO: implement standalone shebang)</p>
</dd>
<dt class="hdlist1"><em>shebang::</em></dt>
<dd>
<p><code>#!</code> <em>input-characters<sub>opt</sub></em></p>
</dd>
<dt class="hdlist1"><em>input-characters::</em></dt>
<dd>
<p><em>input-characters<sub>opt</sub> input-character</em></p>
</dd>
<dt class="hdlist1"><em>input-character::</em></dt>
<dd>
<p>Any Unicode character point except <em>new-line-character</em></p>
</dd>
<dt class="hdlist1"><em>new-line-character::</em></dt>
<dd>
<p><em>line-feed</em><br>
<em>carriage-return</em><br></p>
</dd>
<dt class="hdlist1"><em>new-line::</em></dt>
<dd>
<p><em>line-feed</em><br>
<em>carriage-return line-feed<sub>opt</sub></em><br></p>
</dd>
<dt class="hdlist1"><em>line-feed::</em></dt>
<dd>
<p>LINE FEED (U+000A)</p>
</dd>
<dt class="hdlist1"><em>carriage-return::</em></dt>
<dd>
<p>CARRIAGE RETURN (U+000D)</p>
</dd>
<dt class="hdlist1"><em>input-element::</em></dt>
<dd>
<p><em>whitespace</em><br>
<em>comment</em><br>
<em>token</em></p>
</dd>
<dt class="hdlist1"><em>whitespace::</em></dt>
<dd>
<p><em>new-line</em><br>
SPACE (U+0020)<br>
CHARACTER TABULATION (U+0009)<br>
FORM FEED (U+000C)<br></p>
</dd>
<dt class="hdlist1"><em>comment::</em></dt>
<dd>
<p><em>end-of-line-comment</em><br>
<em>delimited-comment</em></p>
</dd>
<dt class="hdlist1"><em>end-of-line-comment::</em></dt>
<dd>
<p><code>//</code> <em>input-characters<sub>opt</sub></em></p>
</dd>
<dt class="hdlist1"><em>delimited-comment::</em></dt>
<dd>
<p><code>/*</code> <em>delimited-comment-parts<sub>opt</sub> asterisks</em> <code>/</code></p>
</dd>
<dt class="hdlist1"><em>delimited-comment-parts::</em></dt>
<dd>
<p><em>delimited-comment-parts<sub>opt</sub> delimited-comment-part</em></p>
</dd>
<dt class="hdlist1"><em>delimited-comment-part::</em></dt>
<dd>
<p><em>delimited-comment</em><br>
<em>not-asterisk</em><br>
<em>asterisks not-slash-or-asterisk</em></p>
</dd>
<dt class="hdlist1"><em>asterisks::</em></dt>
<dd>
<p><em>asterisks<sub>opt</sub></em> <code>*</code></p>
</dd>
<dt class="hdlist1"><em>not-asterisk::</em></dt>
<dd>
<p>Any Unicode character except <code>*</code></p>
</dd>
<dt class="hdlist1"><em>not-slash-or-asterisk::</em></dt>
<dd>
<p>Any Unicode character except <code>*</code> and <code>/</code></p>
</dd>
<dt class="hdlist1"><em>token::</em></dt>
<dd>
<p><em>identifier</em><br>
<em>field-identifier</em><br>
<em>keyword</em><br>
<em>integer-literal</em><br>
<em>real-literal</em><br>
<em>char-literal</em><br>
<em>string-literal</em><br>
<em>operator</em></p>
</dd>
<dt class="hdlist1"><em>identifier::</em></dt>
<dd>
<p><em>regular-identifier</em><br>
<em>escaped-identifier</em></p>
</dd>
<dt class="hdlist1"><em>field-identifier::</em></dt>
<dd>
<p><code>$</code> &lt;nospace&gt; <em>identifier</em> (TODO: consider moving to syntax grammar)</p>
</dd>
<dt class="hdlist1"><em>regular-identifier::</em></dt>
<dd>
<p><em>keyword-or-identifier</em> other than a <em>keyword</em></p>
</dd>
<dt class="hdlist1"><em>keyword-or-identifier::</em></dt>
<dd>
<p><em>identifier-start identifier-parts<sub>opt</sub></em></p>
</dd>
<dt class="hdlist1"><em>identifier-start::</em></dt>
<dd>
<p><em>letter</em></p>
</dd>
<dt class="hdlist1"><em>letter::</em></dt>
<dd>
<p>Any Unicode character of classes Lu, Ll, Lt, Lm, Lo, or Nl</p>
</dd>
<dt class="hdlist1"><em>identifier-parts::</em></dt>
<dd>
<p><em>identifier-parts<sub>opt</sub> identifier-part</em></p>
</dd>
<dt class="hdlist1"><em>identifier-part::</em></dt>
<dd>
<p><em>identifier-start</em><br>
<em>digit</em></p>
</dd>
<dt class="hdlist1"><em>digit::</em></dt>
<dd>
<p>Any Unicode character of class Nd</p>
</dd>
<dt class="hdlist1"><em>escaped-identifier::</em></dt>
<dd>
<p><em>backtick escape-identifier-characters backtick</em> (TODO: Unicode escapes)</p>
</dd>
<dt class="hdlist1"><em>backtick::</em></dt>
<dd>
<p><code>`</code> GRAVE ACCENT (U+0060)</p>
</dd>
<dt class="hdlist1"><em>escape-identifier-characters::</em></dt>
<dd>
<p><em>escape-identifier-characters<sub>opt</sub> escape-identifier-character</em></p>
</dd>
<dt class="hdlist1"><em>escape-identifier-character</em></dt>
<dd>
<p>Any input-character except <em>backtick</em></p>
</dd>
<dt class="hdlist1"><em>keyword::</em></dt>
<dd>
<p>one of <code>as</code> <code>break</code> <code>class</code> <code>continue</code> <code>do</code> <code>else</code> <code>false</code> <code>for</code> <code>fun</code> <code>if</code> <code>in</code> <code>interface</code> <code>is</code> <code>null</code><br>
<code>object</code> <code>package</code> <code>return</code> <code>super</code> <code>this</code> <code>throw</code> <code>true</code> <code>try</code> <code>typealias</code> <code>val</code> <code>var</code> <code>when</code> <code>while</code><br>
Any <em>keyword-or-identifier</em> consisting of one or more characters <code>_</code></p>
</dd>
<dt class="hdlist1"><em>decimal-digit::</em></dt>
<dd>
<p>one of <code>0</code> <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code></p>
</dd>
<dt class="hdlist1"><em>integer-literal::</em></dt>
<dd>
<p><em>decimal-digits integer-literal-suffix<sub>opt</sub></em></p>
</dd>
<dt class="hdlist1"><em>integer-literal-suffix::</em></dt>
<dd>
<p><code>L</code></p>
</dd>
<dt class="hdlist1"><em>decimal-digits::</em></dt>
<dd>
<p><em>decimal-digits<sub>opt</sub> decimal-digit</em></p>
</dd>
<dt class="hdlist1"><em>float-literal::</em></dt>
<dd>
<p>TODO</p>
</dd>
<dt class="hdlist1"><em>hex-digit::</em></dt>
<dd>
<p><em>decimal-digit</em><br>
one of <code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code> <code>f</code> <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code></p>
</dd>
<dt class="hdlist1"><em>hex-digits::</em></dt>
<dd>
<p><em>hex-digits<sub>opt</sub> hex-digit</em></p>
</dd>
<dt class="hdlist1"><em>hex-literal::</em></dt>
<dd>
<p><code>0x</code> <em>hex-digits</em><br>
<code>0X</code> <em>hex-digits</em></p>
</dd>
<dt class="hdlist1"><em>char-literal::</em></dt>
<dd>
<p>TODO</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_identifiers">4.2.1. Identifiers</h4>
<div class="paragraph">
<p>An identifier can start with a letter or underscore, followed by zero or more letters, underscores or decimal digits. Any token of this form is an identifier, unless it is explicitly reserved as a keyword. Identifiers are case-sensitive: <code>kotlin</code>, <code>Kotlin</code> and <code>KOTLIN</code> are 3 different identifiers. A single underscore and sequences of 2, 3, etc. underscores are reserved keywords, but otherwise underscore is valid everywhere in an identifier. <em>[Note:</em> A digit is defined as a member of the Unicode class Nd. Note that it contains other characters beyond ten ASCII digits <code>0</code>-<code>9</code>. <em>End Note]</em> <em>[Note:</em> Unicode escape sequences are not supported in regular identifiers. <em>End Note]</em></p>
</div>
</div>
<div class="sect3">
<h4 id="_keywords">4.2.2. Keywords</h4>
<div class="paragraph">
<p>If a use of an identifier with a spelling matching a keyword is desired, an escaped identifier may be used.</p>
</div>
</div>
<div class="sect3">
<h4 id="_decimal_literals">4.2.3. Decimal Literals</h4>
<div class="paragraph">
<p>A decimal literal is a sequence of one or more ASCII decimal digits, followed by an optional <code>L</code> (LATIN CAPITAL LETTER L, U+004C). A literal without a suffix represents a constant value of type <code>Int</code> (TODO: it is more complicated). A literal with suffix <code>L</code> represents a constant value of type <code>Long</code>.</p>
</div>
<div class="paragraph">
<p>A decimal literal represents a constant value that results from interpreting the literal in decimal notation. The value of a literal must lie within the range of its type.</p>
</div>
<div class="paragraph">
<p><em>[Note:</em> Decimal literals always represent non-negative integers. For example, an expression <code>-5</code> is a unary operator <code>-</code> applied to its operand, a decimal literal <code>5</code>, rather than a single decimal literal. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>It is an error if a decimal literal other than <code>0</code> starts with digit <code>0</code>. <em>[Example:</em> Literals <code>00</code>, <code>007</code> are errors. <em>End Example]</em> <em>[Rationale:</em> Some programming languages use a leading zero to denote octal literals. Kotlin does not support octal literals, so without this rule there would be a possibility of difficult-to-catch mistakes when a user enters a literal starting with a leading zero and intends it to be interpreted as an octal literal, but the compiler simply drops leading zeros and interprets it as a decimal literal with a different numeric value than intended. <em>End Rationale]</em></p>
</div>
<div class="paragraph">
<p>It is an error if a decimal literal has an adjacent identifier or keyword before or after it without any characters separating these tokens. <em>[Example:</em> <code>0less1</code> is an error. <em>End Example]</em></p>
</div>
</div>
<div class="sect3">
<h4 id="_hexadecimal_literals">4.2.4. Hexadecimal Literals</h4>
<div class="paragraph">
<p>A hexadecimal literal consists of a prefix <code>0x</code> or <code>0X</code>, followed a sequence of one or more hexadecimal digits, followed by an optional <code>L</code> LATIN CAPITAL LETTER L (U+004C). A literal without a suffix represents a constant value of type <code>Int</code>. A literal with suffix <code>L</code> represents a constant value of type <code>Long</code>. A hexadecimal digit is an ASCII decimal digit or an upper-case or lower-case letter in the range <code>A</code>-<code>F</code> (corresponding upper-case and lower-case letters are equivalent, having numeric values 10-15, respectively). Prefixes <code>0x</code> and <code>0X</code> are equivalent.</p>
</div>
<div class="paragraph">
<p>A hexadecimal literal represents a constant value that results from interpreting the literal in hexadecimal notation (with leading zeros allowed). The value of a literal must lie within the range of its type.</p>
</div>
<div class="paragraph">
<p>TODO: overflow behavior</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_syntax_grammar">4.3. Syntax Grammar</h3>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>expression-or-block:</em></dt>
<dd>
<p><em>expression</em><br>
<em>assignment</em><br>
<em>block</em></p>
</dd>
<dt class="hdlist1"><em>expression:</em></dt>
<dd>
<p><em>disjunction</em></p>
</dd>
<dt class="hdlist1"><em>assignment:</em></dt>
<dd>
<p><em>assignable-expression assignment-operator disjunction</em></p>
</dd>
<dt class="hdlist1"><em>assignment-operator:</em></dt>
<dd>
<p><code>=</code><br>
<code>+=</code><br>
<code>-=</code><br>
<code>*=</code><br>
<code>/=</code><br>
<code>%=</code></p>
</dd>
<dt class="hdlist1"><em>disjunction:</em></dt>
<dd>
<p><em>conjunction</em><br>
<em>disjunction</em> <code>||</code> <em>conjunction</em></p>
</dd>
<dt class="hdlist1"><em>conjunction:</em></dt>
<dd>
<p><em>equality</em><br>
<em>conjunction</em> <code>&amp;&amp;</code> <em>equality</em></p>
</dd>
<dt class="hdlist1"><em>equality:</em></dt>
<dd>
<p><em>comparison</em><br>
<em>equality equality-operator comparison</em></p>
</dd>
<dt class="hdlist1"><em>equality-operator:</em></dt>
<dd>
<p><code>==</code><br>
<code>!=</code><br>
<code>===</code><br>
<code>!==</code></p>
</dd>
<dt class="hdlist1"><em>comparison:</em></dt>
<dd>
<p><em>infix-operation</em><br>
<em>comparison comparison-operator infix-operation</em></p>
</dd>
<dt class="hdlist1"><em>comparison-operator:</em></dt>
<dd>
<p><code>&gt;</code><br>
<code>&lt;</code><br>
<code>&gt;=</code><br>
<code>&lt;=</code></p>
</dd>
<dt class="hdlist1"><em>infix-operation:</em></dt>
<dd>
<p><em>elvis-expression</em><br>
<em>elvis-expression is-operator type</em><br>
<em>infix-operation in-operator elvis-expression</em></p>
</dd>
<dt class="hdlist1"><em>is-operator:</em></dt>
<dd>
<p><code>is</code><br>
<code>!</code> &lt;nospace&gt; <code>is</code></p>
</dd>
<dt class="hdlist1"><em>in-operator:</em></dt>
<dd>
<p><code>in</code><br>
<code>!</code> &lt;nospace&gt; <code>in</code></p>
</dd>
<dt class="hdlist1"><em>elvis-expression:</em></dt>
<dd>
<p><em>infix-function-call</em><br>
<em>elvis-expression</em> <code>?:</code> <em>infix-function-call</em></p>
</dd>
<dt class="hdlist1"><em>infix-function-call:</em></dt>
<dd>
<p><em>range-expression</em><br>
<em>infix-function-call simple-name range-expression</em></p>
</dd>
<dt class="hdlist1"><em>range-expression:</em></dt>
<dd>
<p><em>additive-expression</em><br>
<em>range-expression</em> <code>..</code> <em>additive-expression</em></p>
</dd>
<dt class="hdlist1"><em>additive-expression:</em></dt>
<dd>
<p><em>multiplicative-expression</em><br>
<em>additive-expression additive-operator multiplicative-expression</em></p>
</dd>
<dt class="hdlist1"><em>additive-operator:</em></dt>
<dd>
<p><code>+</code><br>
<code>-</code></p>
</dd>
<dt class="hdlist1"><em>multiplicative-expression:</em></dt>
<dd>
<p><em>as-expression</em><br>
<em>multiplicative-expression multiplicative-operator as-expression</em></p>
</dd>
<dt class="hdlist1"><em>multiplicative-operator:</em></dt>
<dd>
<p><code>*</code><br>
<code>/</code><br>
<code>%</code></p>
</dd>
<dt class="hdlist1"><em>as-expression:</em></dt>
<dd>
<p><em>prefix-unary-expression</em><br>
<em>as-expression as-operator type</em></p>
</dd>
<dt class="hdlist1"><em>as-operator:</em></dt>
<dd>
<p><code>as</code><br>
<code>as</code> &lt;nospace&gt; <code>?</code></p>
</dd>
<dt class="hdlist1"><em>prefix-unary-expression:</em></dt>
<dd>
<p><em>postfix-unary-expression</em><br>
<em>prefix-unary-operator prefix-unary-expression</em><br>
<em>annotation prefix-unary-expression</em><br>
<em>label prefix-unary-expression</em></p>
</dd>
<dt class="hdlist1"><em>prefix-unary-operator:</em></dt>
<dd>
<p><code>+</code><br>
<code>-</code><br>
<code>++</code><br>
<code>--</code><br>
<code>!</code></p>
</dd>
<dt class="hdlist1"><em>annotation:</em></dt>
<dd>
<p>TODO</p>
</dd>
<dt class="hdlist1"><em>label:</em></dt>
<dd>
<p>TODO</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><em>postfix-unary-expression:</em>
	<em>assignable-expression</em><br>
	<em>invocation-expression</em><br>
	<em>postfix-unary-expression postfix-unary-operator</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>postfix-unary-operator:</em></dt>
<dd>
<p><code>++</code><br>
<code>--</code><br>
<code>!!</code></p>
</dd>
<dt class="hdlist1"><em>assignable-expression:</em></dt>
<dd>
<p><em>primary-expression</em><br>
<em>indexing-expression</em><br>
<em>member-access</em></p>
</dd>
<dt class="hdlist1"><em>primary-expression:</em></dt>
<dd>
<p><em>parenthesized-expression</em><br>
<em>literal</em><br>
<em>function-literal</em><br>
<em>this-expression</em><br>
<em>super-expression</em><br>
<em>object-literal</em><br>
<em>simple-name</em><br>
<em>field-name</em><br>
<em>callable-reference</em><br>
<em>package-expression</em><br>
<em>jump-expression</em><br>
<em>conditional-expression</em><br>
<em>loop-expression</em><br>
<em>try-expression</em></p>
</dd>
<dt class="hdlist1"><em>callable-reference:</em></dt>
<dd>
<p><code>::</code> <em>simple-name</em><br>
TODO (qualified reference)</p>
</dd>
<dt class="hdlist1"><em>parenthesized-expression:</em></dt>
<dd>
<p><code>(</code> <em>expression</em> <code>)</code></p>
</dd>
<dt class="hdlist1"><em>literal:</em></dt>
<dd>
<p><em>boolean-literal</em><br>
<em>integer-literal</em><br>
<em>float-literal</em><br>
<em>character-literal</em><br>
<em>string-literal</em><br>
<em>null-literal</em></p>
</dd>
<dt class="hdlist1"><em>boolean-literal:</em></dt>
<dd>
<p><code>true</code><br>
<code>false</code></p>
</dd>
<dt class="hdlist1"><em>null-literal:</em></dt>
<dd>
<p><code>null</code></p>
</dd>
<dt class="hdlist1"><em>this-expression:</em></dt>
<dd>
<p><code>this</code> <em>label-reference<sub>opt</sub></em></p>
</dd>
<dt class="hdlist1"><em>super-expression:</em></dt>
<dd>
<p><code>super</code> <em>supertype-reference<sub>opt</sub></em> label-referenceopt</p>
</dd>
<dt class="hdlist1"><em>supertype-reference:</em></dt>
<dd>
<p><code>&lt;</code> <em>type</em> <code>&gt;</code></p>
</dd>
<dt class="hdlist1"><em>label-reference:</em></dt>
<dd>
<p><code>@</code> &lt;nospace&gt; <em>identifier</em></p>
</dd>
<dt class="hdlist1"><em>invocation-expression:</em> </dt>
<dd>
<p><em>postfix-unary-expression type-arguments<sub>opt</sub> argument-list<sub>opt</sub> trailing-lambda</em><br>
<em>postfix-unary-expression type-arguments<sub>opt</sub> argument-list</em><br>
<em>postfix-unary-expression type-arguments</em></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>TODO: Specify rules that guarantee correct grouping in parsing of types <code>() -&gt; Int?</code> and <code>() -&gt; Unit.() -&gt; Unit</code>.
TODO: Specify places where parsing as blocks is preferred to parsing as function literals (<code>if</code>, <code>else</code>, <code>when</code>, loops).
Block is parsed as a function literal if it has at least one leading label or annotation (only if there is a potential ambiguity&#8201;&#8212;&#8201;there are places where it can only be parsed as a block, e.g. after <code>try</code> keywords, and no labels or annotations are allowed there). Parsing of else branches in nested <code>if</code> statements (possibly within a <code>when</code> statement). When newline commits a statement, and when statement is parsed greedily.</p>
</div>
<div class="paragraph">
<p>Possible empty statements: <code>if(true) else;</code></p>
</div>
<div class="paragraph">
<p><em>[Example:</em> Parsing functional types before <code>-&gt;</code> token in lambdas and with statements. <em>End Example]</em></p>
</div>
<div class="paragraph">
<p><em>[Note: Parenthesization or leading <code>-&gt;</code> forces parsing of a block as a function literal. _End Note]</em></p>
</div>
<div class="sect3">
<h4 id="_grammar_ambiguities">4.3.1. Grammar Ambiguities</h4>
<div class="paragraph">
<p>TODO: Specify what are possible grammar ambiguities (if any), and how they shall be handled.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_symbols">5. Symbols</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_7">5.1. General</h3>
<div class="paragraph">
<p>Programs can declare and reference different kinds of entities called symbols. Examples of symbols are  packages, classes, functions, parameters or variables. A symbol can have a name, or can be anonymous. Symbols can be introduced using syntactic constructs called declarations, or be implicitly declared. Every symbol that is not a package can have at most one declaration. A package can have one or more declarations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_declaring_symbol">5.2. Declaring Symbol</h3>
<div class="paragraph">
<p>Every symbol (except TODO?) has exactly one declaring symbol. Usually, the declaration of a symbol is immediately textually contained within the declaration of its declaring symbol. For example, the declaring symbol of a method is the class in which it is declared, and the declaring symbol of a parameter is the method in which signature the parameter occurs. Sometimes, but not always, a symbol is a member of its declaring symbol. In the previous example, the method is a member of its declaring class, but the parameter is not a member of its declaring method.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implicit_declarations">5.3. Implicit Declarations</h3>
<div class="paragraph">
<p>TODO: What symbols can be declared implicitly (e.g. default constructor, or <code>it</code> parameter in lambdas, <code>field</code> in accessors).</p>
</div>
</div>
<div class="sect2">
<h3 id="_modifiers">5.4. Modifiers</h3>
<div class="paragraph">
<p>Syntax for some declarations allow to provide a modifier list that may contain zero or more modifiers. Each declaration kind can have its own rules governing allowed modifiers and valid combinations of them, but general rules are given in this section.</p>
</div>
<div class="paragraph">
<p>A modifier is one of the following keywords:</p>
</div>
<div class="paragraph">
<p><code>abstract</code> <code>annotation</code> <code>companion</code> <code>crossinline</code> <code>data</code> <code>enum</code> <code>external</code> <code>final</code> <code>in</code> <code>infix</code> <code>inline</code> <code>inner</code> <code>internal</code> <code>lateinit</code> <code>noinline</code> <code>open</code> <code>operator</code> <code>out</code> <code>override</code> <code>private</code> <code>protected</code> <code>public</code> <code>reified</code> <code>sealed</code> <code>tailrec</code> <code>vararg</code></p>
</div>
<div class="paragraph">
<p>Among those, only <code>in</code> is a hard keyword, all others are soft keywords that are reserved only in a modifier position.</p>
</div>
<div class="paragraph">
<p>An order of modifiers in a modifier list is not significant. The same modifier cannot appear more than once in the same modifier list. Modifiers <code>public</code>, <code>private</code>, <code>protected</code> and <code>internal</code> are called <em>visibility modifiers</em>, they are used to specify the visibility of a declared symbol. Only declarations of type members can have <code>protected</code> modifier.</p>
</div>
<div class="paragraph">
<p>The following pairs of modifiers are incompatible in the same modifier list (in any order, possibly separated by other modifiers):</p>
</div>
<div class="paragraph">
<p><code>final</code> <code>open</code><br>
<code>final</code> <code>abstract</code><br>
<code>final</code> <code>sealed</code><br>
<code>open</code> <code>sealed</code><br></p>
</div>
<div class="paragraph">
<p>The modifier <code>open</code> is redundant if <code>abstract</code> is specified. Modifier <code>abstract</code> is redundant if <code>sealed</code> is specified.</p>
</div>
</div>
<div class="sect2">
<h3 id="_visibility">5.5. Visibility</h3>
<div class="paragraph">
<p>Every symbol has an associated visibility domain&#8201;&#8212;&#8201;a region or regions of program text where it could be referenced from explicitly or implicitly. Explicit reference to a symbol involves a textual usage of its name (at least simple name), while implicit does not. Every case that constitutes an implicit reference to a symbol is explicitly called out in the specification. <em>[Example:</em> Declaration of an implicitly typed local variable whose type <code>T</code> is inferred from its initializer constitutes an implicit reference to the type <code>T</code>. <em>End Example]</em> The visibility domain of a symbol <code>S</code> is the intersection of the visibility domain of its declaring symbol and the declared visibility of the symbol <code>S</code>. In case <code>S</code> does not have a declaring symbol, its visibility domain is just its declared visibility.</p>
</div>
<div class="sect3">
<h4 id="_declared_visibility">5.5.1. Declared Visibility</h4>
<div class="paragraph">
<p>The declared visibility of a symbol is determined by a visibility modifier present at the symbol declaration, if any.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_packages">5.6. Packages</h3>
<div class="paragraph">
<p>All declarations in a program are grouped in packages. Different packages can have declarations of the same kind and with the same simple. Thus, packages allow to avoid name clashes, serve as namespaces and enable grouping of the symbols having related functionality. A package name is a sequence of one of more (not necessary distinct) identifiers separated by dots. There is also a single default package that has no name.</p>
</div>
<div class="paragraph">
<p>TODO: define "module"</p>
</div>
<div class="paragraph">
<p>A single module can contain declarations from multiple packages, and symbols in the same package can be declared in different modules. Declarations in a single file always introduce symbols into the same package, whose name specified in the package directive in the file header. If a file contains no package directive, the declarations in this file introduce symbols into the default package.</p>
</div>
</div>
<div class="sect2">
<h3 id="_classes">5.7. Classes</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_interfaces">5.8. Interfaces</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_properties_and_fields">5.9. Properties and Fields</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_methods_and_functions">5.10. Methods and Functions</h3>
<div class="sect3">
<h4 id="_general_8">5.10.1. General</h4>
<div class="paragraph">
<p>A function is a callable fragment of code that has zero or more parameters, a return value and a set of local variables. Each invocation of a function creates a separate set of storage locations for its parameters and local variables, independent from other invocations of the same function, referred to as a logical stack frame. A logical stack frame can be different from a physical stack frame because of tail call optimizations, inlining and other reasons. Lifetime of some parameters and variables can follow special rules if they are captured in a closure (§Closure).</p>
</div>
<div class="paragraph">
<p>Evaluation of a function can cause an invocation of another function (or a recursive invocation of the same function) that effectively suspends evaluation of the current function, pushes a new frame on the call stack, and transfers control flow to the beginning of the body of the callee. If evaluation of a function completes normally, the topmost stack frame is discarded, and control flow is returned back to its caller, and its evaluation is resumed at the point immediately following the invocation (the return value, becomes the value of the completed invocation  expression). Evaluation of a function can also result in an exception (§Exception), which can be either caught and handled inside the same function, or result in an abrupt completion of the function, and propagation of the exception along the stack to a closest direct or indirect caller that can catch and handle it.</p>
</div>
<div class="paragraph">
<p>Functions can be either named or anonymous (lambdas). Named functions can be either top-level functions, local functions or member functions (methods).</p>
</div>
</div>
<div class="sect3">
<h4 id="_type_parameter_list">5.10.2. Type-parameter List</h4>
<div class="paragraph">
<p>A type-parameter list specifies names and bounds of the type-parameters of a function. Syntactically, a type-parameter list is one or more type-parameter declarations, separated by commas, and enclosed in angle brackets. Names of all type-parameters within a type-parameter list must be distinct.</p>
</div>
<div class="paragraph">
<p>TODO: type-parameter lists in generic types</p>
</div>
</div>
<div class="sect3">
<h4 id="_parameter_list">5.10.3. Parameter List</h4>
<div class="paragraph">
<p>A parameter list specifies names and types of the parameters of a function. Syntactically, a parameter list is zero or more parameter declarations, separated by commas, and enclosed in parentheses. Names of all formal parameters in a formal parameter list must be distinct. A name of a formal parameter in a formal parameter list cannot be the same as a name of a type-parameter in a type-parameter list associated with the same function declaration.</p>
</div>
<div class="paragraph">
<p><em>[Example:</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T&gt; f(T : Int) // error</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>End example]</em></p>
</div>
<div class="paragraph">
<p>TODO: type-parameter list, parameter list.</p>
</div>
</div>
<div class="sect3">
<h4 id="_generic_functions">5.10.4. Generic Functions</h4>
<div class="paragraph">
<p>A function whose declaration includes a type-parameter list is a generic function.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_local_and_top_level_functions">5.10.5. Local and Top-Level Functions</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_locals">5.11. Locals</h3>
<div class="paragraph">
<p>Read-only local variables are declared using <code>val</code> keyword. Mutable local variables are declared using <code>var</code> keyword.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parameters">5.12. Parameters</h3>
<div class="paragraph">
<p>Parameters behave similarly to local variables. They are always immutable and always definitely assigned. Lifetime of parameters and their behavior when captured in a closure are the same as for local variables.
TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_singleton_objects">5.13. Singleton Objects</h3>
<div class="paragraph">
<p>An object declaration introduces two symbols of different kinds, but with the same name: a class and a value that is the only instance of that class. The class is final and is guaranteed to have exactly one instance. <em>[Note:</em> there are some caveats about initialization time of such instances in cases their declaration depend on each other in a circular manner. <em>End Note]</em> Unless explicitly stated otherwise, object declarations follow the same rules as class declarations. An object declaration can specify a superclass and zero or more superinterfaces. An object declaration cannot have type-parameters, and cannot access type-parameters from an outer scope. The only modifiers allowed on an object declaration are: <code>companion</code>, <code>final</code>, <code>internal</code>, <code>private</code>, <code>protected</code>, <code>public</code>. An object declaration cannot be <code>inner</code>, <code>open</code> or <code>abstract</code>. Although the <code>final</code> modifier is allowed, it is completely redundant on object declarations. An object declaration can have no constructors declarations (but has an implicit private parameterless primary constructor that is automatically invoked during object initialization, and can contain <code>init</code> blocks that are executed as parts of that primary constructor). An object declaration cannot be local, and cannot be enclosed in a local class declaration. An object declaration can be top-level or be declared within a class declaration, an interface declaration, or an object declaration (possibly, within a companion object). An object declaration cannot access <code>this</code> instances of enclosing types either explicitly or implicitly. [TODO: clarify logical connectives in this section]</p>
</div>
<div class="paragraph">
<p>A class nested immediately within a singleton object cannot be an inner class (but it is possible to have an inner class deeper in the nesting hierarchy).</p>
</div>
<div class="paragraph">
<p>A singleton object (except companion objects) cannot declare a member with the <code>protected</code> modifier, and cannot declare a property whose accessor has the <code>protected</code> modifier.</p>
</div>
<div class="paragraph">
<p>Singleton objects are initialized in an order determined by trying to topologically sort them by their dependencies. In case of an initialization cycle a complete topological sort is impossible, and it is possible to observe the value of an object involved in the cycle as <code>null</code>. This can cause an exception if this value is passed to a function expecting a non-nullable type.</p>
</div>
<div class="paragraph">
<p><em>[Example:</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>abstract class A(val x : Any?)
object B : A(C)
object C : A(B)

fun main(args: Array&lt;String&gt;) {
    println(B.x)
    println(C.x) // null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>End Example]</em></p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_companion_objects">5.13.1. Companion Objects</h4>
<div class="paragraph">
<p>Companion object can be declared within classes or interfaces, including generic ones. An optional name can be specified for a companion object, if no name is specified, the default name <code>Companion</code> is used. The name of a companion object (either explicit or default) must be distinct from names of all other members declared in the containing type. No more than one companion object per class or interface is allowed. When the name of a companion object is accessed through dot on the name of the containing class or interface, no type-arguments can be provided to the containing type name, even if the type containing is generic. A companion object can specify at most one superclass and zero or more superinterfaces. <em>[Note:</em> There is no rule that would prevent the supertype of a companion object to be the containing type of the companion object. In such a case, if the containing type is generic then type-arguments must be provided after its name in the supertype list of the companion object declaration, but those type-arguments cannot use type-parameters of the containing type, because they are not in scope throughout the companion object declaration. <em>End Note]</em>.</p>
</div>
<div class="paragraph">
<p>The body of a companion object is optional. If no body is provided, the empty body <code>{ }</code> is assumed. Members of a companion object can be accessed directly through the dot on its containing type name (no type-arguments must be provided even if the containing type is generic). The name of a companion object hides its identically named members in this context (the hidden members are still available by lookup in the name of the companion object in this case). [Example: TODO End example] TODO: This hiding behavior is actually not that simple for method names.</p>
</div>
<div class="paragraph">
<p>A type and its companion object have access to private members of each other, regardless of declared visibility of the companion object.</p>
</div>
<div class="paragraph">
<p>If a companion object is declared within a generic type, there is still only one instance of a companion object, despite that potentially multiple instantiations of the generic type is possible. Type-parameters of containing types are not available in the declaration of a companion object.</p>
</div>
<div class="paragraph">
<p>A companion object cannot be declared within a local or inner class.</p>
</div>
<div class="paragraph">
<p>Declared visibility <code>private</code> or <code>protected</code> of members of a companion object is understood with respect to its container type rather than to the companion object itself (TODO: implementation bug with <code>protected</code>).</p>
</div>
<div class="paragraph">
<p>TODO: What does it mean for a companion object to be private.</p>
</div>
<div class="paragraph">
<p>TODO: The name of a containing type can itself be used as an expression that refers to the companion object.</p>
</div>
</div>
<div class="sect3">
<h4 id="_labels">5.13.2. Labels</h4>
<div class="paragraph">
<p>Certain locations in code can be named for later reference by declaring labels.</p>
</div>
<div class="paragraph">
<p>TODO: Declaration space and scope for labels</p>
</div>
<div class="paragraph">
<p>Implicitly Declared Labels
TODO</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_values_and_types">6. Values and Types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_9">6.1. General</h3>
<div class="paragraph">
<p>A value can be a reference to an object, the null value (a special value compatible with any nullable value type and distinct from a reference to any object) or a primitive value.</p>
</div>
<div class="paragraph">
<p>It is up to an implementation to choose (for performance optimization, memory optimizations or any other reason) how to store a primitive value in each particular case. This choice does not have to be uniform across the program. A variable can store a primitive value directly, or store a reference to a boxed copy of a primitive value&#8201;&#8212;&#8201;the language does not provide any means to force either behavior. There can exist multiple references to the same boxed instance, and there can be multiple boxed copies of the same primitive value. A result of the reference equality operator applied to primitive types is unspecified.</p>
</div>
<div class="paragraph">
<p>Variables of reference types store references to objects rather than objects themselves. An object reference points to an instance of a reference type. Multiple variables can store references to the same object, and any modifications to the object made through one of those references are observable through all the others. As many references to a single object as needed can be created by a simple assignment (and some other language constructs), but in general there is no way to create a copy of an object instance, unless this feature is explicitly supported by its class. The terms "object" and "object instance" are considered synonyms and are used interchangeably throughout this specification.</p>
</div>
<div class="paragraph">
<p>Lifetime of objects are managed automatically. There is no need or possibility to explicitly destroy object instances after they are created. An object instance is guaranteed to exists as long as there is at least one reference to it that can be used in an observable way on at least one possible control flow path through the current program (but is permitted to exist longer than required). Provided that this guarantee is satisfied, it is otherwise up to an implementation to decide when objects are destroyed and when memory occupied by them is reclaimed and made available for future allocations. <em>[Note:</em> A particular platform may choose to provide an API to monitor or control this process to some degree, but such an API is not required by the language and is out of scope of this specification. <em>End note]</em></p>
</div>
<div class="paragraph">
<p>The null value is a special immutable atomic (structureless) value. Its exact type is <code>Nothing?</code> (it is the only value of this type), and it also belong to every nullable type, usually indicating an absence of any valid value of the corresponding non-nullable type.</p>
</div>
<div class="paragraph">
<p>TODO: Move detailed discussion of arrays to corresponding section?</p>
</div>
<div class="paragraph">
<p>An object can be considered an instance of multiple (a finite or infinite number) different types, but the set of these types always contains a single type that is a subtype of every other type in the set and is called the exact type of the object. The exact type of an object is always either a concrete (not-abstract) class or an array type. <em>[Example:</em> TODO <em>End example]</em></p>
</div>
<div class="paragraph">
<p>An object is either an instance of a class, or an instance of an array type. An array type is either generic class <code>Array&lt;T&gt;</code> or one of the types representing arrays of primitives:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BooleanArray</code>&#8201;&#8212;&#8201;an array of values of type <code>Boolean</code></p>
</li>
<li>
<p><code>ByteArray</code>&#8201;&#8212;&#8201;an array of values of type <code>Byte</code></p>
</li>
<li>
<p><code>ShortArray</code>&#8201;&#8212;&#8201;an array of values of type <code>Short</code></p>
</li>
<li>
<p><code>IntArray</code>&#8201;&#8212;&#8201;an array of values of type <code>Int</code></p>
</li>
<li>
<p><code>LongArray</code>&#8201;&#8212;&#8201;an array of values of type <code>Long</code></p>
</li>
<li>
<p><code>CharArray</code>&#8201;&#8212;&#8201;an array of values of type <code>Char</code></p>
</li>
<li>
<p><code>FloatArray</code>&#8201;&#8212;&#8201;an array of values of type <code>Float</code></p>
</li>
<li>
<p><code>DoubleArray</code>&#8201;&#8212;&#8201;an array of values of type <code>Double</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Arrays are different from classes with respect to how they store their data. A class always have a fixed number of storage locations (called fields), the fields potentially can have types, and each instance whose exact type if the class will have that fixed number of fields. If an object with a different number of fields is needed, it is necessary to declare a new class. An array type, on the other side, only defines a type of its storage locations (called elements), but leaves their number undefined. The number of elements of an array is specified only at runtime when a particular instance of that array type is created (this number can be zero or more, and is limited only by platform or available memory). This number remains constant during the whole lifetime of that particular instance, but can be different for different instances although they all belong to the same array type. Also, unlike fields of a class that can be declared immutable and therefore their values cannot be changed after the instance is created, all array elements are always mutable. A field is referred to by its name (or, indirectly, by a name of the corresponding property), but an array element is referred to by its index. An index indicates an offset from the first element of the array (so that the first element has index 0, the second element has index 1, and so on to the last element of the array whose index is equal to the length of the array minus one). [Note: This is known as the zero-based indexing. End note] Indices less than 0, or greater or equal to the length of the array are invalid, and an attempt to access an element by such an index will result in an exception (WHICH?) at runtime. An array of length 0 is called an empty array, and it has no valid indices&#8201;&#8212;&#8201;any attempt to access its element results in an exception.</p>
</div>
<div class="paragraph">
<p><em>[Note:</em> It should not be expected that an implementation will try to pack elements of <code>BooleanArray</code> to use only 1 bit of storage per element. Normally, 1 byte of storage per element will be used. <em>End Note]</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO: Sort out terminology: we say that <code>Array&lt;T&gt;</code> is a class, but make a distinction between array instances and class instances.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each value has a type. A type is an abstraction capturing common characteristics (e.g. a set of supported operations and information about their possible results) of a family of similar values. Informally, values that belong to the same type are either identical or have similar shape and behavior. The exact scope of this similarity is detailed in this specification. Usually, many different values belong to the same type, but there are types having only a single value, and there are also uninhabited types having no values&#8201;&#8212;&#8201;they are purely compile-time abstractions, sometimes intentional (like the <code>Nothing</code> type), sometimes just a byproduct of the imperfect type system. Ideally, types that have the same set of values and allow the same set of operations on them would be always considered identical. In fact, the type system only provides an approximation to this goal.</p>
</div>
<div class="paragraph">
<p>While exact values of expressions are usually known only at runtime (except constant expressions that are fully evaluated at compile time), types can be known at compile time, so the compiler can reason about them, and guarantee certain desirable properties of a program (e.g. that a certain method is never invoked on an object that does not support it).</p>
</div>
<div class="paragraph">
<p>One of the main purposes of the Kotlin type system is to maintain the following conditions: a storage location can only contain a value that matches its compile-time type, and the result of evaluation of an expression can only be a value that matches its compile-time type. This condition is guaranteed to hold, except in a few special circumstances: a heap pollution, a null leak, or an abuse of reflection. All this circumstances are explained in details in corresponding sections of the specification (§TODO).</p>
</div>
<div class="paragraph">
<p>Values and types are distinct notions and they do not mix (unlike in some programming languages featuring dependent types). Nonetheless, some types can be described using values of type <code>KClass&lt;T&gt;</code>, and their properties can be queried at runtime, using a technique called reflection. It is important to remember that those values are not types, they just describe or represent types.</p>
</div>
<div class="paragraph">
<p>Each value has a single exact type. This is the narrowest type representable in the language, to which the value belongs.</p>
</div>
<div class="paragraph">
<p>A type can also be thought as representing a set of all possible values having this type. If a type A represents a subset of values, represented by a type B, the type A &#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>TODO: only subtyping defined by rules</p>
</div>
<div class="paragraph">
<p>TODO: exact type, reflection and erasure</p>
</div>
</div>
<div class="sect2">
<h3 id="_syntax_for_types">6.2. Syntax for Types</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p>A type can be parenthesized, it does not change its meaning.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compile_time_and_run_time_types">6.3. Compile-time and Run-time Types</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_reified_types">6.4. Reified Types</h3>
<div class="paragraph">
<p>An inferred type-argument that is a skolem type variable cannot be used as a type-argument for a reified type-parameter.
The types <code>kotlin.Nothing</code> and <code>kotlin.Nothing?</code> cannot be used as type-arguments for a reified type-parameter.</p>
</div>
<div class="paragraph">
<p>DISCUSS: Report an error for: <code>inline fun &lt;reified T : Nothing?&gt; foo(x : T) { }</code></p>
</div>
<div class="paragraph">
<p>A type-parameter of a function can be marked as <code>reified</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>inline fun foo&lt;reified T&gt;() {}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_semantics_checks_and_restrictions">6.4.1. Semantics, Checks and Restrictions</h4>
<div class="ulist">
<ul>
<li>
<p>Definition</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A well-formed type is called <em>runtime-available</em> if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it has the form <code>C</code>, where <code>C</code> is a classifier (object, class or interface) that has either no type-parameters, or all its type-parameters are <code>reified</code>, with the exception for class <code>Nothing</code>,</p>
</li>
<li>
<p>it has the form <code>G&lt;A1, &#8230;&#8203;, An&gt;</code>, where <code>G</code> is a classifier with <code>n</code> type-parameters, and for every type-parameter <code>Ti</code> at least one of the following conditions hold:</p>
</li>
<li>
<p><code>Ti</code> is a <code>reified</code> type-parameter and the corresponding type-argument <code>Ai</code> is a runtime-available type,</p>
</li>
<li>
<p><code>Ai</code> is a star-projection (e.g. for <code>List&lt;*&gt;</code>, <code>A1</code> is a star-projection);</p>
</li>
<li>
<p>it has the form <code>T</code>, and <code>T</code> is a <code>reified</code> type-parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Runtime-available types: <code>String</code>, <code>Array&lt;String&gt;</code>, <code>List&lt;*&gt;</code>.</p>
</li>
<li>
<p>Non-runtime-available types: <code>Nothing</code>, <code>List&lt;String&gt;</code>, <code>List&lt;T&gt;</code> (for any <code>T</code>).</p>
</li>
<li>
<p>Conditional: <code>T</code> is runtime-available iff the type-parameter <code>T</code> is <code>reified</code>, same for <code>Array&lt;T&gt;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Only runtime-available types are allowed as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>right-hand arguments for <code>is</code>, <code>!is</code>, <code>as</code>, <code>as?</code>.</p>
</li>
<li>
<p>arguments for <code>reified</code> type-parameters <strong>of calls</strong> (for types any arguments are allowed, i.e. <code>Array&lt;List&lt;String&gt;&gt;</code> is still a valid type).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As a consequence, if <code>T</code> is a <code>reified</code> type-parameter, the following constructs are allowed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>x is T</code>, <code>x !is T</code></p>
</li>
<li>
<p><code>x as T</code>, <code>x as? T</code></p>
</li>
<li>
<p>reflection access on <code>T</code>: <code>javaClass&lt;T&gt;()</code>, <code>T::class</code> (when supported)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Restrictions regarding reified type-parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Only a type-parameter of an <code>inline</code> function can be marked <code>reified</code>.</p>
</li>
<li>
<p>The built-in class <code>Array&lt;T&gt;</code> is the only class whose type-parameter is marked <code>reified</code>. Other classes are not allowed to declare <code>reified</code> type-parameters.</p>
</li>
<li>
<p>Only a runtime-available type can be passed as an argument to a <code>reified</code> type-parameter.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>No warning is issued on <code>inline</code> functions declaring no inlinable parameters of function types, but having a <code>reified</code> type-parameter declared.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_notes_for_the_jvm">6.4.2. Implementation notes for the JVM</h4>
<div class="paragraph">
<p>TODO: Move to JVM section of the spec.</p>
</div>
<div class="paragraph">
<p>In inline functions, occurrences of a <code>reified</code> type-parameter <code>T</code> are replaced with the actual type-argument. If actual type-argument is a primitive type, its wrapper will be used within reified bytecode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>open class TypeLiteral&lt;T&gt; {
    val type: Type
        get() = (javaClass.getGenericSuperclass() as ParameterizedType).getActualTypeArguments()[0]
}

inline fun &lt;reified T&gt; typeLiteral(): TypeLiteral&lt;T&gt; = object : TypeLiteral&lt;T&gt;() {} // here T is replaced with the actual type

typeLiteral&lt;String&gt;().type // returns `class java.lang.String`
typeLiteral&lt;Int&gt;().type // returns `class java.lang.Integer`
typeLiteral&lt;Array&lt;String&gt;&gt;().type // returns `[Ljava.lang.String;`
typeLiteral&lt;List&lt;*&gt;&gt;().type // returns `java.util.List&lt;?&gt;`</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nullable_types">6.5. Nullable Types</h3>
<div class="paragraph">
<p>Regular reference types (classes, interfaces and arrays) do not support the null value. The language guarantees that all variables of those types are always initialized with a valid object reference prior to their use, and expressions of those types always evaluate to a valid object reference (if their evaluation completes normally).</p>
</div>
<div class="paragraph">
<p>Because type-parameters can be instantiated both with non-nullable and nullable types (unless their bounds indicate otherwise), the language must handle them conservatively: it does not allow assigning null value to variables whose type is a type-parameter (because it may be instantiated with a non-nullable type), but when reading from them, it cannot assume that the value is not null unless it can be proven via static data-flow analysis (because it also may be instantiated with a nullable type).</p>
</div>
<div class="paragraph">
<p>Every reference type, type-parameter or a primitive type <code>T</code> has the corresponding nullable type <code>T?</code>. The type <code>T</code> is called the underlying type of the nullable type <code>T?</code>. It is permitted (although completely redundant) to write <code>T?</code> even if <code>T</code> is already a nullable type. The set of valid values of a nullable type is the set of valid value of its underlying type plus the additional null value. The null value is denoted using the keyword <code>null</code>. The type <code>kotlin.Nothing?</code> has only the null value as its valid value, and is a subtype of every nullable type. The type of the null literal is <code>kotlin.Nothing?</code>. The type <code>kotlin.Any?</code> can store any value whatsoever, and is a supertype of every nullable and every non-nullable type.</p>
</div>
<div class="paragraph">
<p>TODO: Say more about instantiation of type-parameters.</p>
</div>
<div class="paragraph">
<p>A nullable type cannot be specified as a supertype in a class or interface declaration. A nullable type cannot be used on the left hand side of a dot (either in a type context or expression context), except as a receiver type in extension functional types.</p>
</div>
<div class="paragraph">
<p>TODO: It looks reasonable to support a non-nullable version <code>T!!</code> of type-parameter <code>T</code> that is not known to be non-nullable. If the type-parameter <code>T</code> is instantiated with a non-nullable type then <code>T!!</code> is the same type as <code>T</code>. Otherwise, the type-parameter <code>T</code> is instantiated with some nullable type <code>S?</code> (where <code>S</code> is a non-nullable type), and <code>T!!</code> is the same type as <code>S</code>. Non-nullable versions of type-parameters can be propagated into parameters of lambdas by smart casts. Effectively, <code>T!!</code> would be equivalent to the intersection type <code>T &amp; Any</code>. <em>[Note:</em> The notation T!! should not be confused with the notation T! used for platform types. <em>End Note]</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_primitive_and_special_types">6.6. Primitive and Special Types</h3>
<div class="paragraph">
<p>A primitive type is usually represented by the platform as a fixed-length bit pattern, and can be directly and efficiently manipulated by the hardware. But the language does not prescribe any particular representation for primitive type, but only requires that their observable behavior corresponds to the following descriptions. Primitive values do not have simpler components representable in the language, do no share any state with other primitive values and are effectively immutable. [Note: Individual bits of integer types can be extracted using bitwise operations, see §?. End Note]</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code>&#8201;&#8212;&#8201;the Boolean type having exactly two values, represented by literals <code>true</code> and <code>false</code>.</p>
</li>
<li>
<p><code>Byte</code>&#8201;&#8212;&#8201;a signed (2-complement) 8-bit integer type.</p>
</li>
<li>
<p><code>Short</code>&#8201;&#8212;&#8201;a signed (2-complement) 16-bit integer type.</p>
</li>
<li>
<p><code>Int</code>&#8201;&#8212;&#8201;a signed (2-complement) 32-bit integer type.</p>
</li>
<li>
<p><code>Long</code>&#8201;&#8212;&#8201;a signed (2-complement) 64-bit integer type.</p>
</li>
<li>
<p><code>Char</code>&#8201;&#8212;&#8201;unsigned 16-bit integer type, intended to represent UTF-16 code points.</p>
</li>
<li>
<p><code>Float</code>&#8201;&#8212;&#8201;a single-precision 32-bit IEEE 754 floating point type.</p>
</li>
<li>
<p><code>Double</code>&#8201;&#8212;&#8201;a double-precision 64-bit IEEE 754 floating point type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Due to different representations, smaller types are not subtypes of bigger ones. Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions).</p>
</div>
<div class="paragraph">
<p>Primitive types do not have non-private constructors, but their instances could be represented using literal of corresponding types.</p>
</div>
<div class="sect3">
<h4 id="_the_kotlin_any_type">6.6.1. The kotlin.Any Type</h4>
<div class="paragraph">
<p>All classes in Kotlin have a common ultimate superclass <code>kotlin.Any</code>. <code>kotlin.Any</code> is the default superclass for a class with no superclass declared. <code>Any</code> is not <code>java.lang.Object</code>, in particular, it does not have any members other than methods <code>equals</code>, <code>hashCode</code> and <code>toString</code>. It is the root on the hierarchy of all non-nullable types. To declare a variable that can store a reference to a value of any type (nullable or not), the nullable type <code>kotlin.Any?</code> can be used.</p>
</div>
<div class="paragraph">
<p>All interfaces are considered to be subtypes of <code>kotlin.Any</code>.</p>
</div>
<div class="paragraph">
<p><code>kotlin.Any</code> has the following parts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>public constructor()
public open fun equals(other: Any?): Boolean
public open fun hashCode(): Int
public open fun toString(): String</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor implementation is an empty block that does nothing.</p>
</div>
<div class="paragraph">
<p>The default implementation of the method equals performs reference equality check. It can be overridden in derived types to implement a custom equality behavior. It is strongly recommended that any implementation of this method satisfies the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Termination. The method shall complete normally (i.e. it shall not go into an infinite loop or throw an exception).</p>
</li>
<li>
<p>Purity. An invocation <code>x.equals(y)</code> shall not change any observable state of objects <code>x</code> and <code>y</code> (it may update some caches though).</p>
</li>
<li>
<p>Reproducibility. Multiple invocations <code>x.equals(y)</code> shall return the same result (unless state of either <code>x</code> or <code>y</code> has changed in between).</p>
</li>
<li>
<p>Reflexivity. For any non-null value <code>x</code> the expression <code>x.equals(x)</code> shall return <code>true</code>.</p>
</li>
<li>
<p>Symmetry. For any non-values <code>x</code> and <code>y</code> expressions <code>x.equals(y)</code> and <code>y.equals(x)</code> shall return the same value (unless state of either <code>x</code> or <code>y</code> has changed in between).</p>
</li>
<li>
<p>Transitivity. Invocations <code>x.equals(y)</code> and <code>x.equals(z)</code> shall return the same value if <code>y.equals(z)</code> returns <code>true</code> (unless state of either <code>x</code>, <code>y</code> or <code>z</code> has changed in between).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>[Note:</em> Many functions from the standard library may produce unexpected results if any of these rules is violated. It is reasonable to expect implementations of the <code>equals</code> method to be conformant to these rules when writing library code, but one should not rely on it when reasoning about code security and other critical properties, because a malicious client could exploit it and create a security breach. <em>End note]</em></p>
</div>
<div class="paragraph">
<p>The default implementation of the <code>hashCode</code> method returns a hash code for the current object, consistent with the behavior of the <code>equals</code> method (i.e. equal objects always have the same hash code, although different objects also might have the same hash code due to hash collisions).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO: <code>toString</code> method</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Any</code> is an <code>open</code> non-<code>abstract</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_nothing_type">6.6.2. The kotlin.Nothing Type</h4>
<div class="paragraph">
<p>The type <code>kotlin.Nothing</code> is an uninhabited type (i.e. no value can have this type at runtime). Consequently, an evaluation of an expression of type <code>kotlin.Nothing</code> never completes normally (for example, it may be a non-terminating computation, may throw an exception, or result in a control flow transfer). The type <code>kotlin.Nothing</code> is a subtype of every other type. The corresponding nullable type <code>kotlin.Nothing?</code> can have the only value null. Neither <code>kotlin.Nothing</code> nor <code>kotlin.Nothing?</code> can be used as a reified type-argument.</p>
</div>
<div class="paragraph">
<p>If a program was compiles with unchecked warnings (possibly, suppressed), and an evaluation of an unchecked cast resulted in a heap pollution, it may be possible to have an expression with compile type <code>Nothing</code> that will have a value of some inhabited type.</p>
</div>
<div class="paragraph">
<p>The type <code>Nothing</code> does not have non-private constructors, and there is no way in the language to create an instance of this type.</p>
</div>
<div class="paragraph">
<p><code>Nothing</code> is a <code>final</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_unit_type">6.6.3. The kotlin.Unit Type</h4>
<div class="paragraph">
<p>The <code>kotlin.Unit</code> is a singleton type whose directs superclass is <code>kotlin.Any</code>. It does not implement any interfaces. It does not have any members beyond those inherited from <code>kotlin.Any</code>. The expression <code>kotlin.Unit</code> represents the single instance of the <code>kotlin.Unit</code> type. This type may be used as a return type of any function that does not return any meaningful value.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_byte_type">6.6.4. The kotlin.Byte Type</h4>
<div class="paragraph">
<p>TODO: Describe behavior of the interface members implemented by numeric types.</p>
</div>
<div class="paragraph">
<p><code>Byte</code> is a <code>final</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_short_type">6.6.5. The kotlin.Short Type</h4>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><code>Short</code> is a <code>final</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_int_type">6.6.6. The kotlin.Int Type</h4>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><code>Int</code> is a <code>final</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_long_type">6.6.7. The kotlin.Long Type</h4>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><code>Long</code> is a <code>final</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_char_type">6.6.8. The kotlin.Char Type</h4>
<div class="paragraph">
<p>The type <code>kotlin.Char</code> represents a UTF-16 code point, rather than a Unicode character. Some Unicode characters are represented by a pair of surrogates, in which case each of the surrogates is a separate instance of the <code>kotlin.Char</code> type.</p>
</div>
<div class="paragraph">
<p><code>Char</code> is a <code>final</code> class.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_float_type">6.6.9. The kotlin.Float Type</h4>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><code>Float</code> is a <code>final</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_double_type">6.6.10. The kotlin.Double Type</h4>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><code>Double</code> is a <code>final</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_boolean_type">6.6.11. The kotlin.Boolean Type</h4>
<div class="paragraph">
<p>The type <code>Boolean</code> represents Boolean values. It has exactly two possible values: <code>true</code> and <code>false</code>. These values can be syntactically expressed using <code>true</code> and <code>false</code> Boolean literals. <em>[Note:</em> It should not be expected that an implementation will try to pack Boolean values to use only 1 bit of storage per variable. Normally, 1 byte of storage per variable will be used. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>TODO: Describe behavior of the interface members implemented by this type.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><code>Boolean</code> is a <code>final</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_kotlin_arrayt_type">6.6.12. The kotlin.Array&lt;T&gt; Type</h4>
<div class="paragraph">
<p>The <code>kotlin.Array&lt;T&gt;</code> represents a flat array of elements of type <code>T</code>. Unlike other classes whose constituent values are stored in fields, an array&#8217;s constituent values are its elements. Unlike classes that specify number of their fields in their declarations at compile-time, an array type does not specify the number of its elements. This number is specified when a particular instance of an array is created, and remains unchanged for the lifetime of that instance.</p>
</div>
<div class="paragraph">
<p>All elements of an array are effectively public, and can be read or updated by any code that has access to the array itself.</p>
</div>
<div class="paragraph">
<p>The type <code>Array&lt;T&gt;</code> has the only public constructor <code>Array(size: Int, init: (Int) -&gt; T)</code>, no other non-private constructors. There are library methods that enable to create array instances.</p>
</div>
<div class="paragraph">
<p>When kotlin.Array&lt;T&gt; is used with primitive types, its elements are stored in a boxed form that may not be very efficient. For flat array of primitive types, the standard library provides non-generic types <code>ByteArray</code>, <code>ShortArray</code>, <code>IntArray</code>, <code>LongArray</code>, <code>CharArray</code>, <code>BooleanArray</code>, <code>FloatArray</code>, <code>DoubleArray</code>. These classes have no inheritance relationship to the <code>Array&lt;T&gt;</code> class, but they have similar characteristics and similar sets of methods and properties.</p>
</div>
<div class="paragraph">
<p>Each of arrays of primitive types has two public constructors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ByteArray(size: Int) // TODO: specify behavior
ByteArray(size: Int, init: (Int) -&gt; Byte)

ShortArray(size: Int)
ShortArray(size: Int, init: (Int) -&gt; Short)

IntArray(size: Int)
IntArray(size: Int, init: (Int) -&gt; Int)

LongArray(size: Int)
LongArray(size: Int, init: (Int) -&gt; Long)

CharArray(size: Int)
CharArray(size: Int, init: (Int) -&gt; Char)

BooleanArray(size: Int)
BooleanArray(size: Int, init: (Int) -&gt; Boolean)

FloatArray(size: Int)
FloatArray(size: Int, init: (Int) -&gt; Float)

DoubleArray(size: Int)
DoubleArray(size: Int, init: (Int) -&gt; Double)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and has no other non-private constructors. There are library methods that enable to create array instances of these types.</p>
</div>
<div class="paragraph">
<p><code>Array&lt;T&gt;</code> and all primitive array types are <code>final</code> classes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_string_class">6.6.13. kotlin.String class</h4>
<div class="paragraph">
<p>Values of the class <code>String</code> are strings, i.e. finite immutable sequences of UTF-16 code points. A string can have zero or more code points (their length is limited only by platform or available memory). Strings are immutable, meaning that neither their lengths, nor any of their elements can be modifier after their creation.</p>
</div>
<div class="paragraph">
<p>The type <code>String</code> has the only public constructor <code>String()</code> that creates an empty string, and no other non-private constructors. There are library methods named <code>String</code> that enable creation of string instances.</p>
</div>
<div class="paragraph">
<p><code>String</code> is a final class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_reflect_kclasst_class">6.6.14. kotlin.reflect.KClass&lt;T&gt; class</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_dynamic_type">6.6.15. The dynamic Type</h4>
<div class="paragraph">
<p>The type <code>dynamic</code> may be supported not on every platform. A supertype cannot be the <code>dynamic</code> type. The type <code>dynamic</code> has no constructors.</p>
</div>
<div class="paragraph">
<p>TODO: Subtyping relationships for dynamic.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_functional_types">6.7. Functional Types</h3>
<div class="paragraph">
<p>There are two kinds of functional types: free functional types and extension functional types. A free functional type specifies zero or more parameter types, and a return type. An extension functional type in addition specifies a receiver type (before the parameter list, separated by the dot).</p>
</div>
<div class="paragraph">
<p>If a function does not return any meaningful value (for example, is invoked for the sake of its side effects), it may be declared with kotlin.Unit return type. If a function never returns normally (for example, contains an infinite loop, always throws an exception, or terminates the process), it may be declared with kotlin.Nothing return type.</p>
</div>
<div class="paragraph">
<p>Functional types are interfaces, not classes, and so do not have any constructors. There are predefined types implementing these interfaces, and their instances are created implicitly (for example, when converting an anonymous function to a function type).</p>
</div>
</div>
<div class="sect2">
<h3 id="_platform_types">6.8. Platform Types</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_relationships">6.9. Type Relationships</h3>
<div class="paragraph">
<p>It is possible that two types having different syntax forms are considered equivalent (even ignoring the possibility of fully qualified names and name aliases). In particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nested nullable types are equivalent to the corresponding single nullable types (e.g. <code>String??</code> is equivalent to <code>String?</code>).</p>
</li>
<li>
<p>Star-projection is equivalent to the corresponding out-projection (or, in contravariant case, <code>G&lt;Nothing&gt;</code>).</p>
</li>
<li>
<p>Functional types are equivalent to corresponding named types.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TODO: Type equivalence, inheritance, subtyping, interface implementations.</p>
</div>
<div class="sect3">
<h4 id="_restrictions">6.9.1. Restrictions</h4>
<div class="paragraph">
<p>An inheritance hierarchy shall be acyclic, that is more precisely described by the following rule. Construct a directed graph, where all the declared types in the program (classes, interfaces and objects) are represented by vertices, and there is an edge from type A to type B if the declaration of A lists B among its supertypes (ignoring type-arguments) or if the declaration of type A is directly nested in the declaration of type B. It is an error if the constructed directed graph contains a cycle. It means, for example, that it is an error for a class to inherit from itself, or for two classes to inherit from each other, or for a class to inherit from its nested class.</p>
</div>
<div class="paragraph">
<p><em>[Note:</em> It is syntactically impossible for a top-level class to specify a local class as its superclass. <em>End note]</em></p>
</div>
</div>
<div class="sect3">
<h4 id="_single_instantiation_rule">6.9.2. Single Instantiation Rule</h4>
<div class="paragraph">
<p>It is an error if the transitive closure of supertypes of a type contains two different instantiations of a generic type.</p>
</div>
<div class="paragraph">
<p>TODO: do we permit any flexibility for co- or contravariant types?</p>
</div>
<div class="paragraph">
<p>TODO: no expanding generic graphs, single instantiation inheritance.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conversions">6.10. Conversions</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_generics">7. Generics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_10">7.1. General</h3>
<div class="paragraph">
<p>A class, interface, function or property declaration may contain a <em>type-parameter list</em> that declares one or more <em>type-parameters</em>, in which case the declaration is called <em>generic</em>. It is an error if two or more type-parameters in the same parameter list have the same name. The scope of type-parameters extends to the entire symbol declaration to which they belong (including supertype list, the entire type-argument list itself, and any fragments of the declaration that may appear to the left of it).</p>
</div>
<div class="paragraph">
<p>Names of type-parameters can be used like regular type names within their scope. (TODO: nested and inner classes) A generic type declaration serves as a blueprint for multiple type declarations having the same shape. A particular instance of a generic type is obtained by providing a type-argument list after its name. Type-arguments are substituted to all occurrences of corresponding type-parameters in the generic type declaration. The substitution is semantic rather than pure textual. For example, the name of a type provided as a type-argument may be hidden or invisible at a particular occurrence of a corresponding type-parameter, so a pure textual substitution of the name would result in that name being unresolved, or bound to an unrelated symbol. <em>[Note:</em> A type-parameter within its scope may be used as a type-argument, or otherwise appear as a constituent of a type-argument. <em>End Note]</em> <em>[Note:</em> Generic declarations promote better type safety. For example, rather than having a non-generic <code>ArrayList</code> that can store elements of any type, and downcasting its elements to a particular type when they are extracted from list, we can declare a generic <code>ArrayList&lt;T&gt;</code> and to use its particular instantiation, e.g. <code>ArrayList&lt;Int&gt;</code> or <code>ArrayList&lt;String&gt;</code> when we need a list of integers or a list of strings, respectively. This way we cannot put an element of a wrong type to a list, and we do not need to downcast when we extract elements. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>TODO: Description of generic types and methods, type substitution, scope of type-parameters, type-parameter bounds, projections and their members, skolemization (aka capture conversion), raw types, erasure, single instantiation inheritance rule.</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_parameters">7.2. Type-Parameters</h3>
<div class="paragraph">
<p>Type-parameters of types and methods. Scope of type-parameters, interaction with nested classes, interaction with local classes. Identity of type-parameters, comparison of signatures, internal and external view of type-parameters, multiple instantiations (cf. TS). Names and ordinal positions. Substitutions, composition of substitutions. Open and closed instantiations, instance type (type of this). Originating declaration. Generic arity.</p>
</div>
<div class="paragraph">
<p>A type-parameter can never escape its scope&#8201;&#8212;&#8201;no expression can have a type containing a type-parameter outside of its scope (this does not mean a type-parameter is always denotable&#8201;&#8212;&#8201;it still can be hidden by other symbols). Thus, if a name in a code refers to a type-parameter, it can never be a type-parameter declared in a library, or even in a different compilation unit (the latter would become false if Kotlin ever introduced partial types).</p>
</div>
<div class="paragraph">
<p>A type-parameter can only be denoted using a simple name, never using a qualified name (it means that if a type-parameter is hidden, it is not denotable).</p>
</div>
<div class="paragraph">
<p>A type-parameter name can never appear as the left hand side of a member access operator (dot), but it can appear as a receiver type in extension functional types.</p>
</div>
<div class="paragraph">
<p>No two type-parameters in the same type-parameter list can have the same name.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_instantiation">7.3. Instantiation</h3>
<div class="sect3">
<h4 id="_general_11">7.3.1. General</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_type_argument_list">7.3.2. Type-Argument List</h4>
<div class="paragraph">
<p>Type-argument list can be provided either to a generic type name to specify a type instantiation or projection, or to a generic method name to specify type-arguments to this method. Type-argument list is delimited by angle brackets and contain one or more type-arguments separated by commas. A type-argument can be either a type or a projection specifier. A projection specifier can only appear in a type-argument list provided to a generic type. It is an error if it appears in a type-argument list for a method. A type-argument list cannot contain zero arguments. In certain contexts, where no type-arguments are to be provided, the whole type-argument list, including delimiting angle brackets, are omitted. In certain contexts a generic type can be used without providing type-arguments&#8201;&#8212;&#8201;in this case the whole type-argument list, including delimiting angle brackets, is omitted. It is an error to provide an empty type-argument list: <code>T&lt;&gt;</code>. Number of type-arguments provided in a generic type instantiation must match generic arity of the generic type. It is an error to provide a type-argument list to a non-generic type. It is an error to provide a type-argument list to an identifier that does not denote a type or a method. <em>[Note:</em> certain language constructs (e.g. <code>super</code>) allow to specify a type enclosed in angle brackets that may look similar to a type-argument list, but those syntax constructs are not type-argument lists. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>TODO: Discuss nested types.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_substitution">7.4. Substitution</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_bounds">7.5. Bounds</h3>
<div class="paragraph">
<p>A type-parameter can have zero or more bounds. A bound is a type that can possibly depend on the type-parameter itself, or on other type-parameters from the same type-parameter list, or on other type-parameters from an outer scope).</p>
</div>
<div class="paragraph">
<p>A bound for a type-parameter can be specified at its declaration after a colon (so called primary bound). Also, one or more bounds can be specified in a where clause. Bounds in a where clause can be specified even if primary bound is not present. Order of bounds is not important, except that the leftmost bound is used to determine erased signature on platforms supporting erasure (that can result in a signature clash, for example).</p>
</div>
<div class="paragraph">
<p>A type-parameter cannot specify itself as its own bound, and several type-parameters cannot specify each other as a bound in a cyclic manner. More precisely, for each type-parameter list, construct a directed graph where all type-parameters declared in the type-parameter list are represented as vertices, and there is an edge from type-parameter <code>T</code> to type-parameter <code>S</code> iff <code>T</code> has <code>S</code> or <code>S?</code> as its bound. It is an error if the constructed directed graph contains a cycle.</p>
</div>
<div class="paragraph">
<p>It is not syntactically possible for two type-parameters in different type-parameter lists to specify each other as a bound.</p>
</div>
<div class="paragraph">
<p>It is an error for a bound of a type-parameter to be <code>Nothing</code>, or for several bound to have the intersection <code>Nothing</code> (<code>Nothing?</code> is allowed). Two bounds of the same type-parameter cannot be different instantiations of the same generic type (TODO: in transitive set)</p>
</div>
<div class="paragraph">
<p>The same bound cannot be specified more than once for the same type-parameter (BUG: implement)</p>
</div>
<div class="ulist Note: It is permitted (although rarely useful) to use a `final` class as a bound. If a type-parameter `T` has a `final` class `F` as a bound">
<ul class="Note: It is permitted (although rarely useful) to use a `final` class as a bound. If a type-parameter `T` has a `final` class `F` as a bound">
<li>
<p>TODO: Bounds, self-referential bounds, bound satisfaction, substitution. When exactly satisfaction is checked (nested generics, bounds satisfaction in bounds).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_variance">7.6. Variance</h3>
<div class="paragraph">
<p>TODO: Co- and contravariance, safe occurrences of variant type-parameter (including occurrences in type constraints, inner type constraints, and method constraints), safe invocations of private members.
Variant conversions, infinite recursion issues, expanding cycles.</p>
</div>
<div class="paragraph">
<p>TODO: Workaround for <code>add</code> methods (extension methods).</p>
</div>
</div>
<div class="sect2">
<h3 id="_projections">7.7. Projections</h3>
<div class="paragraph">
<p>TODO: Projections, valid occurrences of projections, members of projections. Meaning of projections of variant types. Interaction of declaration-site and use-side bounds, interaction with invisible types.  Projections of a generic type in bounds in its own declaration.</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_inference">7.8. Type Inference</h3>
<div class="paragraph">
<p>TODO: Type variables, and fixed (external) type-parameters (can originate from the same declaration). Type inference session (can include type variables from multiple declarations or multiple instances of the same declaration). Identity of type variables.</p>
</div>
<div class="paragraph">
<p>Type inference is a process that tries to infer type-arguments in a generic function invocation (or a group of generic function invocations, chained or nested) where no explicit type-arguments are provided from function arguments and the expected type (if one is present), such that the inferred type-arguments satisfy the bounds on the corresponding type-parameters, and, after substitution of the type-arguments in the function signature, the function is applicable to the provided arguments and the result of the function is assignable to the expected type (if one is present). Type inference is conservative&#8201;&#8212;&#8201;it may fail to find suitable assignment of type-arguments to the type-parameters despite that one exist, and the function invocation could be successfully typechecked if the programmer explicitly provided suitable type-arguments. Also, it is possible that multiple different valid assignments of type-arguments are possible&#8201;&#8212;&#8201;in this case, if the type inference succeeds, it will deterministically select one of those assignments. It is possible that the selected assignment leads to a compile-time error elsewhere, that could be avoided if the programmer explicitly provided a different assignment of type-arguments. It is also possible that type inference infers type-arguments that for some reason are not denotable in the given location in the source code (e.g. because they contain captured type variables or type parameters hidden by other declarations), and so could not be provided explicitly. This condition by itself does not prevent the generic function invocation from being typechecked successfully.</p>
</div>
</div>
<div class="sect2">
<h3 id="_restrictions_on_usage">7.9. Restrictions on Usage</h3>
<div class="paragraph">
<p>A generic class cannot have <code>Throwable</code> as a superclass.</p>
</div>
<div class="paragraph">
<p>Classes in Kotlin may have type-parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Box&lt;T&gt;(t: T) {
  var value = t
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create an instance of such a class, the type-arguments have to be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if the parameters may be inferred, e.g. from the constructor arguments or by some other means, type-arguments can be omitted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val box = Box(1) // 1 has type Int, so the compiler figures out that we are talking about Box&lt;Int&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Declaration-site variance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Suppose we have a generic interface <code>Source&lt;T&gt;</code> that does not have any methods that take <code>T</code> as a parameter, only methods that return <code>T</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
interface Source&lt;T&gt; {
  T nextT();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, it would be perfectly safe to store a reference to an instance of <code>Source&lt;String&gt;</code> in a variable of type <code>Source&lt;Object&gt;</code>&#8201;&#8212;&#8201;there are no consumer-methods to call. But Java does not know this, and still prohibits it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
void demo(Source&lt;String&gt; strs) {
  Source&lt;Object&gt; objects = strs; // !!! Not allowed in Java
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To fix this, we have to declare objects of type <code>Source&lt;? extends Object&gt;</code>, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there is no value added by the more complex type. But the compiler does not know that.</p>
</div>
<div class="paragraph">
<p>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called declaration-site variance: we can annotate the type-parameter <code>T</code> of Source to make sure that it is only returned (produced) from members of <code>Source&lt;T&gt;</code>, and never consumed.
To do this we provide the <code>out</code> modifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>abstract class Source&lt;out T&gt; {
  fun nextT(): T
}

fun demo(strs: Source&lt;String&gt;) {
  val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The general rule is: when a type-parameter <code>T</code> of a class <code>C</code> is declared <code>out</code>, it may occur only in <code>out</code>-position in the members of <code>C</code>, but in return <code>C&lt;Base&gt;</code> can safely be a supertype of <code>C&lt;Derived&gt;</code>.</p>
</div>
<div class="paragraph">
<p>In "clever words" they say that the class <code>C</code> is covariant in the parameter <code>T</code>, or that <code>T</code> is a covariant type-parameter. <code>C</code> can be thought of as being a producer of `T`s, and NOT a consumer of `T`s.</p>
</div>
<div class="paragraph">
<p>The <code>out</code> modifier is called a variance annotation, and  since it is provided at the type-parameter declaration site, we talk about declaration-site variance. This is in contrast with Java&#8217;s use-site variance where wildcards in the type usages make the types covariant.</p>
</div>
<div class="paragraph">
<p>In addition to <code>out</code>, Kotlin provides a complementary variance annotation: <code>in</code>. It makes a type-parameter contravariant: it can only be consumed and never produced. A good example of a contravariant class is <code>Comparable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>abstract class Comparable&lt;in T&gt; {
  fun compareTo(other: T): Int
}

fun demo(x: Comparable&lt;Number&gt;) {
  x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number
  // Thus, we can assign x to a variable of type Comparable&lt;Double&gt;
  val y: Comparable&lt;Double&gt; = x // OK!
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Type projections</p>
</li>
<li>
<p>Use-site variance: Type projections</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is very convenient to declare a type-parameter T as <code>out</code> and have no trouble with subtyping on the use site. Yes, it is, when the class in question can actually be restricted to only return `T`s, but what if it cannot?
A good example of this is Array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Array&lt;T&gt;(val size: Int) {
  fun get(index: Int): T { /* ... */ }
  fun set(index: Int, value: T) { /* ... */ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This class cannot be either co- or contravariant in <code>T</code>. And this imposes certain inflexibilities. Consider the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun copy(from: Array&lt;Any&gt;, to: Array&lt;Any&gt;) {
  assert(from.size == to.size)
  for (i in from.indices)
    to[i] = from[i]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function is supposed to copy items from one array to another. Let us try to apply it in practice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val ints: Array&lt;Int&gt; = array(1, 2, 3)
val any = Array&lt;Any&gt;(3)
copy(ints, any) // Error: expects (Array&lt;Any&gt;, Array&lt;Any&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we run into the same familiar problem: <code>Array&lt;T&gt;</code> is invariant in <code>T</code>, thus neither of <code>Array&lt;Int&gt;</code> and <code>Array&lt;Any&gt;</code> is a subtype of the other. Why? Again, because copy might be doing bad things, i.e. it might attempt to write, say, a <code>String</code> to <code>from</code>, and if we actually passed an array of <code>Int</code> there, a <code>ClassCastException</code> would have been thrown sometime later.</p>
</div>
<div class="paragraph">
<p>Then, the only thing we want to ensure is that <code>copy()</code> does not do any bad things. We want to prohibit it from writing to <code>from</code>, and we can:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) {
 // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What has happened here is called type projection: we said that <code>from</code> is not simply an array, but a restricted (projected) one: we can only call those methods that return the type-parameter <code>T</code>, in this case it means that we can only call <code>get()</code>. This is our approach to use-site variance, and corresponds to Java&#8217;s <code>Array&lt;? extends Object&gt;</code>, but in a slightly simpler way.</p>
</div>
<div class="paragraph">
<p>It is also possible to create an in-projection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun fill(dest: Array&lt;in String&gt;, value: String) {
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Array&lt;in String&gt;</code> corresponds to Java&#8217;s <code>Array&lt;? super String&gt;</code>, i.e. both an array of <code>CharSequence</code> and an array of <code>Object</code> can be passed to the <code>fill()</code> function.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Star-projections</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sometimes it is necessary to work with a generic type, although nothing is known about the type-argument, it still have to be manipulated it in a safe way. The safe way here is to say that we are dealing with an <code>out</code>-projection (the object does not consume any values of unknown types), and that this projection is with the upper bound of the corresponding parameter, i.e. <code>out Any?</code> for most cases. Kotlin provides a shorthand syntax for this, that we call a star-projection: <code>Foo&lt;*&gt;</code> means <code>Foo&lt;out Bar&gt;</code> where <code>Bar</code> is the upper bound for `Foo&#8217;s type-parameter.</p>
</div>
<div class="paragraph">
<p><strong>Note</strong>: star-projections are very much like Java&#8217;s raw types, but safe.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generic_functions_2">7.10. Generic functions</h3>
<div class="paragraph">
<p>Not only classes can have type-parameters. Functions can, too. type-parameters are placed before the name of the function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; {
  // ...
}

fun &lt;T&gt; T.basicToString() : String {  // extension function
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If type-parameters are passed explicitly at the call site, they are specified after the name of the function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val l = singletonList&lt;Int&gt;(1)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_generic_constraints">7.11. Generic constraints</h3>
<div class="paragraph">
<p>The set of all possible types that can be substituted for a given type-parameter may be restricted by generic constraints.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Upper bounds</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The most common type of constraint is an upper bound that corresponds to Java&#8217;s <code>extends</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) {
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type specified after a colon is the upper bound: only a subtype of <code>Comparable&lt;T&gt;</code> may be substituted for <code>T</code>. For example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>sort(listOf(1, 2, 3)) // OK. Int is a subtype of Comparable&lt;Int&gt;
sort(listOf(HashMap&lt;Int, String&gt;())) // Error: HashMap&lt;Int, String&gt; is not a subtype of Comparable&lt;HashMap&lt;Int, String&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default upper bound (if none specified) is <code>Any?</code>. Only one upper bound can be specified inside the angle brackets. If the same type-parameter needs more than one upper bound, we need a separate <code>where</code>-clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T&gt; cloneWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;T&gt;
    where T : Comparable,
          T : Cloneable {
  return list.filter { it &gt; threshold }.map { it.clone() }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_type_projections">7.11.1. Type Projections</h4>
<div class="paragraph">
<p>TODO
A type projection cannot be used as a supertype.</p>
</div>
</div>
<div class="sect3">
<h4 id="_extended_set_of_bounds">7.11.2. Extended Set of Bounds</h4>
<div class="paragraph">
<p>If T is a type-parameter, then its <em>extended set of bounds</em> S is the transitive closure of its set of bounds under the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a nullable type U? is in S, then U is in S.</p>
</li>
<li>
<p>If a type-parameter U is in S, then all bounds of U are in S.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>[Example:</em> Consider the following class declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class A&lt;T : U, U : Throwable?&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The extended set of bounds of the type-parameter <code>T</code> is { <code>U</code>, <code>Throwable?</code>, <code>Throwable</code> }.
End Example]</p>
</div>
<div class="paragraph">
<p>It is a compile-time error if the extended set of bounds of a type-parameter contains two different instantiations of the same generic type.</p>
</div>
</div>
<div class="sect3">
<h4 id="_constituent_types">7.11.3. Constituent Types</h4>
<div class="paragraph">
<p>For every type <code>T</code>, there is a corresponding set <code>S</code> of its <em>constituent types</em>, defined as the transitive closure of the singleton set {<code>T</code>} under the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a nullable type <code>U?</code> is in <code>S</code>, then <code>U</code> is in <code>S</code>.</p>
</li>
<li>
<p>If a constructed generic type <code>G&lt;A1, &#8230;&#8203;, An&gt;</code> is in <code>S</code>, then for each its type-argument <code>Ai</code> that is a type (i.e. not a projection argument), <code>Ai</code> is in <code>S</code>.</p>
</li>
<li>
<p>If a constructed generic type <code>G&lt;A1, &#8230;&#8203;, An&gt;</code> is in <code>S</code>, then for each its type-argument <code>Ai</code> that is a projection argument of the form <code>out Ti</code> or <code>in Ti</code>, <code>Ti</code> is in <code>S</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>[Note:</em> Note that every type is always a constituent type of itself. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p><em>[Example:</em> The constituent types of the type <code>A&lt;T?, B&lt;out B&lt;X, X&gt;, C&lt;*&gt;&gt;&gt;</code> are { <code>A&lt;T, B&lt;out B&lt;X, X&gt;, C&lt;*&gt;&gt;&gt;</code>, <code>T?</code>, <code>T</code>, <code>B&lt;out B&lt;X, X&gt;, C&lt;*&gt;&gt;</code>, <code>B&lt;X, X&gt;</code>, <code>C&lt;*&gt;</code>, <code>X</code> }. <em>End Example]</em></p>
</div>
</div>
<div class="sect3">
<h4 id="_effectively_generic_types">7.11.4. Effectively Generic Types</h4>
<div class="paragraph">
<p>A class or interface is an <em>effectively generic</em> type if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>its declaration has a type-parameter list, or</p>
</li>
<li>
<p>it is an inner class nested within an <em>effectively generic</em> class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An <em>effective type-parameter list</em> of an effectively generic type <code>A</code> is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>just the type-parameter list of <code>A</code>&#8201;&#8212;&#8201;if A is not an inner class or its immediate container is not an effectively generic class,</p>
</li>
<li>
<p>just the effective type-parameter list of the immediate container of <code>A</code>&#8201;&#8212;&#8201;if A is a non-generic inner class,</p>
</li>
<li>
<p>the concatenation of the effective type-parameter list of the immediate container of <code>A</code> and the type-parameter list of <code>A</code>&#8201;&#8212;&#8201;otherwise.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the latter case it is assumed that any identically named type-parameters declared in different type-parameter lists are still distinct and are not confused when they appear in the concatenated effective type-parameter list.</p>
</div>
<div class="paragraph">
<p>TODO: classes within generic methods?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_restrictions_on_generic_types">7.12. Restrictions on Generic Types</h3>
<div class="paragraph">
<p>Here, for the sake of simplicity, we assume that all type declarations are top-level, and ignore existence of nested, inner and local type declarations (including those declared within generic functions). When we refer to type-parameters, we always assume type-parameters of generic types (and never those of generic functions). An extension covering  the full language complexity will be presented separately.</p>
</div>
</div>
<div class="sect2">
<h3 id="_general_rules_and_definitions">7.13. General Rules and Definitions</h3>
<div class="paragraph">
<p>A type that is parameterized with one or more types is called a generic type. Each generic type has its declaration <code>C&lt;T1, T2, &#8230;&#8203;&gt;</code>, where <code>Ti</code> are its type-parameters (also referred to as formal type-parameters), and multiple possible instantiations <code>C&lt;A1, A2, &#8230;&#8203;&gt;</code> where <code>Ai</code> are type-arguments (also referred to as actual type-arguments). A type-argument can be either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a type, in which case it is called a simple type-argument, or</p>
</li>
<li>
<p>have the form <code>out X</code>, <code>in X</code> or <code>*</code> (where <code>X</code> is some type), in which case it is called a projection type-argument.
If an instantiation has at least one projection type-argument, it is called a projected generic type, otherwise it is called a simple generic type. A type <code>C&lt;A1, A2, &#8230;&#8203;&gt;?</code> is called a nullable generic type, and is also included as a particular case in a more general notion of generic type. For each type-argument <code>Ai</code> of an instantiation <code>C&lt;A1, A2, &#8230;&#8203;&gt;</code> there is a corresponding type-parameter <code>Ti</code> of the declaration of <code>C&lt;T1, T2, &#8230;&#8203;&gt;</code>, having the same position in the type-parameter list as the position of <code>Ai</code> in the type-argument list <code>&lt;A1, A2, &#8230;&#8203;&gt;</code>. And, vice versa, we can say about a type-argument (of a particular instantiation of a generic type) corresponding to a given type-parameter of the declaration of that generic type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>T</code> is a type-parameter of the declaration of a generic type <code>C&lt;&#8230;&#8203;&gt;</code>, then <code>C&lt;&#8230;&#8203;&gt;</code> is called the owner of <code>T</code>. A type that is not generic is called a non-generic type. Formal type-parameters can be used within their scope as regular types, and are also classified as non-generic types. Note that a simple type-argument can be either a non-generic type (possibly, a type-parameter), or it can be a generic type (simple or projected). A projection type-argument that is not directly an argument of a generic type <code>C&lt;&#8230;&#8203;&gt;</code>, but rather is nested somewhere within its simple type-arguments, does not make <code>C&lt;&#8230;&#8203;&gt;</code> a projected generic type. In any case, the nesting depth of a generic type (either explicitly written in the program or inferred as a type of an expression in a program) is finite. Within a generic type declaration <code>C&lt;T1, T2, &#8230;&#8203;&gt;</code> it is possible to use an instantiation <code>C&lt;T1, T2, &#8230;&#8203;&gt;</code> where each type-parameter is used as a type-argument corresponding to itself. Such type is called the instance type of the corresponding declaration (it is the type of the expression <code>this@C</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="_constituent_types_2">7.14. Constituent Types</h3>
<div class="paragraph">
<p>Suppose <code>X</code> is a type. Let <code>SX</code> denote the set of types that is the transitive closure of the singleton set { <code>X</code> } under the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a nullable type <code>K?</code> is in <code>SX</code>, then <code>K</code> is in <code>SX</code>.</p>
</li>
<li>
<p>If a constructed generic type <code>C&lt;A1, A2, &#8230;&#8203;&gt;</code> is in <code>SX</code>, then every its simple type-argument <code>Ai</code> is in <code>SX</code>.</p>
</li>
<li>
<p>If a constructed generic type <code>C&lt;A1, A2, &#8230;&#8203;&gt;</code> is in <code>SX</code>, then for every its projection type-argument of the form <code>out Bi</code> or <code>in Bi</code>, the type <code>Bi</code> is in <code>SX</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An element of the set <code>SX</code> is called a constituent type of <code>X</code>. Note that for every type <code>X</code> the set of its constituent types is finite and contains <code>X</code> itself. If a type <code>Y</code> is a constituent type of a type <code>X</code>, we sometimes say that <code>X</code> refers to <code>Y</code>.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="paragraph">
<p>The only constituent type of a non-generic, non-nullable type <code>T</code> is <code>T</code> itself.</p>
</div>
<div class="paragraph">
<p>The constituent types of <code>C&lt;X, Y?&gt;</code> are <code>C&lt;X, Y?&gt;</code>, <code>X</code>, <code>Y?</code> and <code>Y</code>.</p>
</div>
<div class="paragraph">
<p>The constituent types of <code>A&lt;T?, B&lt;out B&lt;X, X&gt;, C&lt;*&gt;&gt;&gt;</code> are <code>A&lt;T?, B&lt;out B&lt;X, X&gt;, C&lt;*&gt;&gt;&gt;</code>, <code>T?</code>, <code>T</code>, <code>B&lt;out B&lt;X, X&gt;, C&lt;*&gt;&gt;&gt;</code>, <code>B&lt;X, X&gt;</code>, <code>C&lt;*&gt;</code> and <code>X</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bounds_2">7.15. Bounds</h3>
<div class="paragraph">
<p>Every type-parameter <code>Ti</code> of a generic type <code>C&lt;&#8230;&#8203;&gt;</code> has a (possibly empty) set of declared upper bounds. Each upper bound is a type (possibly generic, and possibly referring to <code>Ti</code> itself or to other type-parameters from the same type-parameter list). For a particular simple instantiation <code>C&lt;A1, A2, &#8230;&#8203;&gt;</code> we say that a type-parameter <code>Ti</code> has a set of upper bounds adapted to this instantiation, that is obtained by substitution of type-arguments <code>A1</code>, <code>A2</code>, &#8230;&#8203; for corresponding type-parameters in the set of declared upper bounds of <code>Ti</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="paragraph">
<p>Consider a generic interface declaration interface <code>C&lt;T : C&lt;T&gt;&gt;</code>. The type-parameter <code>T</code> has a single declared upper bound <code>C&lt;T&gt;</code>, and it refers to the type-parameter <code>T</code> itself. Now consider a derived interface declaration <code>interface B : C&lt;B&gt;</code>. Its superinterface <code>C&lt;B&gt;</code> is an instantiation of the generic interface <code>C&lt;&#8230;&#8203;&gt;</code> where <code>B</code> is the type-argument corresponding to the type-parameter <code>T</code>. The set of upper bounds of the type-parameter <code>T</code> adapted to the instantiation <code>C&lt;B&gt;</code> has the only element <code>C&lt;B&gt;</code> obtained by substitution of the type-argument <code>B</code> for the type-parameter <code>T</code> in the declared upper bound <code>C&lt;T&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_skolemization">7.16. Skolemization</h3>
<div class="paragraph">
<p>Suppose <code>C&lt;&#8230;&#8203;&gt;</code> is a projected generic type. A skolemization of this type is a simple generic type constructed using the following steps. Replace each projection type-argument in <code>C&lt;&#8230;&#8203;&gt;</code> with a fresh type variable (a distinct type variable is synthesized for each type-argument  being replaced). For each introduced type variable <code>Q</code>, let the set of its upper bounds be the set of upper bounds of the corresponding type-parameter adapted to this. If the variable <code>Q</code> was substituted in place of a projection type-argument of the form <code>out X</code>, add the type <code>X</code> to the set of upper bounds of <code>Q</code>. If the variable <code>Q</code> was substituted in place a projection type-argument of the form in <code>Y</code>, let the type <code>Y</code> be a lower bound of <code>Q</code>. A type variable introduced during skolemization is called a skolem type variable.</p>
</div>
</div>
<div class="sect2">
<h3 id="_b_closure">7.17. B-Closure</h3>
<div class="paragraph">
<p>Suppose <code>S</code> is a set of types. Let <code>Z</code> denote the set of types that is the transitive closure of <code>S</code> under the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a nullable type <code>K?</code> in <code>Z</code>, then <code>K</code> is in <code>Z</code>.</p>
</li>
<li>
<p>If a type-parameter <code>T</code> is in <code>Z</code>, then each declared upper bound of <code>T</code> is in <code>Z</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The set <code>Z</code> is called the B-closure of <code>S</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_finite_bound_restriction">7.18. Finite Bound Restriction</h3>
<div class="paragraph">
<p>Let G be a directed graph whose vertices are all type-parameters of all generic type declarations in the program. For every projection type-argument A in every generic type B&lt;&#8230;&#8203;&gt; in the set of constituent types of every type in the B-closure of the set of declared upper bounds of every type-parameter T in G add an edge from T to U, where U is the type-parameter of the declaration of B&lt;&#8230;&#8203;&gt; corresponding to the type-argument A. It is a compile-time error if the graph G has a cycle.</p>
</div>
<div class="paragraph">
<p><em>[Note:</em> An intuitive meaning of an edge X → Y in the graph G is "the exact meaning of bounds for the type-parameter X depends on bounds for the type-parameter Y". <em>End Note]</em></p>
</div>
<div class="paragraph">
<p><em>[Example:</em></p>
</div>
<div class="paragraph">
<p>The following declaration is invalid, because there is an edge <code>T</code> → <code>T</code>, forming a cycle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A&lt;T : A&lt;*&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bound <code>A&lt;*&gt;</code> is a projection with an implicit bound. If that bound is made explicit, the type <code>A&lt;*&gt;</code> takes an equivalent form <code>A&lt;out A&lt;*&gt;&gt;</code>. In the same way, it can be further rewritten in an equivalent from <code>A&lt;out A&lt;out A&lt;*&gt;&gt;&gt;</code>, and so on. In its fully expanded form this bound would be infinite. The purpose of this rule is to avoid such infinite types, and type checking difficulties associated with them.</p>
</div>
<div class="paragraph">
<p>The following pair of declarations is invalid, because there are edges <code>T</code> → <code>S</code> and <code>S</code> → <code>T</code>, forming a cycle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface B&lt;T : C&lt;*&gt;&gt;
interface C&lt;S : B&lt;*&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following declaration is invalid, because there are edges <code>K</code> → <code>V</code> and <code>V</code> → <code>K</code>, forming a cycle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface D&lt;K: D&lt;K, *&gt;, V: D&lt;*, V&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, each of the following declarations is valid:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A&lt;T : A&lt;T&gt;&gt;
interface D&lt;K, V : D&lt;*, V&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>End Example]</em></p>
</div>
<div class="paragraph">
<p>TODO: Interaction of these algorithms with flexible types.
TODO: Importing type declared in Java that violate these rules.</p>
</div>
<div class="paragraph">
<p>Subtyping relationships is to be decided inductively, i.e. must have a finite proof.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface N&lt;in T&gt;
interface A&lt;S&gt; : N&lt;N&lt;A&lt;A&lt;S&gt;&gt;&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_control_and_data_flow">8. Control and Data Flow</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_12">8.1. General</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_definite_assignment">8.2. Definite Assignment</h3>
<div class="paragraph">
<p>Every local variable must be definitely assigned at every point in reachable code where its value is read.</p>
</div>
<div class="paragraph">
<p>TODO: Exact rules.</p>
</div>
<div class="paragraph">
<p>TODO: Definite assignment for properties</p>
</div>
</div>
<div class="sect2">
<h3 id="_smart_casts">8.3. Smart-casts</h3>
<div class="paragraph">
<p>The language uses information about preceding checks for null, checks for types (is, !is), safe call operators (?.) and Nothing-returning expression to infer additional information about types of variable (beyond that explicitly specified or inferred from initializers at their declarations) that may be more specific in certain blocks or even expressions. This information is then used to enable wider set of operations on those expressions and to select more specific overloads.</p>
</div>
<div class="paragraph">
<p><em>[Example:</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun main(args: Array&lt;String&gt;) {
    var x : Any
    x = ""
    x.toUpperCase() // OK, smart cast to String
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>End Example]</em></p>
</div>
<div class="paragraph">
<p>TODO: Description of the algorithm.</p>
</div>
<div class="paragraph">
<p>Example of code not handled by the algorithm (<a href="https://youtrack.jetbrains.com/issue/KT-8781" class="bare">https://youtrack.jetbrains.com/issue/KT-8781</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun f(x : Boolean?, y : Boolean?) {
    if (x == true) return
    if (x == false) return
    if (y != x) {
        y.hashCode()
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>When smart casts are enabled</p>
</li>
<li>
<p>On local values (always)</p>
</li>
<li>
<p>On local variables, if (all three of the following are true)
a smart cast is performed not in the loop which changes the variable after the smart cast
the smart cast is performed in the same function when the variable is declared, not inside some closure
no closure that changes the variable exists before the location of the smart cast</p>
</li>
<li>
<p>On private or internal member or top-level values, if
they are not abstract / open, delegated, and have no custom getter</p>
</li>
<li>
<p>On protected or public member or top-level values, if (both of the following are true)
they are not abstract / open, delegated, and have no custom getter
a smart cast is performed in the same module when the value is declared</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Smart casts are disabled for member or top-level variables.</p>
</div>
<div class="paragraph">
<p>II. What information is taken into account (examples)</p>
</div>
<div class="paragraph">
<p>if / while (x != null) makes x not nullable inside if / while
if / while (x is Type) makes x of type Type inside if / while
x!! makes x not nullable after !!
x as Type makes x of type Type after as
x.foo(&#8230;&#8203;).bar(&#8230;&#8203;) or x?.foo(&#8230;&#8203;)?.bar(&#8230;&#8203;) makes x not nullable inside foo / bar arguments
x = y makes x of the type of y after the assignment
val / var x = y makes of the type of y after the initialization, but
val / var x: Type = y makes x of type Type after the initialization
&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="_unreachable_code">8.4. Unreachable Code</h3>
<div class="paragraph">
<p>Certain regions of code may be proved unreachable via static analysis, which results in a compile-time warning. Definite assignment is not checked within unreachable code, and assignment in unreachable code has no effect of definite assignment state of variables. Otherwise, unreachable code is not exempt from rules of this specification, and any violations result in errors in the same way as in reachable code. Compiler is free to skip code generation for any code proved to be unreachable, but this shall not have any observable effects (beyond those that can be obtained by inspection of the binaries).</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_effects_of_kotlin_nothing_type">8.4.1. Effects of kotlin.Nothing Type</h4>
<div class="paragraph">
<p>An evaluation of an expression of type <code>kotlin.Nothing</code> never completes normally, and any assignment to a variable of type <code>kotlin.Nothing</code> is unreachable.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_effects_on_nullability">8.4.2. Effects on Nullability</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_effects_on_smart_casts">8.4.3. Effects on Smart-Casts</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_application_life_cycle">9. Application Life Cycle</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_applications_vs_libraries">9.1. Applications vs. Libraries</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_application_startup">9.2. Application Startup</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_entry_point">9.3. Entry Point</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_loading_and_initialization">9.4. Type Loading and Initialization</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_threads">9.5. Threads</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_race_conditions">9.5.1. Race Conditions</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_unhandled_exceptions">9.6. Unhandled Exceptions</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_runtime_limitations">9.7. Runtime Limitations</h3>
<div class="sect3">
<h4 id="_general_13">9.7.1. General</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_stack_overflow">9.7.2. Stack Overflow</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_out_of_memory_condition">9.7.3. Out of Memory Condition</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_application_termination">9.8. Application Termination</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_garbage_collection">9.9. Garbage Collection</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_finalization">9.10. Finalization</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_object_oriented_programming_features">10. Object-Oriented Programming Features</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_14">10.1. General</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_inheritance">10.2. Inheritance</h3>
<div class="paragraph">
<p>All classes in Kotlin have a common superclass <code>Any</code>, that is a default superclass for a class with no supertypes explicitly specified:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Example // Implicitly inherits from Any</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Any</code> is not <code>java.lang.Object</code>; in particular, it does not have any members other than the <code>equals</code>, <code>hashCode</code> and <code>toString</code> methods.</p>
</div>
<div class="paragraph">
<p>To declare an explicit supertype, it is specified after a colon in the class header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>open class Base(p: Int)

class Derived(p: Int) : Base(p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the class has a primary constructor, the base type can (and must) be initialized right there, using the parameters of the primary constructor.</p>
</div>
<div class="paragraph">
<p>If the class has no primary constructor, then each secondary constructor has to initialize the base type using the <code>super</code> keyword, or to delegate to another constructor which does that. Note that in this case different secondary constructors can call different constructors of the base type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class MyView : View {
    constructor(ctx: Context) : super(ctx) { }
    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, all classes in Kotlin are final. More precisely, if a class declaration has the <code>open</code> modifier, then the class is considered open, and can be used as a superclass of another class. Otherwise, if the class declaration has the <code>final</code> modifier, the class is considered final, and cannot be used as a superclass. If neither the <code>open</code> nor <code>final</code> modifier is present, then the class is considered final. [Note: Thus, the <code>final</code> modifier is entirely optional and only serves to make the intention explicit. End note]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Overriding Members</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kotlin requires the explicit <code>open</code> modifier for overridable members and the explicit <code>override</code> modifier for overrides:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>open class Base {
  open fun v() { }
  fun nv() { }
}

class Derived() : Base() {
  override fun v() { }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>override</code> modifier is required for <code>Derived.v()</code>. If it were missing, it would result in a compile-time error. If there is no <code>open</code> modifier on a function, like <code>Base.nv()</code>, declaring a method with the same signature in a subclass is illegal, either with <code>override</code> or without it. In a final class (e.g. a class with no <code>open</code> modifier), open members are prohibited.</p>
</div>
<div class="paragraph">
<p>A member marked <code>override</code> is itself open, i.e. it may be overridden in subclasses. To prohibit re-overriding, use <code>final</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>open class AnotherDerived() : Base() {
  final override fun v() {}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Overriding Rules</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate supertypes, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, the <code>super</code> keyword followed by the supertype name in angle brackets is used, e.g. <code>super&lt;Base&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>open class A {
  open fun f() { print("A") }
  fun a() { print("a") }
}

interface B {
  fun f() { print("B") } // interface members are `open` by default
  fun b() { print("b") }
}

class C() : A(), B {
  // The compiler requires f() to be overridden:
  override fun f() {
    super&lt;A&gt;.f() // call to A.f()
    super&lt;B&gt;.f() // call to B.f()
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is permissible to inherit from both <code>A</code> and <code>B</code>, and there are no ambiguity problems with <code>a()</code> and <code>b()</code> since <code>C</code> inherits only one implementation of each of these functions. But for <code>f()</code> two implementations are inherited by <code>C</code>, and thus <code>f()</code> has to be overridden in <code>C</code> to avoid the ambiguity.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Abstract Classes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A class and some of its members may be declared <code>abstract</code>. A declaration of an abstract member does contain its implementation. Thus, when some descendant inherits an abstract member, it does not count as an implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>abstract class A {
  abstract fun f()
}

interface B {
  fun f() { print("B") }
}

class C() : A(), B {
  // It is not required to override f()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that it is allowed, but not required to provide the <code>open</code> modifier for an abstract class or function.</p>
</div>
<div class="paragraph">
<p>A non-abstract open member can be overridden with an abstract one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>open class Base {
  open fun f() {}
}

abstract class Derived : Base() {
  override abstract fun f()
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interface_implementation">10.3. Interface Implementation</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_visibility_2">10.4. Visibility</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_overriding">10.5. Overriding</h3>
<div class="paragraph">
<p>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, the <code>super</code> keyword followed by the supertype name in angle brackets is used, e.g. <code>super&lt;Base&gt;</code>.</p>
</div>
<div class="paragraph">
<p>If a member is overridden on one inheritance path, it is considered to be overridden on all inheritance paths.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_delegation">10.6. Delegation</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_extension_members">10.7. Extension Members</h3>
<div class="paragraph">
<p>If a member function in type A is an extension for type B, then in case it is invoked with an explicit receiver, the receiver must be of type B <em>[Note:</em> for example, such a function cannot be invoked on an explicit receiver of type A even if an implicit receiver of type B is in scope. <em>End note]</em></p>
</div>
<div class="paragraph">
<p>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called <em>extensions</em>. Kotlin supports <em>extension functions</em> and <em>extension properties</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Extension Functions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To declare an extension function, its name has to be prefixed with a <em>receiver type</em>, i.e. the type being extended. The following adds a <code>swap</code> function to <code>MutableList&lt;Int&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) {
  val tmp = this[index1] // `this` corresponds to the list
  this[index1] = this[index2]
  this[index2] = tmp
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>this</code> keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot or provided implicitly). Such a function can be called on any <code>MutableList&lt;Int&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val l = mutableListOf(1, 2, 3)
l.swap(0, 2) // `this` inside `swap()` will hold the value of `l`</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function makes sense for any <code>MutableList&lt;T&gt;</code>, and so it can be made generic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T&gt; MutableList&lt;T&gt;.swap(index1: Int, index2: Int) {
  val tmp = this[index1] // `this` corresponds to the list
  this[index1] = this[index2]
  this[index2] = tmp
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Type-parameters of a generic function are declared before the function name (and before the receiver type, if present). <em>[Rationale:</em> type-parameters may be used in the receiver type, and it is considered prudent to put the declaration before usage.  It also enables better IDE support. <em>End rationale]</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Extensions are resolved statically</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Extensions do not modify classes they extend. By defining an extension, one do not insert new members into a class, but merely make new functions callable with the dot-notation on instances of this class.</p>
</div>
<div class="paragraph">
<p>Extension functions are dispatched statically, i.e. they are not virtual by receiver type. If there is a member and extension of the same type both applicable to given arguments, a member always wins. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class C {
    fun foo() { println("member") }
}

fun C.foo() { println("extension") }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>c.foo()</code> is called on any <code>c</code> of type <code>C</code>, it will print "member", not "extension".</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nullable Receiver</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an expression even if its value is null, and can check for <code>this == null</code> inside the body. [Example: This is what allows to call toString() in Kotlin without checking for null: the check happens inside the extension function. End example]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun Any?.toString(): String {
    if (this == null) return "null"
    // after the null check, `this` is auto-cast to a non-null type, so the toString() below
    // resolves to the member function of the Any class
    return toString()
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Extension Properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Similarly to functions, Kotlin supports extension properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val &lt;T&gt; List&lt;T&gt;.lastIndex: Int
  get() = size - 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, since extensions do not actually insert members into classes, there is no efficient way for an extension property to have a backing field. This is why initializers are not allowed for extension properties. Their behavior can only be defined by explicitly providing getters/setters.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val Foo.bar = 1 // error: initializers are not allowed for extension properties</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Companion Object Extensions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a class has a companion object defined, one can also define extension functions and properties for the companion object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class MyClass {
  companion object { }  // will be called "Companion"
}

fun MyClass.Companion.foo() {
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>MyClass.foo()</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Scope of Extensions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the time extensions are defined on the top level, i.e. outside of any type declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package foo.bar

fun Baz.goo() { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use such an extension outside its declaring package, it has to be imported at the call site:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package com.example.usage

import foo.bar.goo // importing all extensions by name "goo"
                   // or
import foo.bar.*   // importing everything from "foo.bar"

fun usage(baz: Baz) {
  baz.goo()
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_object_construction">10.8. Object Construction</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_runtime_virtual_invocation_dispatch">10.9. Runtime Virtual Invocation Dispatch</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_singleton_objects_2">10.10. Singleton Objects</h3>
<div class="paragraph">
<p>Kotlin has a predefined syntax to declaring singleton objects.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functional_programming_features">11. Functional Programming Features</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_15">11.1. General</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_functional_values">11.2. Functional Values</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_method_references">11.3. Method References</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_anonymous_functions">11.4. Anonymous Functions</h3>
<div class="ulist">
<ul>
<li>
<p>Higher-Order Functions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A higher-order function is a function that takes functions as parameters, or returns a function. A good example of such a function is <code>lock()</code> that takes a lock object and a function, acquires the lock, runs the function and releases the lock:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun lock&lt;T&gt;(lock: Lock, body: () -&gt; T): T {
  lock.lock()
  try {
    return body()
  }
  finally {
    lock.unlock()
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let us examine the code above: <code>body</code> has a function type <code>() -&gt; T</code>, so it is supposed to be a function that takes no parameters and returns a value of type <code>T</code>. It is invoked inside the <code>try</code>-block, while protected by the <code>lock</code>, and its result is returned by the <code>lock()</code> function.</p>
</div>
<div class="paragraph">
<p>If we want to call <code>lock()</code>, we can pass another function to it as an argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun toBeSynchronized() = sharedResource.operation()

val result = lock(lock, ::toBeSynchronized)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another, often more convenient way is to pass a function literal (often referred to as <em>lambda expression</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val result = lock(lock, { sharedResource.operation() })</code></pre>
</div>
</div>
<div class="paragraph">
<p>Function literals are described in more detail below, but to facilitate understanding of this section, here is a brief summary:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A function literal is always surrounded by curly braces,</p>
</li>
<li>
<p>Its parameters (if any) are declared before <code>-&gt;</code> (parameter types may be omitted),</p>
</li>
<li>
<p>The body goes after <code>-&gt;</code> (when present).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a function can be invoked with only one argument, and the argument is a function literal, then instead of using regular syntax <code>f({&#8230;&#8203;})</code>, the explicit argument list can be omitted and the function literal specified immediately after the function name (and after the type-argument list, if present).</p>
</div>
<div class="paragraph">
<p>If a function can be invoked with an argument list, where the last argument is a function literal, the syntax <code>f(&#8230;&#8203;) { &#8230;&#8203; }</code> can be used, where the explicit argument list between the parentheses contains all arguments except the last one, and the last argument, which is a function literal, is specified immediately after the function name (and after the type-argument list, if present). [Note: The explicit argument list may have zero arguments in this case. End note]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>lock (lock) {
  sharedResource.operation()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another example of a higher-order function would be <code>map()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T, R&gt; List&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; {
  val result = arrayListOf&lt;R&gt;()
  for (item in this)
    result.add(transform(item))
  return result
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This function can be called as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val doubled = ints.map { it -&gt; it * 2 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another helpful convention is that if a function literal has only one parameter, its declaration may be omitted (along with the <code>-&gt;</code>), and it will be implicitly named <code>it</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ints.map { it * 2 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>These conventions allow to write code like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>strings.filter { it.length == 5 }.sortBy { it }.map { it.toUpperCase() }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Inline Functions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sometimes it is beneficial to enhance performance of higher-order functions using inline functions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Function Literals and Function Expressions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A function literal or a function expression is an "anonymous function", i.e. a function that is not declared, but passed immediately as an expression. Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>max(strings, { a, b -&gt; a.length() &lt; b.length() })</code></pre>
</div>
</div>
<div class="paragraph">
<p>Function <code>max</code> is a higher-order function, i.e. it takes a function value as the second argument. This second argument is an expression that is itself a function, i.e. a function literal. As a function, it is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun compare(a: String, b: String): Boolean = a.length() &lt; b.length()</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Function Types</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a function to accept another function as a parameter, the parameter can be declared to be of a function type. For example the aforementioned function <code>max</code> is defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun max&lt;T&gt;(collection: Collection&lt;out T&gt;, less: (T, T) -&gt; Boolean): T? {
  var max: T? = null
  for (it in collection)
    if (max == null || less(max!!, it))
      max = it
  return max
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameter <code>less</code> is of type <code>(T, T) -&gt; Boolean</code>, i.e. a function that takes two parameters of type <code>T</code> and returns a <code>Boolean</code>:
true if the first one is smaller than the second one.</p>
</div>
<div class="paragraph">
<p>In the body, line 4, <code>less</code> is used as a function: it is called by passing two arguments of type <code>T</code>.</p>
</div>
<div class="paragraph">
<p>A function type is written as above, or may have named parameters, for documentation purposes and to enable calls with named arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val compare: (x: T, y: T) -&gt; Int = ...</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Function Literal Syntax</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The full syntactic form of function literals, i.e. literals of function types, is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val sum = { x: Int, y: Int -&gt; x + y }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A function literal is always surrounded by curly braces, parameter declarations in the full syntactic form go inside parentheses and have optional type annotations, the body goes after an <code>-&gt;</code> sign. If all the optional annotations are left out, then the function literal looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val sum: (Int, Int) -&gt; Int = { x, y -&gt; x + y }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is very common that a function literal has only one parameter. If the signature can be inferred from the context, it is permitted not to declare the single parameter, and it will be implicitly declared and will have the name <code>it</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ints.filter { it &gt; 0 } // this literal is of type `(it: Int) -&gt; Boolean`</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Function Expressions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One thing missing from the function literal syntax presented above is the ability to specify the return type of the function. In most cases, this is unnecessary because the return type can be inferred automatically. To specify it explicitly, an alternative syntax can be used: a <em>function expression</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun(x: Int, y: Int): Int = x + y</code></pre>
</div>
</div>
<div class="paragraph">
<p>A function expression looks very much like a regular function declaration, except that its name is omitted. Its body can be either an expression (as shown above) or a block:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun(x: Int, y: Int): Int {
  return x + y
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameters and the return type are specified in the same way as for regular functions, except that the parameter types can be omitted if they can be inferred from context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ints.filter(fun(item) = item &gt; 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The return type inference for function expressions works just like for normal functions: the return type is inferred automatically for function expressions with an expression body and has to be specified explicitly (or is assumed to be <code>Unit</code>) for function expressions with a block body.</p>
</div>
<div class="paragraph">
<p>Note that function expression parameters are always passed inside the parentheses. The shorthand syntax allowing to leave the function outside the parentheses works only for function literals.</p>
</div>
<div class="paragraph">
<p>One other difference between function literals and function expressions is the behavior of non-local returns. A <code>return</code>  statement without a label always returns from the function declared with the <code>fun</code> keyword. This means that a <code>return</code> inside a function literal will return from the enclosing function, whereas a <code>return</code> inside a function expression will return from the function expression itself.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Closures</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A function literal or expression (as well as a local function and an object expression) can access its <em>closure</em>, i.e. the variables declared in the outer scope. Unlike Java, the variables captured in the closure can be modified:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>var sum = 0
ints.filter { it &gt; 0 }.forEach {
  sum += it
}
print(sum)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Extension Function Expressions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TODO: Move to informal introduction
In addition to ordinary functions, Kotlin supports extension functions. Extension function literals and expressions are also supported.</p>
</div>
<div class="paragraph">
<p>A function expression can have a receiver type specification, in which case it is called an extension function expression. Extension function expression has an additional implicit parameter of the specified receiver type, which has no name but is available within the function body through the <code>this</code> keyword.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val sum = fun Int.(other: Int): Int = this + other</code></pre>
</div>
</div>
<div class="paragraph">
<p>Receiver type may be specified explicitly only in function expressions, not in function literals. Function literals can be used in context where an expression of an extension function type is expected, provided that the receiver type can be inferred from the context.</p>
</div>
<div class="paragraph">
<p>The type of an extension function expression is a function type with receiver:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>sum : Int.(other: Int) -&gt; Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function can be called as if it were a method on the receiver object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1.sum(2)</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_lambda_as_an_argument_to_an_invocation">11.4.1. Lambda as an Argument to an Invocation</h4>
<div class="paragraph">
<p>TODO: Special syntax</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_function_inlining">11.5. Function Inlining</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_inline_functions">11.5.1. inline Functions</h4>
<div class="paragraph">
<p>An inline function is declared with the modifier <code>inline</code>. Any of type-parameters of an inline functions can be made reified by declaring them with reified modifier. A virtual function (i.e. non-private, non-final method) cannot be declared inline. An inline function cannot be directly recursive (it also cannot invoke itself inside nested lambdas, and cannot have a callable reference to itself). An inline function cannot be indirectly recursive if at least one recursion cycle contains only inline functions.</p>
</div>
<div class="paragraph">
<p>The following declarations and expressions are not supported anywhere inside inline functions
(including any nested object expressions):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>declarations of local functions</p>
</li>
<li>
<p>declarations of local classes</p>
</li>
<li>
<p>declarations of inner nested classes</p>
</li>
<li>
<p>function expressions (starting with fun keyword)</p>
</li>
<li>
<p>default values for optional parameters</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A local function cannot be declared inline.</p>
</div>
<div class="paragraph">
<p>If an <code>inline</code> function has a parameter of a functional type without <code>noinline</code> annotation, and an argument corresponding to this parameter is an anonymous function (function expression or function literal), then this anonymous function is inlined at each of its usages in the body of the inline function (which is itself is inlined at its call site). The function literal is allowed to have non-local return statements in such cases. There are also certain restrictions on use of such parameters: they cannot be assigned to variables, fields, properties, or array elements or passed as arguments to non-inline functions (or arguments to inline functions that are not inlined, e.g. have non-functional declared type, vararg modifier, or noinline annotation). Unless they are annotated with the annotation <code>crossinline</code>, they cannot be used within function literals or object expressions.</p>
</div>
<div class="paragraph">
<p>A parameters of an <code>inline</code> function whose type is a nullable functional types must have <code>noinline</code> or <code>vararg</code> annotation.</p>
</div>
<div class="paragraph">
<p>Using higher-order functions brings certain runtime overhead: each function is an object, and it captures a closure, i.e. those variables that are accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead.</p>
</div>
<div class="paragraph">
<p>But in many cases this kind of overhead can be eliminated by inlining the function literals. The functions shown above are good examples of this situation. I.e., the <code>lock()</code> function could be easily inlined at call-sites. Consider the following case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>lock(l) { foo() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>lock.lock()
try {
  foo()
}
finally {
  lock.unlock()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make the compiler do this, the <code>lock()</code> function has to be annotated with the <code>inline</code> modifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>inline fun lock&lt;T&gt;(lock: Lock, body: () -&gt; T): T {
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>inline</code> modifier affects both the function itself and the lambdas passed to it: all of those will be inlined into the call site.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>noinline</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In case it is intended that only some of the lambdas passed to an inline function are to be inlined, some of the function parameters can be marked with the <code>noinline</code> modifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but <code>noinline</code> ones can be manipulated as any other values: stored in fields, passed around etc.</p>
</div>
<div class="paragraph">
<p>Note that if an inline function has no inlinable function parameters and no reified type-parameters, the compiler will issue a warning. [Rationale: inlining such functions is very unlikely to be beneficial. End Rationale]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Non-local returns</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To exit a named function or a function expression, the simple unqualified form of the <code>return</code> expression is used. But to exit a lambda, the <code>return</code> expression with a label has to be used, and an unqualified <code>return</code> is forbidden inside a lambda. [Rationale: a lambda cannot make the enclosing function return. End rationale]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun foo() {
  ordinaryFunction {
     return // ERROR: cannot make `foo` return here
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if the function the lambda is passed to is inlined, the return can be inlined as well, so it is allowed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun foo() {
  inlineFunction {
    return // OK: the lambda is inlined
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such returns (located in a lambda, but exiting the enclosing function) are called <strong>non-local</strong> returns. This sort of constructs are often used in loops, which inline functions often enclose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun hasZeros(ints: List&lt;Int&gt;): Boolean {
  ints.forEach {
    if (it == 0) return true // returns from hasZeros
  }
  return false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body, but from another execution context, such as a local object or a nested function. In such cases, non-local control flow is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with the <code>crossinline</code> modifier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>inline fun f(crossinline body: () -&gt; Unit) {
    val f = object: Runnable {
        override fun run() = body()
    }
    // ...
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Reified type-parameters</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sometimes it is necessary to access a type passed as a parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T&gt; TreeNode.findParentOfType(clazz: Class&lt;T&gt;): T? {
    var p = parent
    while (p != null &amp;&amp; !clazz.isInstance(p)) {
        p = p?.parent
    }
    @Suppress("UNCHECKED_CAST")
    return p as T
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the function walks up a tree and uses reflection to check if a node has a certain type. Unfortunately, the call site looks overly verbose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>myTree.findParentOfType(MyTreeNodeType::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It would be more readable if the type could be provided as a type-argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>myTree.findParentOfType&lt;MyTreeNodeType&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To enable this, inline functions support <strong>reified type-parameters</strong>. Using them, the method can be rewritten as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>inline fun &lt;reified T&gt; TreeNode.findParentOfType(): T? {
    var p = parent
    while (p != null &amp;&amp; p !is T) {
        p = p?.parent
    }
    return p as T
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the type-parameter is annotated with the <code>reified</code> modifier, that makes it accessible inside the function much like a regular class. Since the function is inlined, no reflection is necessary, and operators like <code>!is</code> and <code>as</code> can be used instead. The call site now takes the desired form: <code>myTree.findParentOfType&lt;MyTreeNodeType&gt;()</code>.</p>
</div>
<div class="paragraph">
<p>Though reflection may not be needed in many cases, it still can be used with a reified type-parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>inline fun membersOf&lt;reified T&gt;() = T::class.members

fun main(s: Array&lt;String&gt;) {
  println(membersOf&lt;StringBuilder&gt;().joinToString("\n"))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Functions not marked as <code>inline</code> cannot have reified parameters. A type that does not have a run-time representation (e.g. a non-reified type-parameter or a fictitious type like <code>Nothing</code>) cannot be used as an argument for a reified type-parameter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_closures">11.6. Closures</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_instantiation_and_lifetime_of_captured_variables">11.6.1. Instantiation and Lifetime of Captured Variables</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_implications_for_strong_references_and_garbage_collection">11.6.2. Implications for Strong References and Garbage Collection</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_external_modifier">11.6.3. external Modifier</h4>
<div class="paragraph">
<p><code>external</code> modifier is only applicable to top-level functions, or to class members (not to interface members). Top-level function mush have a body unless it is external. External function cannot be inline. External function cannot have a body. If function is not external and not abstract, it must have a body. A constructor cannot be external.</p>
</div>
<div class="paragraph">
<p>TODO: external accessors?</p>
</div>
</div>
<div class="sect3">
<h4 id="_tailrec_modifier">11.6.4. tailrec Modifier</h4>
<div class="paragraph">
<p><code>tailrec</code> modifier on a function indicates that that a function is tail-recursive and its recursive invocations must be optimized by the compiler to loops. If the <code>tailrec</code> modifier is applied to a function that is not actually tail-recursive, a compile-time error occurs.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compilation_units">12. Compilation Units</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_16">12.1. General</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_file_level_annotations">12.2. File-Level Annotations</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_package_specification">12.3. Package Specification</h3>
<div class="paragraph">
<p>If a package specification is present, it shall be at the top of the source file. It is not required to match directories and packages: source files can be placed arbitrarily in the file system. All the contents (such as classes and functions) of the source file are contained by the package declared. If the package is not specified, the contents of such a file belong to the default package that has no name.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_import_directives">12.4. Import Directives</h3>
<div class="paragraph">
<p>Apart from the default imports declared by the module, each file may contain its own import directives.</p>
</div>
<div class="paragraph">
<p>An import directive must refer to a fully qualified name. It is an error if two import directives attempt to import types with the same simple name. If several import directives import the same type multiple times, redundant imports are ignored and the result is the same as if the type was imported only once.</p>
</div>
<div class="paragraph">
<p>It is an error if two import directives import different symbols but attempt to rename them to the same name. If several import directives import the same symbol multiple times and rename it to the same name N, redundant imports are ignored and the result is the same as if the type was imported by the name N only once.</p>
</div>
</div>
<div class="sect2">
<h3 id="_type_and_object_declarations">12.5. Type and Object Declarations</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_package_level_functions">12.6. Package-Level Functions</h3>
<div class="paragraph">
<p>Function visible from outside of a module shall have return type explicitly specified. Unit return type can be omitted.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_classes_2">13. Classes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_17">13.1. General</h3>
<div class="paragraph">
<p>TODO: more precise class definition.</p>
</div>
<div class="paragraph">
<p>Class declarations and interface declarations are similar in the sense that they introduce reference types, provide templates partially or completely describing shape and behavior of objects of those types, and define their subtyping relations. But only class declarations can describe state of objects and their initialization logic. And only class declarations can introduce concrete types, while interface declarations always introduce abstract types. Only single inheritance is supported for classes, while interfaces support multiple inheritance. A class can be a subtype both of its superclass, and of multiple superinterfaces, while an interface can only be a subtype of its superinterfaces and cannot specify its superclass (although all interfaces are implicitly subtypes of the ultimate superclass <code>Any</code>). This section presents specification of class types and class declarations.</p>
</div>
<div class="paragraph">
<p>A class can encapsulate state, object initialization logic, public functional contract, possibly providing a complete or partial implementation of it and an implementation of private functional members it may have. A class can be introduced via a class declaration, object declaration or anonymous object expression. Classes introduced via class or object declarations are named (their names always occur explicitly in their declarations, except for companion objects that are allowed to omit it and use the default name <code>Companion</code>). Classes introduced via anonymous object expressions do not have a denotable name, but still behave as nominal (not structural) types.</p>
</div>
</div>
<div class="sect2">
<h3 id="_class_declarations">13.2. Class Declarations</h3>
<div class="paragraph">
<p>A class declaration can appear at the top level,</p>
</div>
<div class="paragraph">
<p>A body of a class, interface or object declaration is optional. If no explicit body is provided, then an empty body <code>{ }</code> is assumed.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_class_modifiers">13.3. Class Modifiers</h3>
<div class="paragraph">
<p>A class can have zero or more of the following modifiers: visibility modifiers and <code>abstract</code>, <code>enum</code>, <code>final</code>, <code>inner</code>, <code>open</code>, <code>sealed</code>.</p>
</div>
<div class="paragraph">
<p>An order of modifiers is not significant. The same modifier cannot appear more than once in the same modifier list. Not all combinations of modifiers are valid and not all modifiers are allowed on all class declarations.</p>
</div>
<div class="paragraph">
<p>A modifier list can contain no more than one modifier from the set: public private protected internal. Only member classes can have protected modifier.</p>
</div>
<div class="paragraph">
<p>The following pairs of modifiers are incompatible: final open, final abstract, final sealed, sealed open.</p>
</div>
<div class="paragraph">
<p>Modifier <code>open</code> is redundant if <code>abstract</code> is specified. Modifier <code>abstract</code> is redundant if <code>sealed</code> is specified.</p>
</div>
<div class="paragraph">
<p>TODO: factor out the common rules for modifiers and visibility modifiers into a separate section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_initialization_blocks">13.4. Initialization Blocks</h3>
<div class="paragraph">
<p>Initialization block appears within a class body and must be immediately preceded by the <code>init</code> contextual keyword. Initialization block is not a declaration and so does not introduce a symbol. It is evaluated during the primary constructor invocation. A class can have multiple initialization blocks, they are evaluated in their textual order. Primary constructor parameters are in scope throughout all initialization blocks of the class. Variables declared in one initialization block are not in scope in other initialization blocks of the same class.</p>
</div>
<div class="paragraph">
<p>Initialization blocks can also appear in object declarations and object expressions. They are evaluated during the initialization of the corresponding object in their textual order.</p>
</div>
<div class="paragraph">
<p>Annotations on init blocks?</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_class_members">13.5. Class Members</h3>
<div class="paragraph">
<p>Non-abstract classes cannot declare abstract functional members (but can have abstract member classes), and must override all inherited abstract functional members.
TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_constructors">13.6. Constructors</h3>
<div class="paragraph">
<p>A class in Kotlin can have a primary constructor and one or more secondary constructors. The primary constructor is declared in the class header: it goes after the class name (and optional type-parameters). Keywords val and var together with accessibility modifiers can be applied to primary constructor parameters to implicitly declare and initialize properties with the same names. They also can have override modifier to override properties from a supertype. The primary constructor cannot contain any code. Initialization code can be placed in initializer blocks, which are prefixed with the <code>init</code>. Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body.</p>
</div>
<div class="paragraph">
<p>The class can also declare secondary constructors, which are prefixed with constructor. If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class is done using the this keyword.</p>
</div>
<div class="paragraph">
<p>If a non-abstract class does not declare any constructors (primary or secondary), it will have a default primary constructor with no arguments. The visibility of the constructor will be public. In order to avoid creating a default constructor, an empty private constructor can be declared.</p>
</div>
<div class="paragraph">
<p>If the class has a primary constructor, the base type can (and must) be initialized right there, possibly using the parameters of the primary constructor.</p>
</div>
<div class="paragraph">
<p>If the class has no primary constructor, then each secondary constructor has to initialize the base type using the super keyword, or to delegate to another constructor which does that. Note that in this case different secondary constructors can call different constructors of the base type.</p>
</div>
<div class="paragraph">
<p>It is an error to access this of the object being created in a constructor delegation. (TODO: access to members or super access).</p>
</div>
<div class="paragraph">
<p>A class cannot have two or more constructors with the same signature. The @platformName annotation is not applicable to constructors.</p>
</div>
<div class="paragraph">
<p>A constructor cannot have tailrec modifier.</p>
</div>
<div class="paragraph">
<p>Constructor cannot have type-parameters, and there is no way to provide type-arguments to the constructor itself at a constructor invocation.</p>
</div>
<div class="paragraph">
<p>Cycles in constructor delegation are not allowed.</p>
</div>
<div class="paragraph">
<p>Constructor body is optional, if no explicit body is provided then an empty body <code>{ }</code> is assumed. Constructors cannot have an expression body.</p>
</div>
<div class="paragraph">
<p>A constructor can have only visibility modifiers.</p>
</div>
<div class="paragraph">
<p>A constructor declaration in class <code>C</code> introduces a method with name <code>C</code> in the same declaration space where the class <code>C</code> is declared. Such method can overload other methods in the same declaration space (possibly including other constructors) subject to normal overloading rules. Such methods are not considered when methods overriding methods from supertypes are being determined.</p>
</div>
<div class="paragraph">
<p><code>this</code> of the current class is not available in a superclass constructor invocation.</p>
</div>
<div class="sect3">
<h4 id="_secondary_constructors">13.6.1. Secondary constructors</h4>
<div class="ulist">
<ul>
<li>
<p>Examples</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With a primary constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Foo(a: Bar): MySuper() {
  // when there is a primary constructor, (direct or indirect) delegation to it is required
  constructor() : this(Bar()) { ... } // cannot call super() here
  constructor(s: String) : this() { ... }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>No primary constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Foo: MySuper { // initialization of superclass is not allowed
  constructor(a: Int) : super(a + 1) { ... } // must call super() here
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>No primary constructor + two overloaded constructors</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Foo: MySuper { // initialization of superclass is not allowed
  constructor(a: Int) : super(a + 1) { ... }
  constructor() : this(1) { ... } // either super() or delegate to another constructor
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO</p>
<div class="ulist checklist">
<ul class="checklist">
<li>
<p>&#10063; is delegation allowed when no primary constructor is present?</p>
</li>
<li>
<p>&#10063; Allow omitting parameterless delegating calls?</p>
</li>
</ul>
</div>
</li>
<li>
<p>Syntax for primary constructor</p>
<div class="ulist">
<ul>
<li>
<p>There is a primary constructor if</p>
</li>
<li>
<p>parentheses after class name, or</p>
</li>
<li>
<p>there are no secondary constructors (default primary constructor)</p>
</li>
<li>
<p>No parentheses after name and an explicit constructor present &#8658; no primary constructor</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>No primary constructor &#8658; no supertype initialization allowed in the class header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Foo : Bar() { // Error
  constructor(x: Int) : this() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a primary constructor is present, explicit constructors are called <strong>secondary</strong>.</p>
</div>
<div class="paragraph">
<p>Every class must have a constructor. The following is an error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Parent
class Child : Parent { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error is: "superclass must be initialized". This class has a primary constructor, but does not initialize its superclass in the class header.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Syntax for explicit constructors</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>constructor
  : modifiers "constructor" valueParameters (":" constructorDelegationCall) block
  ;

constructorDelegationCall
  : "this" valueArguments
  | "super" valueArguments
  ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Passing lambdas outside parentheses is not allowed in <code>constructorDelegationCall</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rules for delegating calls</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The only situation when an explicit constructor may not have an explicit delegating call is
- when there is no primary constructor and the superclass has a constructor that can be called with no parameters passed to it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Parent {}
class Child: Parent {
  constructor() { ... } // implicitly calls `super()`
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If there is a primary constructor, all explicit constructors must have explicit delegating calls that (directly or indirectly) call the primary constructor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Parent {}
class Child(): Parent() {
  constructor(a: Int) : this() { ... }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Initialization code outside constructors</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The primary constructor&#8217;s body consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>super class initialization from class header</p>
</li>
<li>
<p>assignments to properties from constructor parameters declared with <code>val</code> or <code>var</code></p>
</li>
<li>
<p>property initializers and bodies of anonymous initializers following in the order of appearance in the class body</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the primary constructor is not present, property initializers and anonymous initializers are conceptually "prepended" to the body of each explicit constructor that has a delegating call to super class, and their contents are checked accordingly for definite initialization of properties etc.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Syntax for anonymous initializers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Anonymous initializer in the class body must be prefixed with the <code>init</code> keyword, without parentheses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class C {
  init {
    ... // anonymous initializer
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Checks for constructors</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All constructors must be checked for</p>
</div>
<div class="ulist">
<ul>
<li>
<p>absence of circular delegation</p>
</li>
<li>
<p>overload compatibility</p>
</li>
<li>
<p>definite initialization of all properties that must be initialized</p>
</li>
<li>
<p>absence of non-empty super call for enum constructors</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>No secondary constructors can be declared for</p>
</div>
<div class="ulist">
<ul>
<li>
<p>interfaces</p>
</li>
<li>
<p>objects (named, anonymous, and default)</p>
</li>
<li>
<p>bodies of enum literals</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A data class shall have a primary constructor.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_methods">13.7. Methods</h3>
<div class="paragraph">
<p>Functions that declared as members of a type are called methods.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_properties">13.8. Properties</h3>
<div class="paragraph">
<p>A property is a functional member that is syntactically accessed like a variable, but can be implemented either a simple storage location, or using custom code that is executed when the property is read on written. A property can be read-only or read-write. A read-only property has a single accessor called getter, and a read-write property has a pair of accessors called getter and setter. An accessor is a function that is invoked when the corresponding property is accessed: a getter is invoked on property read, and a setter is invoked or property write.</p>
</div>
<div class="paragraph">
<p>A property can have an underlying storage location called a backing field. Within accessor bodies, the backing field is available as a variable named <code>field</code>. The identifier field is not a reserved keyword, and has a special meaning only within property accessors, and even there can be shadowed according to regular rules. No code outside of a property accessors can name or otherwise access the backing field of the property. The type of the backing field is the same as the type of the property.</p>
</div>
<div class="paragraph">
<p>The backing field exists if at least one accessor is default (non-abstract, non-external and does not have a body) or at least one accessor refers to the backing field using <code>field</code> identifier.</p>
</div>
<div class="sect3">
<h4 id="_delegated_properties">13.8.1. Delegated Properties</h4>
<div class="paragraph">
<p>There are certain common kinds of properties, that without the language support would be necessary to re-implement each time they are needed. Examples include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>lazy properties: the value gets computed only upon first access,</p>
</li>
<li>
<p>observable properties: listeners get notified about changes to this property,</p>
</li>
<li>
<p>storing properties in a map, not in separate field each.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To cover these (and other) cases, Kotlin supports <em>delegated properties</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Example {
  var p: String by Delegate()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax is: <code>val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code>. The expression after <code>by</code> is the <em>delegate</em>, because <code>get()</code> (and <code>set()</code>) corresponding to the property will be delegated to its <code>getValue()</code> and <code>setValue()</code> methods. Property delegates do not have to implement any interface, but they have to provide a <code>getValue()</code> function (and <code>setValue()</code> --- for `var`s).
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Delegate {
  operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String {
    return "$thisRef, thank you for delegating '${property.name}' to me!"
  }

  operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) {
    println("$value has been assigned to '${property.name} in $thisRef.'")
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the code reads from <code>p</code> that delegates to an instance of <code>Delegate</code>, the <code>getValue()</code> function from <code>Delegate</code> is called, so that its first parameter is the object <code>p</code> is read from and the second parameter holds a description of <code>p</code> itself (e.g. it is possible to take its name). For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val e = Example()
println(e.p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This prints</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Example@33a17727, thank you for delegating 'p' to me!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, when a value is assigned to <code>p</code>, the <code>setValue()</code> function is called. The first two parameters are the same, and the third holds the value being assigned:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>e.p = "NEW"</code></pre>
</div>
</div>
<div class="paragraph">
<p>This prints</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>NEW has been assigned to 'p' in Example@33a17727.</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Property Delegate Requirements</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is a summary of requirements to delegate objects.</p>
</div>
<div class="paragraph">
<p>For a read-only property (i.e. a <code>val</code>), a delegate has to provide a function named <code>getValue</code> that takes the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>receiver --- must be the same or a supertype of the <em>property owner</em> (for extension properties --- the type being extended),</p>
</li>
<li>
<p>metadata --- must be of type <code>KProperty&lt;*&gt;</code> or its supertype,</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>this function must return the same type as property (or its subtype).</p>
</div>
<div class="paragraph">
<p>For a mutable property (a <code>var</code>), a delegate has to <em>additionally</em> provide a function named <code>setValue</code> that takes the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>receiver --- same as for <code>getValue()</code>,</p>
</li>
<li>
<p>metadata --- same as for <code>getValue()</code>,</p>
</li>
<li>
<p>new value --- must be of the same type as a property or its supertype.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>getValue()</code> and/or <code>setValue()</code> functions may be provided either as member functions of the delegate class or extension functions. The latter is handy when one need to delegate property to an object which does not originally provide these functions. Both of the functions need to be marked with the <code>operator</code> keyword.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Standard Delegates</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Kotlin standard library provides factory methods for several useful kinds of delegates.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lazy</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>lazy()</code> is a function that takes a lambda and returns an instance of <code>Lazy&lt;T&gt;</code> which can serve as a delegate for implementing a lazy property: the first call to <code>get()</code> executes the lambda passed to <code>lazy()</code> and remembers the result, subsequent calls to <code>get()</code> simply return the remembered result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}

fun main(args: Array&lt;String&gt;) {
    println(lazyValue)
    println(lazyValue)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the evaluation of lazy properties is synchronized: the value is computed only in one thread, and all threads will observe the same value. If the synchronization of initialization delegate is not required, so that multiple threads can execute it simultaneously, pass <code>LazyThreadSafetyMode.PUBLICATION</code> as a parameter to the <code>lazy()</code> function. And if it is known for certain that the initialization will always happen on a single thread, one can use <code>LazyThreadSafetyMode.NONE</code> mode, which does not incur any thread-safety guarantees and the related overhead.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Observable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Delegates.observable()</code> takes two arguments: the initial value and a handler for modifications. The handler gets called every time a value is assigned to the property (<em>after</em> the assignment has been performed). It has three parameters: a property being assigned to, the old value and the new one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import kotlin.properties.Delegates

class User {
    var name: String by Delegates.observable("&lt;no name&gt;") {
        prop, old, new -&gt;
        println("$old -&gt; $new")
    }
}

fun main(args: Array&lt;String&gt;) {
    val user = User()
    user.name = "first"
    user.name = "second"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example prints</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;no name&gt; -&gt; first
first -&gt; second</code></pre>
</div>
</div>
<div class="paragraph">
<p>If one want to be able to intercept an assignment and "veto" it, use <code>vetoable()</code> instead of <code>observable()</code>. The handler passed to the <code>vetoable</code> is called <em>before</em> the assignment of a new property value has been performed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Storing Properties in a Map</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>One common use case is storing the values of properties in a map. [Example: This comes up often in applications like parsing JSON or doing other "dynamic" things. End example] In this case, one can use the map instance itself as the delegate for a delegated property. In order for this to work, one needs to import an extension accessor function <code>getValue()</code> that adapts maps to the delegated property API: it reads property values from the map, using property name as a key.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import kotlin.properties.getValue

class User(val map: Map&lt;String, Any?&gt;) {
    val name: String by map
    val age: Int     by map
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the constructor takes a map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val user = User(mapOf(
    "name" to "John Doe",
    "age"  to 25
))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Delegated properties take values from this map (by the string keys&#8201;&#8212;&#8201;names of properties):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>println(user.name) // Prints "John Doe"
println(user.age)  // Prints 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works also for <code>var&#8217;s properties if a `MutableMap</code> is used instead of read-only <code>Map</code> and an additional extension function is imported: <code>kotlin.properties.setValue</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import kotlin.properties.getValue
import kotlin.properties.setValue

class MutableUser(val map: MutableMap&lt;String, Any?&gt;) {
    var name: String by map
    var age: Int     by map
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_general_18">13.8.2. General</h4>
<div class="paragraph">
<p>Classes in Kotlin can have properties. These can be declared as mutable, using the var keyword or read-only using the val keyword.</p>
</div>
</div>
<div class="sect3">
<h4 id="_properties_without_explicit_accessors">13.8.3. Properties without Explicit Accessors</h4>
<div class="paragraph">
<p>Non-abstract properties must have an initializer.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_properties_with_explicit_accessors">13.8.4. Properties with Explicit Accessors</h4>
<div class="paragraph">
<p>The full syntax for declaring a property is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>var &lt;propertyName&gt;: &lt;PropertyType&gt; [= &lt;property_initializer&gt;]
  &lt;getter&gt;
  &lt;setter&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer or from the base class member being overridden. Types are not inferred for properties exposed in the public API, i.e. public and protected. If one need to change the visibility of an accessor or to annotate it, but do not need to change the default implementation, it is possible define the accessor without defining its body.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fields">13.9. Fields</h3>
<div class="paragraph">
<p>Classes cannot declare fields explicitly. But there is an implicitly declared field for every non-abstract property. It can be accessed using the $ symbol followed by the property name (no characters, e.g. whitespace, comments, etc. are allowed between them). A field has private-to-this accessibility, and can only be accessed from inside the class where the corresponding property is defined.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_nested_and_inner_classes">13.10. Nested and Inner Classes</h3>
<div class="paragraph">
<p>Inner classes are nested classes declared using inner modifier. Inner classes cannot be declared within interfaces or non-inner nested classes. Inner classes may not contain nested interface declarations or non-inner nested class declarations. Inner classes have access to current instances of their enclosing classes.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_sealed_classes">13.11. Sealed Classes</h3>
<div class="paragraph">
<p>Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but cannot have any other type. They are, in a sense, an extension of enum classes: the set of values for an enum type is also restricted, but each enum constant exists only as a single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.</p>
</div>
<div class="paragraph">
<p>To declare a sealed class, one puts the <code>sealed</code> modifier before the name of the class. A sealed class can have subclasses, but all of them must be nested inside the declaration of the sealed class itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>sealed class Expr {
    class Const(val number: Double) : Expr()
    class Sum(val e1: Expr, val e2: Expr) : Expr()
    object NotANumber : Expr()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that classes which extend subclasses of a sealed class (indirect inheritors) can be placed anywhere, not necessarily inside the declaration of the sealed class.</p>
</div>
<div class="paragraph">
<p>The key benefit of using sealed classes comes into play when they are used in a <code>when</code> expression. If it is possible to verify that the statement covers all cases, it is not necessary to add an <code>else</code> clause to the statement.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun eval(expr: Expr): Double = when(expr) {
    is Const -&gt; expr.number
    is Sum -&gt; eval(expr.e1) + eval(expr.e2)
    NotANumber -&gt; Double.NaN
    // the `else` clause is not required because all cases are already covered
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_local_classes">13.12. Local Classes</h3>
<div class="paragraph">
<p>A local class is a class declared within a block. A local class cannot have inner modifier. Local classes may not contain nested interface declarations or non-inner nested class declarations. Local classes have access to current instances of their enclosing classes. If a local class is declared within a generic method, then the method&#8217;s type-parameters are in scope in the local class. A local class is only in scope in its containing block from the beginning of its declaration to the end of the containing block (so, it is in scope throughout its own declaration, and not in scope before its declaration). Local classes has access to outer local variables and parameters.</p>
</div>
<div class="paragraph">
<p>TODO: specify capture semantics, compare with lambdas</p>
</div>
</div>
<div class="sect2">
<h3 id="_anonymous_classes">13.13. Anonymous Classes</h3>
<div class="paragraph">
<p>Anonymous classes are implicitly declared using anonymous class creation expressions (§18.3.10). The body of an anonymous class is the block of the corresponding anonymous class creation expression.</p>
</div>
<div class="paragraph">
<p>TODO: Choose what do describe here and what is in the Expressions section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enum_classes">13.14. Enum Classes</h3>
<div class="paragraph">
<p>An enum class is declared by specifying enum modifier on a class declaration. A body of enum classes have a syntactic shape (TODO: reference to grammar production) different from regular classes, that is described below. The enum modifier is valid only on class declarations. An enum class cannot be an inner or local class. It cannot be a data class. It cannot have open modifier and other classes cannot inherit from it, except classes corresponding to entries of the same enum class, that always implicitly inherit from it. It cannot have abstract modifier, and is always implicitly abstract. It cannot have annotation or sealed modifier. An enum class declaration cannot have type-parameters (and because it cannot be inner or local, it does not have any type-parameters in scope at all).  An enum class declaration cannot specify an explicit superclass, but it can specify superinterfaces. The direct supertype of an enum class E is assumed to be <code>Enum&lt;E&gt;</code>. <em>[Note:</em> As a consequence of the single instantiation inheritance rule (§TODO), if an enum class type <code>E</code> explicitly implements an instantiation of interface <code>Comparable&lt;T&gt;</code>, it must be <code>Comparable&lt;E&gt;</code>, because this instantiation is implemented by its supertype <code>Enum&lt;E&gt;</code>. <em>End Note]</em> An enum class can have a companion object.</p>
</div>
<div class="paragraph">
<p>The only instances of an enum type are the enum entries declared in it. It is not possible to explicitly invoke an enum constructor or create its instance in any other way. All enum entries are distinct objects. A reference equality comparison of an enum entry with an object return true iff the object is that enum entry itself. A constructor of an enum type cannot be invoked explicitly, it can only be implicitly referenced from the declaration of an entry of the same enum. The argument list can be omitted if empty. Trailing lambda, if any, must be provided as a regular explicit argument.</p>
</div>
<div class="paragraph">
<p>Each enum entry must have a unique name within its declaring enum class. An enum entry cannot have visibility modifiers and is implicitly public. Each enum entry name occupies a slot in the enum member declaration space. A secondary constructor cannot delegate to a constructor of the superclass. An enum entry cannot have type-parameters and never has any other type-parameters in scope.</p>
</div>
<div class="paragraph">
<p>An enum entry cannot have modifiers.</p>
</div>
<div class="paragraph">
<p>An enum entry cannot have a companion object. An enum entry can have init blocks. An enum entry cannot have constructors. It cannot specify superinterfaces. Enum classes cannot have abstract modifier, but are implicitly abstract. If an enum class contains at least one abstract functional member, then each its entry must provide implementation for all abstract functional members.</p>
</div>
<div class="paragraph">
<p>A class nested within an enum entry cannot be an inner class (BUG: KT-9750).</p>
</div>
<div class="paragraph">
<p>Synthetic method valueOf(value: String) and synthetic property <code>values</code> and special overload resolution rules for them (including possible conflicts with identically named functions of a companion object).</p>
</div>
<div class="paragraph">
<p>TODO: this and super in enum entries.</p>
</div>
<div class="paragraph">
<p>Enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is <code>EnumClass</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>EnumClass.valueOf(value: String): EnumClass
EnumClass.values(): Array&lt;EnumClass&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>[Rationale:</em> The method <code>values</code> is declared as a method rather than a property, because such a property could potentially conflict with an enum entry named <code>values</code>. <em>End Rationale]</em></p>
</div>
<div class="paragraph">
<p>The <code>valueOf()</code> method throws an <code>IllegalArgumentException</code> if the specified name does not match any of the enum constants defined in the class.</p>
</div>
<div class="paragraph">
<p>Every invocation of the method <code>values()</code> returns a new instance of an array filled with enum entries, so a modification made in the result of one invocation does not affect elements in the result of another invocation.</p>
</div>
<div class="paragraph">
<p>The method <code>equals()</code> of enums performs reference equality comparison, and the method <code>hashCode()</code> is implemented consistently with it.</p>
</div>
<div class="paragraph">
<p>Every enum constant has properties to obtain its name and position in the enum class declaration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val name: String
val ordinal: Int</code></pre>
</div>
</div>
<div class="paragraph">
<p>The enum constants also implement the <code>Comparable</code> interface, with the natural order being the order in which they are defined in the enum class.</p>
</div>
<div class="paragraph">
<p>Enum classes can be nested.</p>
</div>
</div>
<div class="sect2">
<h3 id="_data_classes">13.15. Data Classes</h3>
<div class="paragraph">
<p>A data class is a class declared with a <code>data</code> modifier. A data class is always final. It is permitted, but not required to specify a <code>final</code> modifier on its declaration. A data class cannot specify its superclass, but can specify zero or more superinterfaces. The direct superclass of a data class is always Any. A data class cannot be inner class, but can be local. A data class can contain inner classes.</p>
</div>
<div class="paragraph">
<p>A data class must have a (TODO: public?) primary constructor that has at least one parameter. All primary constructor parameters must be val/var. A data class cannot have <code>enum</code>, <code>annotation</code>, <code>abstract</code>, <code>open</code>, <code>sealed</code> modifiers.</p>
</div>
<div class="paragraph">
<p>A data class provides default implementation for equals, hashCode and toString method. If a declaration of any of these methods is provided explicitly, then it replaces the corresponding default implementation.</p>
</div>
<div class="paragraph">
<p>The default implementation for equals method performs first performs reference equality check for <code>this</code> and its arguments, and if this check returns true, then the equals method returns true. Otherwise, it performs component-wise comparison using == operator in the same order in which the components are declared. If any of the comparisons returns false, the method immediately returns false. Otherwise, if all comparisons return true, then the method returns true. <em>[Note:</em> It is possible that this implementation goes into an infinite recursion if a component of a data class is (or refers to) the current instance. <em>End Note]</em> Components that are arrays are compared like all other types using array&#8217;s <code>equals</code> method (that performs reference equality comparison). <em>[Note:</em> If structural comparison is desired then it is recommended to manually implement equals method using <code>java.util.Arrays.equals</code> or <code>java.util.Arrays.deepEquals</code> and provide a matching implementation of <code>hashCode()</code>. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>It is often necessary to create classes that do nothing but hold data. In such classes some functionality is often mechanically derivable from the data they hold. In Kotlin a class can be marked as <code>data</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data class User(val name: String, val age: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is called a <em>data class</em>. The compiler automatically derives the following members from all properties declared in the primary constructor:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>equals()</code>/<code>hashCode()</code> pair,</p>
</li>
<li>
<p><code>toString()</code> of the form <code>"User(name=John, age=42)"</code>,</p>
</li>
<li>
<p><code>componentN()</code> functions corresponding to the properties in their order or declaration,</p>
</li>
<li>
<p><code>copy()</code> function (described below).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If any of these functions is explicitly defined in the class body or inherited from the base types, it will not be generated.</p>
</div>
<div class="paragraph">
<p>To ensure consistency and meaningful behavior of the generated code, data classes have to fulfil the following requirements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The primary constructor needs to have at least one parameter;</p>
</li>
<li>
<p>All primary constructor parameters need to be marked as <code>val</code> or <code>var</code>;</p>
</li>
<li>
<p>Data classes cannot be abstract, open, sealed or inner;</p>
</li>
<li>
<p>Data classes may not extend other classes (but may implement interfaces).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data class User(val name: String = "", val age: Int = 0)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Copying</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is often necessary to create a copy of an object with <em>some</em> of its properties changed, but keeping the rest unchanged. This is what <code>copy()</code> function is generated for. For the <code>User</code> class above, its implementation would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun copy(name: String = this.name, age: Int = this.age) = User(name, age)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows us to write</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val jack = User(name = "Jack", age = 1)
val olderJack = jack.copy(age = 2)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Data Classes and Multi-Declarations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Component functions generated for data classes enable their use in multi-declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val jane = User("Jane", 35)
val (name, age) = jane
println("$name, $age years of age") // prints "Jane, 35 years of age"</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Standard Data Classes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The standard library provides <code>Pair</code> and <code>Triple</code>. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interfaces_2">14. Interfaces</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_19">14.1. General</h3>
<div class="paragraph">
<p>An interface represents a contract than can be implemented by multiple classes, and a class can implement multiple interfaces. An interface can also specify zero or more superinterfaces. Thus, interfaces provide a restricted mechanism of multiple inheritance. Interfaces cannot contain any data or initialization logic, they can only declare abstract function members and optionally provide a default implementation for some of them. An interface cannot be instantiated directly, only a class implementing this interface can be instantiated, and an instance of such a class is also considered an instance of the interface.</p>
</div>
<div class="paragraph">
<p>An interface cannot explicitly declare a superclass. But because an instance of an interface can only exist as an instance of some class that implements it, and every class has the class kotlin.Any as its ultimate superclass, every interface is considered to have <code>kotlin.Any</code> as its only superclass, and consequently, it is assignable to that class and inherits its members (unless they are overridden by a superinterface of this interface).</p>
</div>
<div class="paragraph">
<p>An interface method without a body can be marked <code>abstract</code>, but this is redundant.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interface_declarations">14.2. Interface Declarations</h3>
<div class="paragraph">
<p>An interface is declared using interface declaration that can be recognized by presence of <code>interface</code> keyword, followed by the interface simple name. An interface name is an identifier. The fully-qualified interface is obtained by appending a dot token followed by the simple name to the fully qualified name of the interface&#8217;s container. Each interface has exactly one corresponding interface declaration. It is an error if the program contains two or more interface declarations that attempt to declare interfaces with the same fully qualified name.</p>
</div>
<div class="paragraph">
<p>TODO: Conflict between declared and imported types.</p>
</div>
<div class="paragraph">
<p>An interface declaration cannot have an initialization block or a constructor declaration.</p>
</div>
<div class="paragraph">
<p>Interfaces can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract.</p>
</div>
<div class="paragraph">
<p>An interface is defined using the keyword <strong>interface</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface MyInterface {
    fun bar()
    fun foo() {
      // optional body
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Implementing Interfaces</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A class or object can implement one or more interfaces</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Child : MyInterface {
   fun bar() {
      // body
   }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Properties in Interfaces</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Interfaces allow properties as long as these are stateless, that is because interfaces do not allow state.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface MyInterface {
    val property: Int // abstract

    fun foo() {
        print(property)
    }
}

class Child : MyInterface {
    override val property: Int = 29
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Resolving overriding conflicts</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If many types are specified in the supertype list, it may happen that the class inherits more than one implementation of the same method. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
  fun foo() { print("A") }
  fun bar()
}

interface B {
  fun foo() { print("B") }
  fun bar() { print("bar") }
}

class C : A {
  override fun bar() { print("bar") }
}

class D : A, B {
  override fun foo() {
    super&lt;A&gt;.foo()
    super&lt;B&gt;.foo()
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interfaces <code>A</code> and <code>B</code> both declare functions <code>foo()</code> and <code>bar()</code>. Both of them implement <code>foo()</code>, but only <code>B</code> implements <code>bar()</code> (<code>bar()</code> is not marked <code>abstract</code> in <code>A</code>, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class <code>C</code> from <code>A</code>, we, obviously, have to override <code>bar()</code> and provide an implementation. And if we derive <code>D</code> from <code>A</code> and <code>B</code>, we do not have to override <code>bar()</code>, because we have inherited only one implementation of it. But we have inherited two implementations of <code>foo()</code>, so the compiler does not know which one to choose, and forces us to override <code>foo()</code> and say what we want explicitly.</p>
</div>
<div class="sect3">
<h4 id="_methods_2">14.2.1. Methods</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_properties_2">14.2.2. Properties</h4>
<div class="paragraph">
<p>Properties in interfaces cannot have state, and never have an associated implicitly declared field.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_interfaces_vs_classes">14.3. Interfaces vs. Classes</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_annotations">15. Annotations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_20">15.1. General</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_declarations">15.2. Declarations</h3>
<div class="paragraph">
<p>An annotation class is declared by providing the <code>annotation</code> modifier in a class declaration. It is an error if an annotation class is generic. An annotation class declaration cannot have a body (and so, cannot have a companion object, nested or inner classes or any members other than inherited or introduced in its primary constructor). An annotation class cannot specify its supertypes explicitly. The immediate superclass of every annotation class is <code>kotlin.Annotation</code>. An annotation class cannot be an inner class, but can be a local class (TODO: bug?). If no primary constructor is specified, then a primary constructor with an empty parameter list is assumed.</p>
</div>
<div class="paragraph">
<p>An annotation class is implicitly final. An annotation class cannot have <code>final</code>, <code>open</code>, <code>abstract</code>, <code>sealed</code>, <code>enum</code> or <code>data</code> modifiers.
TODO</p>
</div>
<div class="sect3">
<h4 id="_primary_constructor_parameters">15.2.1. Primary Constructor Parameters</h4>
<div class="paragraph">
<p>Parameters of the primary constructor in an annotation class must be declared with <code>val</code> or <code>var</code> keyword. A type of a parameter cannot be nullable type. A type of a parameter must be one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Primitive type: <code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code>, <code>Char</code>, <code>Boolean</code>, <code>Float</code>, <code>Double</code></p>
</li>
<li>
<p><code>String</code></p>
</li>
<li>
<p>An instantiation or a projection of <code>KClass&lt;T&gt;</code></p>
</li>
<li>
<p>An enum type</p>
</li>
<li>
<p>An annotation class</p>
</li>
<li>
<p>An array of any of above-mentioned types, or an out-projection of <code>Array&lt;T&gt;</code> with any of above-mentioned types.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>[Note:</em> Arrays of arrays are not supported. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>Default values for parameters, if any, must be expressions that would be valid arguments to an annotation application, and they cannot refer to other parameters.</p>
</div>
<div class="paragraph">
<p>An annotation class cannot be instantiated using a constructor invocation in an executable code. Annotation constructor invocations are only allowed in annotation applications, and are only instantiated by the runtime [TODO: when?]</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_annotation_targets">15.3. Annotation Targets</h3>
<div class="paragraph">
<p>A declaration of an annotation specifies to which code elements the annotation can be applied. Those code elements are called targets. The following targets exist:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>method declaration</p>
</li>
<li>
<p>type declaration</p>
</li>
<li>
<p>file</p>
</li>
<li>
<p>type-parameter</p>
</li>
<li>
<p>parameter</p>
</li>
<li>
<p>TODO</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If annotation targets are not specified at its declaration, it has the default set of targets: TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_applying_annotations">15.4. Applying Annotations</h3>
<div class="paragraph">
<p>An argument to an annotation application must be a compile-time constant, a class expression, an annotation constructor invocation, an invocation of <code>arrayOf(&#8230;&#8203;)</code> function. In the two latter cases, arguments to an invocation must be expressions that would be valid arguments to an annotation application.</p>
</div>
<div class="paragraph">
<p>File annotations are only allowed at the top of a source file. The import directives below them, if any, are still in effect for the name resolution in file annotations.</p>
</div>
<div class="paragraph">
<p>If an annotation is specified in a position where it can possibly apply to several different targets, then the target is selected according to the list of possible targets of the annotations. If several targets match, then the first applicable target from the following list is selected: parameter, property, field.</p>
</div>
<div class="paragraph">
<p>TODO: @-syntax and simplified syntax.</p>
</div>
<div class="paragraph">
<p>TODO: Meaning of annotations in functional types. Equality of types that differ in annotations.
An argument to an annotation application must be a compile-time constant, a class expression, an  annotation constructor invocation, an invocation of arrayOf(&#8230;&#8203;) function. In the two latter cases, arguments to an invocation must be expressions that would be valid arguments to an annotation application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_retention_levels">15.5. Retention Levels</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_predefined_annotations_significant_for_kotlin_compiler">15.6. Predefined Annotations Significant for Kotlin Compiler</h3>
<div class="sect3">
<h4 id="_general_21">15.6.1. General</h4>
<div class="paragraph">
<p>Some annotations defined in the standard library have a special meaning for the compiler and may change meaning of the language, including allowed syntactic shapes of some language constructs. They may cause or suppress compiler diagnostics. Some of them have applicability constraints more strict that would follow from their <code>target(&#8230;&#8203;)</code> annotation. Some predefined annotations have associated enum classes, whose values can be provided as their arguments and change some details of their meaning.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><em>[Note:</em> Earlier versions of the Kotlin language and standard library had the following annotations, that are currently superseded by corresponding modifiers: <code>annotation</code>, <code>enum</code>, <code>data</code>, <code>inline</code>, <code>noinline</code>. <em>End Note]</em></p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_suppress_annotation">15.6.2. <code>kotlin.Suppress</code> Annotation</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_deprecated_annotation">15.6.3. <code>kotlin.Deprecated</code> Annotation</h4>
<div class="paragraph">
<p>The first parameter is intended to provide motivation and possible workarounds. Its value is not interpreted by the compiler. The second parameter is IDE-specific.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_annotation_retention_annotation">15.6.4. <code>kotlin.annotation.Retention</code> annotation</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_annotation_annotationretention_enum_class">15.6.5. <code>kotlin.annotation.AnnotationRetention</code> Enum Class</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_annotation_target_annotation">15.6.6. <code>kotlin.annotation.Target</code> Annotation</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_annotation_annotationtarget_enum_class">15.6.7. <code>kotlin.annotation.AnnotationTarget</code> Enum Class</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_jvm_synchronized_annotation">15.6.8. <code>kotlin.jvm.Synchronized</code> Annotation</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_jvm_strictfp_annotation">15.6.9. <code>kotlin.jvm.Strictfp</code> Annotation</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_jvm_volatile_annotation">15.6.10. <code>kotlin.jvm.Volatile</code> Annotation</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_jvm_transient_annotation">15.6.11. <code>kotlin.jvm.Transient</code> Annotation</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_jvm_jvmname_annotation">15.6.12. <code>kotlin.jvm.JvmName</code> Annotation</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_kotlin_jvm_jvmstatic_annotation">15.6.13. <code>kotlin.jvm.JvmStatic</code> Annotation</h4>
<div class="ulist">
<ul>
<li>
<p>Annotations</p>
</li>
<li>
<p>Annotation Declaration</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Annotations are means of attaching metadata to code. To declare an annotation, put the <code>annotation</code> modifier in front of a class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>annotation class Fancy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additional attributes of the annotation can be specified by annotating the annotation class with meta-annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Target</code> specifies the possible kinds of elements which can be annotated with the annotation (classes, functions, properties, expressions etc.);</p>
</li>
<li>
<p><code>@Retention</code> specifies whether the annotation is stored in the compiled class files and whether it is visible through reflection at runtime (by default, both are true);</p>
</li>
<li>
<p><code>@Repeatable</code> allows using the same annotation on a single element multiple times;</p>
</li>
<li>
<p><code>@MustBeDocumented</code> specifies that the annotation is part of the public API and is to be included in the class or method signature shown in the generated API documentation.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION,
        AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.EXPRESSION)
@Retention(AnnotationRetention.SOURCE)
@MustBeDocumented
public annotation class Fancy</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Usage</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Fancy class Foo {
  @Fancy fun baz(@Fancy foo: Int): Int {
    return (@Fancy 1)
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To put an annotation on the primary constructor of a class, the explicit <code>constructor</code> keyword has to be used in the class header, and the annotation section has to be specified immediately before it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Foo @Inject constructor(dependency: MyDependency) {
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Property accessors can also be annotated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Foo {
    var x: MyDependency? = null
        @Inject set
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Constructors</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Annotations may have constructors that take parameters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>annotation class Special(val why: String)

@Special("example") class Foo {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an annotation is used as a parameter of another annotation, its name is not prefixed with the @ character:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>public annotation class ReplaceWith(val expression: String)

public annotation class Deprecated(
        val message: String,
        val replaceWith: ReplaceWith = ReplaceWith(""))

@Deprecated("This function is deprecated, use === instead", ReplaceWith("this === other"))</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Lambdas</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Annotations can also be used on lambdas. They will be applied to the <code>invoke()</code> method into which the body of the lambda is generated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>annotation class Suspendable

val f = @Suspendable { Fiber.sleep(10) }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Annotation Use-site Targets</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When annotating a property or a primary constructor parameter, there are multiple Java elements which are generated from the corresponding Kotlin element, and therefore multiple possible locations for the annotation in the generated Java bytecode. To specify how exactly the annotation is to be generated, use the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Example(@field:Ann val foo,    // annotate Java field
              @get:Ann val bar,      // annotate Java getter
              @param:Ann val quux)   // annotate Java constructor parameter</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target <code>file</code> at the top level of a file, before the package directive or before all imports if the file is in the default package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@file:JvmName("Foo")

package org.jetbrains.demo</code></pre>
</div>
</div>
<div class="paragraph">
<p>If multiple annotations with the same target is used together, repeating the target can be avoided by adding brackets after the target and putting all the annotations inside the brackets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class Example {
     @set:[Inject VisibleForTesting]
     public var collaborator: Collaborator
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The full list of supported use-site targets is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>file</code></p>
</li>
<li>
<p><code>property</code> (annotations with this target are not visible to Java)</p>
</li>
<li>
<p><code>field</code></p>
</li>
<li>
<p><code>get</code> (property getter)</p>
</li>
<li>
<p><code>set</code> (property setter)</p>
</li>
<li>
<p><code>receiver</code> (receiver parameter of an extension function or property)</p>
</li>
<li>
<p><code>param</code> (constructor parameter)</p>
</li>
<li>
<p><code>setparam</code> (property setter parameter)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To annotate the receiver parameter of an extension function, use the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun @receiver:Fancy String.myExtension() { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a use-site target is not specified, the target is chosen according to the <code>@Target</code> annotation of the annotation being used. If there are multiple applicable targets, the first applicable target from the following list is used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>param</code></p>
</li>
<li>
<p><code>property</code></p>
</li>
<li>
<p><code>field</code></p>
</li>
<li>
<p>Java Annotations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java annotations are fully compatible with Kotlin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import org.junit.Test
import org.junit.Assert.*

class Tests {
  @Test fun simple() {
    assertEquals(42, getTheAnswer())
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the order of parameters for an annotation written in Java is not defined, a regular function call syntax cannot be used for passing the arguments. Instead, the named argument syntax has to be used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
public @interface Ann {
    int intValue();
    String stringValue();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Kotlin
@Ann(intValue = 1, stringValue = "abc") class C</code></pre>
</div>
</div>
<div class="paragraph">
<p>A special case is the <code>value</code> parameter; its value can be specified without an explicit name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
public @interface AnnWithValue {
    String value();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Kotlin
@AnnWithValue("abc") class C</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>value</code> argument in Java has an array type, it becomes a <code>vararg</code> parameter in Kotlin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
public @interface AnnWithArrayValue {
    String[] value();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Kotlin
@AnnWithArrayValue("abc", "foo", "bar") class C</code></pre>
</div>
</div>
<div class="paragraph">
<p>If one need to specify a class as an argument of an annotation, use a Kotlin class <code>KClass&lt;T&gt;</code>. The Kotlin compiler will automatically convert it to a Java class, so that the Java code will be able to observe the annotations and arguments normally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import kotlin.reflect.KClass

annotation class Ann(val arg1: KClass&lt;*&gt;, val arg2: KClass&lt;out Any?&gt;)

@Ann(String::class, Int::class) class MyClass</code></pre>
</div>
</div>
<div class="paragraph">
<p>Values of an annotation instance are exposed as properties to Kotlin code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
public @interface Ann {
    int value();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// Kotlin
fun foo(ann: Ann) {
    val i = ann.value
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_executable_code">16. Executable Code</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_22">16.1. General</h3>

</div>
<div class="sect2">
<h3 id="_blocks">16.2. Blocks</h3>
<div class="paragraph">
<p>A block is a sequence of zero or more statements enclosed in curly braces <code>{ &#8230;&#8203; }</code>. Blocks can appear as bodies of methods, function expressions, loop bodies, or as initialization blocks. Standalone blocks cannot be used as statements to create nested scopes (but a similar effect could be used by run method from the standard library. TODO: Example).</p>
</div>
<div class="paragraph">
<p>A block is evaluated by sequential evaluation of the statements contained in it.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_statements">16.3. Statements</h3>
<div class="paragraph">
<p>A statement can have one of the following forms: expression statement, declaration statement, assignment statement, loop statement or empty statement (the latter can be a result of putting multiple semicolons in a row).</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_expression_statement">16.4. Expression Statement</h3>
<div class="paragraph">
<p>An expression statement is an expression followed by a semicolon (the latter can be implicit according to the grammar rules). An expression statement is evaluated by evaluation the expression. A value resulted from evaluation of the expression is discarded.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_single_variable_declaration">16.5. Single-Variable Declaration</h3>
<div class="paragraph">
<p>A declaration statement can have one of the following forms: a variable declaration, a local function declaration, of a local type declaration. The declaration statement is terminated by a semicolon (the latter can be implicit according to the grammar rules). Local properties and extension properties are not supported. A variable declaration declares a read-only (<code>val</code>) or mutable (<code>var</code>) local variable. It can have an optional variable type specification after color, and an optional variable initializer after the <code>=</code> token. At least one of them must be present. Evaluation of a variable declaration statement without an initializer does nothing. Evaluation of a variable declaration statement with an initializer consists of evaluation of the initializer and assignment of its result to the declared variable.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_variable_declaration">16.6. Multi-Variable Declaration</h3>
<div class="paragraph">
<p>A declaration of the form <code>val (v1, v2, &#8230;&#8203;) = expr</code> is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val $temp = expr
val v1 = $temp.component1()
val v2 = $temp.component2()
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>where method names all begin with the prefix component followed a 1-based component index in decimal form without leading zeros, and <code>$temp</code> is a fresh name not visible in the user code. Instead of the <code>val</code> keyword, the <code>var</code> keyword may be used, in which case all declared variables become mutable. Some or all components of a multi-declaration may have optional type annotations&#8201;&#8212;&#8201;if present, they are copied in the above expansion to declarations of corresponding variables (and can affect, for example, type inference in the corresponding <code>$temp.componentN()</code> invocations). All component names <code>v1</code>, <code>v2</code>, &#8230;&#8203; must be distinct. Some collection types in the standard library (e.g. arrays) support a fixed number of <code>componentN</code> functions that extract their elements with index (N-1). <code>componentN</code> functions are also automatically generated for data classes, where N-th function extracts a value of the property initialized from N-th constructor parameter.</p>
</div>
<div class="paragraph">
<p>TODO: Components of type Nothing and control flow.</p>
</div>
</div>
<div class="sect2">
<h3 id="_local_function_declaration">16.7. Local Function Declaration</h3>
<div class="paragraph">
<p>Evaluation of a local function declaration has no effect at run-time.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_local_type_declaration">16.8. Local Type Declaration</h3>
<div class="paragraph">
<p>A local type declaration can be a class declaration or an interface declaration. Evaluation of a local class of interface declaration does nothing.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_assignment">16.9. Simple Assignment</h3>
<div class="paragraph">
<p><em>[Note:</em> An assignment is a statement. It produces no value and cannot be used as an expression. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>TODO: Assignment targets: a variable, property, field, array element. Evaluation of assignment.
Multi-component assignment is not supported, only multi-component initialization.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compound_assignment">16.10. Compound Assignment</h3>
<div class="paragraph">
<p>TODO: Evaluation of assignment.</p>
</div>
</div>
<div class="sect2">
<h3 id="_for_loop">16.11. for Loop</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_multi_declarations_in_for_loop">16.11.1. Multi-Declarations in for Loop</h4>
<div class="paragraph">
<p>TODO: <code>for((key, value) in map)</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_while_loop">16.12. while Loop</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_literals">16.13. Literals</h3>
<div class="paragraph">
<p>TODO: <code>true</code>, <code>false</code>, <code>null</code>, integers (dec, hex), floating-point, strings, chars.</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_names">16.14. Simple Names</h3>
<div class="paragraph">
<p>A simple name consists of a single identifier. A simple name resolution can be in general described as follows. Each function body, anonymous function body, accessor body, type body, or file represents a scope. Names imported by <code>import</code> directives are placed into several special scopes called "import scopes" that effectively enclose the file scope:</p>
</div>
<div class="paragraph">
<p>TODO: describe precedence of import directives and what exactly scopes are created.</p>
</div>
<div class="paragraph">
<p>Scopes can be nested. For each two different scopes M and N in the same file (including <code>import</code> scopes), there are exactly 3 possibilities: A is nested within B, B is nested within A, or scopes A and B are disjoint.  For each occurrence of a simple name in a file there a hierarchy of nested enclosing scopes, viewed from innermost to outermost. To determine meaning of a simple name, scopes are searched from innermost to outermost, performing a name lookup with a given name in each scope. Once a match is found, the process stops and returns the match as a result. If the result turns out to be not valid in the current context for some reason, the process does not resume. At each step, corresponding to a type body, an additional step is inserted after it, looking for a matching symbol in the type&#8217;s companion object, if any.</p>
</div>
</div>
<div class="sect2">
<h3 id="_invocation_expressions">16.15. Invocation Expressions</h3>
<div class="paragraph">
<p>Invocation expressions has a form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>       PrimaryExpression ( ArgumentList )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The PrimaryExpression must either be bound to a method group, or to a value that supports an invocation operation (e.g. a value of a functional type). Type-arguments can only be provided if the primary expression is a method group containing a generic method. To create an instance of a class, we call the constructor as if it were a regular function. Named arguments. Named argument to a functional type invocation.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_this_expression">16.16. <code>this</code> Expression</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_super_access">16.17. <code>super</code> Access</h3>
<div class="paragraph">
<p>Super-access is a value of the delegate object if it mentions an interface implemented via delegation. It cannot be used as a target of an assignment. In all other cases it can only be used at the left hand side of member access (dot operator).</p>
</div>
<div class="paragraph">
<p>There are no super expressions corresponding to this expressions introduced by extension functions or extension anonymous functions.</p>
</div>
<div class="paragraph">
<p>Super access cannot be used to access an extension.</p>
</div>
<div class="paragraph">
<p>TODO: Describe expressions of the form <code>super&lt;A&gt;@B</code>, where <code>B</code> is a containing class such that <code>this@B</code> is available, and <code>A</code> is a supertype of <code>B</code> (where it type-arguments may be omitted).</p>
</div>
<div class="paragraph">
<p>A super-access without an explicit supertype name can be used only if the current type inherits exactly one non-abstract member with the given name (TODO: method overloading?)</p>
</div>
</div>
<div class="sect2">
<h3 id="_class_expressions">16.18. <code>class</code> Expressions</h3>
<div class="paragraph">
<p><code>T::class</code></p>
</div>
<div class="paragraph">
<p>Cannot be used on type-parameters. No type-arguments can be provided even if the type <code>T</code> is generic (except for the <code>Array&lt;T&gt;</code> type, for which a type-argument must be provided, in/out projections in the argument are ignored). <code>T</code> cannot syntactically be a functional type. <code>dynamic::class</code> is not supported. The type of the <code>T::class</code> expression is <code>KClass&lt;T&gt;</code>. <code>(T)::class</code> is not supported (BUG?). <code>java.lang.Object::class</code> is equivalent to <code>kotlin.Any::class</code>. <code>java.lang.Void::class</code> is equivalent to <code>kotlin.Nothing::class</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_callable_references">16.19. Callable References</h3>
<div class="paragraph">
<p>Callable references to local variables and parameters are not supported.</p>
</div>
<div class="paragraph">
<p>TODO: Member, non-member</p>
</div>
</div>
<div class="sect2">
<h3 id="_operator_expressions">16.20. Operator Expressions</h3>
<div class="paragraph">
<p>There are several unary and binary operators in Kotlin. Unary operators are translated into method invocations on their operand. Binary operators are translated into method invocations on their left operand passing the right operand as the single argument to the invocation. Every operator has a method name associated with it (compound assignment operators can be translated in several possible ways). Overload resolution for translated invocations is performed according the regular rules, except that only those candidates are considered that are declared in Java, or declared with <code>operator</code> modifier in Kotlin.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Unary operators</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Expression | Translated to |
|------------|---------------|
| `+a` | `a.plus()` |
| `-a` | `a.minus()` |
| `!a` | `a.not()` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>This table says that when the compiler processes, for example, an expression <code>+a</code>, it performs the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Determines the type of <code>a</code>, let it be <code>T</code>.</p>
</li>
<li>
<p>Looks up a function <code>plus()</code> with no parameters for the receiver <code>T</code>, i.e. a member function or an extension function.</p>
</li>
<li>
<p>If the function is absent or ambiguous, it is a compilation error.</p>
</li>
<li>
<p>If the function is present and its return type is <code>R</code>, the expression <code>+a</code> has type <code>R</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Expression | Translated to |
|------------|---------------|
| `a++` | `a.inc()` + see below |
| `a--` | `a.dec()` + see below |</code></pre>
</div>
</div>
<div class="paragraph">
<p>These operations are supposed to change their receiver and (optionally) return a value.</p>
</div>
<div class="paragraph">
<p><code>inc()/dec()</code> should not mutate the receiver object. By "changing the receiver" we mean <em>the receiver-variable</em>, not the receiver object.</p>
</div>
<div class="paragraph">
<p>The compiler performs the following steps for resolution of an operator in the <strong>postfix</strong> form, e.g. <code>a++</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Determines the type of <code>a</code>, let it be <code>T</code>.</p>
</li>
<li>
<p>Looks up a function <code>inc()</code> with no parameters, applicable to the receiver of type <code>T</code>.</p>
</li>
<li>
<p>If the function returns a type <code>R</code>, then it must be a subtype of <code>T</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The effect of computing the expression is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Store the initial value of <code>a</code> to a temporary storage <code>a0</code>,</p>
</li>
<li>
<p>Assign the result of <code>a.inc()</code> to <code>a</code>,</p>
</li>
<li>
<p>Return <code>a0</code> as a result of the expression.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For <code>a--</code> the steps are completely analogous.</p>
</div>
<div class="paragraph">
<p>For the <strong>prefix</strong> forms <code>++a</code> and <code>--a</code> resolution works the same way, and the effect is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Assign the result of <code>a.inc()</code> to <code>a</code>,</p>
</li>
<li>
<p>Return the new value of <code>a</code> as a result of the expression.</p>
</li>
<li>
<p>Binary operations</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Expression | Translated to |
| -----------|-------------- |
| `a + b` | `a.plus(b)` |
| `a - b` | `a.minus(b)` |
| `a * b` | `a.times(b)` |
| `a / b` | `a.div(b)` |
| `a % b` | `a.mod(b)` |
| `a..b ` | `a.rangeTo(b)` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the operations in this table, the compiler resolves the expression in the <strong>Translated to</strong> column.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Expression | Translated to |
| -----------|-------------- |
| `a in b` | `b.contains(a)` |
| `a !in b` | `!b.contains(a)` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <code>in</code> and <code>!in</code> the procedure is the same, but the order of arguments is reversed. (TODO: Order of evaluation?)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Expression | Translated to |
|------------|---------------|
| `a == b` | `a?.equals(b) ?: b.identityEquals(null)` |
| `a != b` | `!(a?.equals(b) ?: b.identityEquals(null))` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>The operators <code>===</code> and <code>!==</code> (identity checks) are not overloadable, so no conventions exist for them</p>
</div>
<div class="paragraph">
<p>The <code>==</code> operation is special in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is translated to a complex expression that screens for <code>null`s, and `null == null</code> is <code>true</code>.</p>
</li>
<li>
<p>It looks up a function with a specific <em>signature</em>, not just a specific <em>name</em>. The function must be declared as</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun equals(other: Any?): Boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or an extension function with the same parameter list and return type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Symbol | Translated to |
|--------|---------------|
| `a &gt; b`  | `a.compareTo(b) &gt; 0` |
| `a &lt; b`  | `a.compareTo(b) &lt; 0` |
| `a &gt;= b` | `a.compareTo(b) &gt;= 0` |
| `a &lt;= b` | `a.compareTo(b) &lt;= 0` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>All comparisons are translated into calls to <code>compareTo</code>, that is required to return <code>Int</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Indexing and invocations</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Symbol | Translated to |
| -------|-------------- |
| `a[i]`  | `a.get(i)` |
| `a[i, j]`  | `a.get(i, j)` |
| `a[i_1, ...,  i_n]`  | `a.get(i_1, ...,  i_n)` |
| `a[i] = b` | `a.set(i, b)` |
| `a[i, j] = b` | `a.set(i, j, b)` |
| `a[i_1, ...,  i_n] = b` | `a.set(i_1, ..., i_n, b)` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>Square brackets are translated to calls to <code>get</code> and <code>set</code> with appropriate numbers of arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Symbol | Translated to |
|--------|---------------|
| `a(i)`  | `a.invoke(i)` |
| `a(i, j)`  | `a.invoke(i, j)` |
| `a(i_1, ...,  i_n)`  | `a.invoke(i_1, ...,  i_n)` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parentheses are translated to calls to invoke with appropriate number of arguments.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Assignments</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| Expression | Translated to |
|------------|---------------|
| `a += b` | `a.plusAssign(b)` |
| `a -= b` | `a.minusAssign(b)` |
| `a *= b` | `a.timesAssign(b)` |
| `a /= b` | `a.divAssign(b)` |
| `a %= b` | `a.modAssign(b)` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the assignment operations, e.g. <code>a += b</code>, the compiler performs the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the function from the right column is available</p>
</li>
<li>
<p>If the left-hand side can be assigned to and the corresponding binary function (i.e. <code>plus()</code> for <code>plusAssign()</code>) is available, report error (ambiguity).</p>
</li>
<li>
<p>Make sure its return type is <code>Unit</code>, and report an error otherwise.</p>
</li>
<li>
<p>Generate code for <code>a.plusAssign(b)</code></p>
</li>
<li>
<p>Otherwise, try to generate code for <code>a = a + b</code> (this includes a type check: the type of <code>a + b</code> must be a subtype of <code>a</code>).</p>
</li>
<li>
<p>Discussion of the ambiguity rule</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We raise an error when both <code>plus()</code> and <code>plusAssign()</code> are available only if the left-hand side is assignable. Otherwise, the availability of <code>plus()</code> is irrelevant, because we know that <code>a = a + b</code> cannot compile. An important concern here is what happens when the left-hand side becomes assignable after the fact (e.g. the user changes <code>val</code> to <code>var</code> or provides a <code>set()</code> function for indexing convention): in this case, the previously correct call site may become incorrect, but not the other way around, which is safe, because former calls to <code>plusAssign()</code> cannot be silently turned into calls to <code>plus()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_range_expression">16.21. Range Expression</h3>
<div class="paragraph">
<p>TODO: Describe range expressions 1..10.</p>
</div>
</div>
<div class="sect2">
<h3 id="_return_expression">16.22. <code>return</code> Expression</h3>
<div class="paragraph">
<p>The type of the return expression is kotlin.Nothing.</p>
</div>
<div class="paragraph">
<p>TODO: return, non-local return, labelled return.</p>
</div>
</div>
<div class="sect2">
<h3 id="_throw_expression">16.23. <code>throw</code> Expression</h3>
<div class="paragraph">
<p>The type of the throw expression is kotlin.Nothing.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_is_is_operators">16.24. <code>is</code>, <code>!is</code> Operators</h3>
<div class="paragraph">
<p>The is operator checks if an expression is an instance of a type. If an immutable local variable or property is checked for a specific type, there is no need to cast it explicitly, see §Smart-cast for exact details.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_in_in_operators">16.25. <code>in</code>, <code>!in</code> Operators</h3>
<div class="paragraph">
<p>TODO: Usage with range expressions, with collections.</p>
</div>
<div class="paragraph">
<p>BUG: Order of evaluation of operands is reversed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_as_as_expressions">16.26. <code>as</code>, <code>as?</code> Expressions</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_member_access_operator">16.27. Member Access Operator</h3>
<div class="paragraph">
<p>TODO: with simple name right-hand side, and other expressions right-hand side</p>
</div>
</div>
<div class="sect2">
<h3 id="_safe_access_operator">16.28. Safe Access Operator <code>?.</code></h3>
<div class="paragraph">
<p>A package name cannot be followed with <code>?.</code>. A class name cannot be followed with <code>?.</code> and a nested class name.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_expression">16.29. Conditional Expression</h3>
<div class="paragraph">
<p>TODO: Describe if-else expression.</p>
</div>
<div class="paragraph">
<p>The condition in the conditional expression has the expected type <code>Boolean</code>. It means that the conditional expression must be assignable to the type <code>Boolean</code>, and in case the conditional expression is a generic function invocation that requires type inference, the type <code>Boolean</code> is used as the expected type in the type inference.</p>
</div>
</div>
<div class="sect2">
<h3 id="_when_expression">16.30. when Expression</h3>
<div class="paragraph">
<p><code>when</code> matches its argument against all branches consequently until some branch condition is satisfied. <code>when</code> can be used either as an expression or as a statement. If it is used as an expression, the value of the selected branch becomes the value of the overall expression. If it is used as a statement, the values of individual branches are ignored. Each branch can be a block, and its value is the value of the last expression in the block. The else branch is evaluated if none of the other branch conditions are satisfied. If <code>when</code> is used as an expression, the else branch is mandatory, unless the compiler can prove that all possible cases are covered with branch conditions. If many cases have to be handled in the same way, the branch conditions may be combined with a comma.</p>
</div>
<div class="paragraph">
<p>Two different syntactic kinds of <code>when</code> expressions exist:
* Governed-by-value <code>when</code> expression. In this case, the keyword <code>when</code> is immediately followed by a parenthesized <em>governing expression</em>, followed by a sequence of zero or more branches, enclosed in curly braces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>when(expr) {
	pattern_list_1 -&gt; branch_1
	pattern_list_2 -&gt; branch_2
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each branch is a <em>pattern list</em> followed by the <code>-&gt;</code> token, followed by a branch body. A branch body is an expression or block. A pattern list is either a sequence of one or more patterns separated by commas, or the <code>else</code> keyword. A <em>pattern</em> can be one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an expression</p>
</li>
<li>
<p>a type test (<code>is</code>, <code>!is</code>)</p>
</li>
<li>
<p>a range test (<code>in</code>, <code>!in</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TODO: Evaluation order</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Governed-by-conditions <code>when</code> expression. In this case, the keyword <code>when</code> is immediately followed by a sequence of zero or more branches, enclosed in curly braces:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>when(expr) {
	condition_list_1 -&gt; branch_1
	condition_list_2 -&gt; branch_2
	...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each branch is a <em>condition list</em> followed by the <code>-&gt;</code> token, followed by a branch body. A branch body is an expression or block. A condition list is either a sequence of one or more expressions separated by commas, or the <code>else</code> keyword. A governed-by-conditions <code>when</code> expression is evaluated as follows: all conditions in all condition branches are evaluated in order (top-to-bottom, left-to-right) until some condition evaluates to <code>true</code>. In this case evaluation of conditions stops, and the branch body in the corresponding branch is evaluated. If all conditions are evaluated to <code>false</code>, then the branch body following the <code>else</code> keyword is evaluated, if there is any. Otherwise, the evaluation of the <code>when</code> expression completes.</p>
</div>
<div class="paragraph">
<p>Every condition has the expected type <code>Boolean</code>. It means that the conditional expression must be assignable to the type <code>Boolean</code>, and in case the conditional expression is a generic function invocation that requires type inference, the type <code>Boolean</code> is used as the expected type in the type inference. (BUG: expected type in type inference is not yet implemented).</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_object_expressions">16.31. Object Expressions</h3>
<div class="paragraph">
<p>An object expression provides a way to declare an anonymous local class and instantiate it within an expression. An object expression can specify the direct superclass and superinterfaces of the declared class, and provide implementations of its members. The declared class does not have a name and is not denotable. Evaluation of an object creation expression involves invocation of the superclass constructor, evaluation of initialization blocks and property initializers within the expression, and returns the created instance. The created instance is also available as this within the expression. If an object expression has an immediately preceding label, then the created instance is also available as labelled this expression that refers to this label.</p>
</div>
<div class="paragraph">
<p>The declared class cannot be abstract and must override all inherited abstract members. The declaration of an anonymous class cannot have any modifiers.</p>
</div>
<div class="paragraph">
<p>A body of an anonymous object expression is mandatory (unlike other class and object declarations).</p>
</div>
<div class="paragraph">
<p>Otherwise, the body of an anonymous class is governed by the same rules as object declarations (see §?).`</p>
</div>
</div>
<div class="sect2">
<h3 id="_anonymous_functions_2">16.32. Anonymous Functions</h3>
<div class="sect3">
<h4 id="_general_23">16.32.1. General</h4>
<div class="paragraph">
<p>An anonymous function can have two different syntactic forms: a function expression, or a function literals. The difference is not purely syntactical&#8201;&#8212;&#8201;some constructs (e.g. return expressions) have different meaning within them.</p>
</div>
<div class="paragraph">
<p>TODO: Evaluation rules for anonymous functions. Body is not evaluated immediately. Rather, the whole expression produces a values of a functional type (§Functional Types), whose invocation results in evaluation of the body of the anonymous function. Captured variables, closure, exceptions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_function_expression">16.32.2. Function Expression</h4>
<div class="paragraph">
<p>A function expression looks very much like a regular function declaration, except that its name is omitted. (DEVIATION: The current compiler implementation allows to specify an optional name, but it has some unfortunate syntactic interactions with annotations and should be disallowed). It also cannot have a type-parameter list (although can use type-parameters that are already in scope). Its body can be either a block (§block) or the <code>=</code> token followed by an expression (return expressions are not allowed in function expressions with expression body). Because a function expression lacks a name, a direct recursive invocation is not possible (a workaround is either to convert the expression into a named local function, or to assign the expression into a named mutable variable). A function expression cannot have @inline annotation. If return type is not specified and the function has a block body, then the return type is assumed to be kotlin.Unit. If return type is not specified and the function has an expression body, then the type can be inferred from the expression.</p>
</div>
</div>
<div class="sect3">
<h4 id="_function_literal">16.32.3. Function Literal</h4>
<div class="paragraph">
<p>Similar to a block, parameters are optional, parameter types are optional, the default parameter is <code>it</code>, cannot use return statement to exit function literal.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_static_type_assertion_expression">16.33. Static Type Assertion Expression</h3>
<div class="paragraph">
<p>Deprecated. May cause parsing ambiguities between blocks and function literals.</p>
</div>
</div>
<div class="sect2">
<h3 id="_parenthesized_expression">16.34. Parenthesized Expression</h3>
<div class="paragraph">
<p>Parenthesized expression has the same value and classification as the expression inside parentheses. Its main use is to change default parsing or grouping of expressions. It is possible to assign a parenthesized variable or property. Parentheses do not change order of evaluation of operands, although they could change order of evaluation of operators by means of changing the shape of a parse tree.</p>
</div>
<div class="paragraph">
<p>Parentheses has an effect on parsing blocks vs. function literals.</p>
</div>
<div class="paragraph">
<p>A prefix <code>super&lt;T&gt;</code> cannot be parenthesized unless it denotes a delegate.</p>
</div>
<div class="paragraph">
<p>Every expression can be placed in a context where an atomic expression is required by enclosing it in parentheses (provided it has suitable classification and type). A method group cannot be parenthesized.</p>
</div>
</div>
<div class="sect2">
<h3 id="_invocation_expression">16.35. Invocation Expression</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="sect3">
<h4 id="_passing_argument_as_a_trailing_function_literal">16.35.1. Passing Argument as a Trailing Function Literal</h4>
<div class="paragraph">
<p>Empty argument list can be omitted in this case: <code>run { &#8230;&#8203; }</code></p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_implicit_invoke_method_invocations">16.35.2. Implicit invoke Method Invocations</h4>
<div class="paragraph">
<p><code>x.foo()</code> cannot be rewritten multiple times, e.g. to <code>x.foo.invoke.invoke()</code></p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_indexer_access_expression">16.36. Indexer Access Expression</h3>
<div class="paragraph">
<p>Translated to an invocation of the method <code>get</code>, or the method <code>set</code>, or both. Index expressions are evaluated only once, left-to-right. Empty index list is not supported. Named indexes are not supported. Spread operator is supported (TODO: implement). Passing trailing lambda as the last parameter is not supported.</p>
</div>
<div class="paragraph">
<p>TODO: Do we support further rewriting of <code>x.get(&#8230;&#8203;)</code> to <code>x.get.invoke(&#8230;&#8203;)</code>?</p>
</div>
</div>
<div class="sect2">
<h3 id="_anonymous_object_creation_expressions">16.37. Anonymous Object Creation Expressions</h3>
<div class="paragraph">
<p>May specify no base class (<code>object { &#8230;&#8203; }</code>), may specify a base class (with a constructor invocation) and zero or more interfaces (<code>object : Base(&#8230;&#8203;), I1, I2 { &#8230;&#8203; }</code>). Anonymous class cannot introduce its own type-parameters, but can use type-parameters that are in scope. Every expression declares a distinct anonymous class&#8201;&#8212;&#8201;even if two expressions are textually and semantically identical, their anonymous classes are unrelated. May not contain constructor declarations, but may contain initialization blocks. May not contain a companion object declaration. May contain nested class declarations, but they must be inner classes. May not contain nested interface declarations. Anonymous classes have access to current instances of their enclosing classes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_try_expressions">16.38. try Expressions</h3>
<div class="paragraph">
<p>An exception type in a catch clause cannot be a type-parameter (TODO: Implement). An exception type in a catch clause cannot be a nullable type. An exception type in a catch clause cannot be the type <code>Nothing</code>.</p>
</div>
<div class="paragraph">
<p>No initializer is allowed for a catch variable. A catch variable is considered initially assigned. A catch variable must have an explicit type that must be the type <code>Throwable</code> or subtype thereof.</p>
</div>
<div class="paragraph">
<p>TODO: try-catch+, try-catch*-finally.</p>
</div>
</div>
<div class="sect2">
<h3 id="_order_of_evaluation">16.39. Order of Evaluation</h3>
<div class="paragraph">
<p>Generally, the order of evaluation is left to right, non-lazy (eager). Some expressions have special rules for order of evaluation of their constituent parts (some of them may be not evaluated at all). Order of evaluation of named arguments corresponds to their order at the invocation site, not the declaration site.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_name_and_overload_resolution">17. Name and Overload Resolution</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_24">17.1. General</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_simple_names_2">17.2. Simple Names</h3>
<div class="paragraph">
<p>A simple name is a single identifier. Its meaning depends on what symbol with that name are in scope. If only on symbols with that name is in scope, then the simple name refers to it. If there are multiple symbols with this name are in scope, then, informally, the symbol whose declaration is "closest" to the occurrence of the simple name is selected. For more precise rules, see TODO</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_qualified_names">17.3. Qualified Names</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p>Resolution of qualified names always proceeds from left to right, and the meaning of an identifier to the left is always fixed before an identifier to the right starts to being resolved. There is backtracking in this process. [Example: When meaning of the qualified name A.B is resolved, the identifier A may initially have several possible candidates, but exactly one of them is selected according to the rules in this specification. Then an attempt to resolve the identifier B after the dot happens. In case a member with this name cannot be found within A (with already fixed meaning), the compiler does not resume resolution process of the identifier A to find another candidate that initially had less priority, although in principle, it may have a member named B. End Example]</p>
</div>
</div>
<div class="sect2">
<h3 id="_name_lookup">17.4. Name Lookup</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_argument_lists">17.5. Argument Lists</h3>
<div class="paragraph">
<p>An argument list for an invocation is the sequence of zero or more arguments, separated by commas. The argument list itself is enclosed in parentheses. An argument can be one of the following kinds:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A positional argument (an expression),</p>
</li>
<li>
<p>A named argument (an identifier, followed by the <code>=</code> token, followed by an expression),</p>
</li>
<li>
<p>A positional spread argument (the <code>*</code> token, followed by an expression),</p>
</li>
<li>
<p>A named spread argument (an identifier, followed by the <code>=</code> token, followed by the <code>*</code> token, followed by an expression).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>[Note:</em> Sometimes the <code><strong></code> token in spread arguments is called the spread operator in an informal description of the Kotlin language. But this word usage is only informal, and <code></strong></code> is not a unary prefix operator in the usual sense (as used throughout this specification). It can only appear in spread arguments, as specified by their grammar, and cannot be used in other places where usual operators can be used. For example, the purported invocation expression with a parenthesized spread operator <code>f(x = (<strong>y))</code> is syntactically ill-formed. On the other hand, the invocation expression <code>f(*z is IntArray)</code> is syntactically well-formed and can be well-typed, but it is equivalent to <code>f(</strong>(z as IntArray))</code>. Note that if <code>*</code> were thought of as a unary prefix operator, it would have an unusually low precedence in this context. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>TODO: restrictions on order of arguments.</p>
</div>
</div>
<div class="sect2">
<h3 id="_positional_arguments">17.6. Positional Arguments</h3>
<div class="paragraph">
<p>A positional argument is just an expression.
TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_named_arguments">17.7. Named Arguments</h3>
<div class="paragraph">
<p>A named argument is an identifier, indicating the corresponding parameter name, followed by the token <code>=</code>, followed by an expression. <em>[Note:</em> So, a named argument is syntactically similar to an assignment statement with a simple name of the left-hand side. <em>End Note]</em> The name in a named argument shall correspond to one of the names of the parameters of a function being invoked. <em>[Note:</em> The overload resolution mechanism guarantees that functions without such parameter are not considered applicable in this invocation. <em>End Note]</em>. A named argument cannot follow a positional argument in an argument list.</p>
</div>
<div class="paragraph">
<p>Names of all named arguments in the same argument list shall be pairwise distinct.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_default_parameter_values">17.8. Default Parameter Values</h3>
<div class="paragraph">
<p>A function declaration can optionally provide default values for some or all its parameters. A default value cannot be provided for the receiver parameter in an extension function. A default value is an expression (TODO: its evaluation context, available parameters) specified after the token <code>=</code> following the parameter type.</p>
</div>
<div class="paragraph">
<p><em>[Example:</em> TODO <em>End Example]</em></p>
</div>
<div class="paragraph">
<p>A default value for a parameter has no effect in an invocation were an actual argument was provided for that parameter. For a parameter that has no corresponding actual argument, its default value is used instead of the missing argument. (TODO: order of evaluation).</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_vararg_invocations">17.9. vararg Invocations</h3>
<div class="paragraph">
<p>At most one parameter in a function declaration can have the <code>vararg</code> modifier. This modifier indicates that a variable number (zero, one or more) of arguments corresponding to this parameter can be provided in a function invocation, as in more detail is described below. The type of the parameter annotated with the <code>vararg</code> modifier is different from the type specified in its declaration&#8201;&#8212;&#8201;the type of the parameter is an array type, whose element type is taken to be the type specified in the declaration. More precisely, if the specified type is one of the primitive types, then the corresponding primitive array type is used as shown in the following table:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Boolean</code>&#8201;&#8212;&#8201;<code>BooleanArray</code></p>
</li>
<li>
<p><code>Byte</code>&#8201;&#8212;&#8201;<code>ByteArray</code></p>
</li>
<li>
<p><code>Short</code>&#8201;&#8212;&#8201;<code>ShortArray</code></p>
</li>
<li>
<p><code>Int</code>&#8201;&#8212;&#8201;<code>IntArray</code></p>
</li>
<li>
<p><code>Long</code>&#8201;&#8212;&#8201;<code>LongArray</code></p>
</li>
<li>
<p><code>Char</code>&#8201;&#8212;&#8201;<code>CharArray</code></p>
</li>
<li>
<p><code>Float</code>&#8201;&#8212;&#8201;<code>FloatArray</code></p>
</li>
<li>
<p><code>Double</code>&#8201;&#8212;&#8201;<code>DoubleArray</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Otherwise, if the specified type is the special type <code>Nothing</code> or the corresponding nullable type <code>Nothing?</code>, then a compile-time error occurs.</p>
</div>
<div class="paragraph">
<p>Otherwise, let the specified type be some type <code>T</code>. In this case the type of the parameter is the projection type <code>Array&lt;out T&gt;</code>.</p>
</div>
<div class="paragraph">
<p>TODO: Consider cases when <code>T</code> is a type-parameter (possibly, bounded) as is substituted with primitive types, or special types <code>Nothing</code> or <code>Nothing?</code>.</p>
</div>
<div class="paragraph">
<p>Arguments provided to a <code>vararg</code> parameter shall be either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a single named argument whose name matches the name of the vararg parameter, or</p>
</li>
<li>
<p>a (possibly empty) sequence of positional arguments or spread arguments intermixed in any order.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Arguments provided to a <code>vararg</code> parameter are consolidated into a single array instance (TODO: of type &#8230;&#8203;). In particular:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If no arguments are passed, then an empty array is created and used as the parameter value;</p>
</li>
<li>
<p>If a named argument or exactly one positional argument is provided, then a singleton array is created, whose only element is the argument provided, and this array is used as the parameter value;</p>
</li>
<li>
<p>If one spread argument <code>*a</code> (where <code>a</code> can be any expression) is provided, then the type of <code>a</code> shall be the same as the type of the parameter (or a subtype thereof)&#8201;&#8212;&#8201;in which case a copy of the array <code>a</code> is created and is used as the parameter value (copying of the array can be elided by the compiler or runtime environment if this would not have any observable effects); TODO: define "observable effects" (excludes performance and memory consumption, and any effects depending on them explicitly or through race conditions or asynchronous exceptions).</p>
</li>
<li>
<p>If multiple spread arguments <code>*ai</code> provided, then the type of every <code>ai</code> be the same as the type of the parameter (or a subtype thereof)&#8201;&#8212;&#8201;in which case a new array instance of the length equal to the sum of lengths of all arrays in spread arguments is created, whose content is a concatenation of contents of all arrays in spread arguments, in the same order as the arguments are specified in source; [Note: The creation of the array could fail with an exception if its lengths exceeds the maximum array length supported by the platform, or because of insufficient memory available to allocate the array. End Note]</p>
</li>
<li>
<p>In a general case, a mixture of positional and spread arguments can be given in any order&#8201;&#8212;&#8201;in which case the effective behavior is as if every positional argument is replaced with a spread argument with a singleton array whose only element is that positional argument, and then the spread arguments are processed as specified in the previous bullet.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>[Note:</em> If the specified type of a <code>vararg</code> parameter is a primitive type (say, <code>Int</code>, so the actual type of the parameter is <code>IntArray</code>) and a spread argument <code>*a</code> is provided for that parameter, then the type of <code>a</code> shall be the corresponding primitive array type (<code>IntArray</code> in this case), and not the generic <code>Array&lt;T&gt;</code> class instantiated with the primitive type (<code>Array&lt;Int&gt;</code> in this case). CONSIDER: relax this requirement. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>If a generic class or interface with a type-parameter <code>T</code> (and, possibly, other type-parameters) declares a method whose parameter list has a <code>vararg</code> parameter whose specified type is <code>T</code>, then it is not possible to override that method in an instantiation of that generic class or interface where <code>T</code> is instantiated with a primitive type. <em>[Rationale:</em> Suppose the primitive type used as the type-argument is <code>Int</code>. The type of the parameter in the original declaration is <code>Array&lt;T&gt;</code>, and its type in the generic instantiation is <code>Array&lt;Int&gt;</code>. In a purported override the corresponding parameter would be declared as <code>vararg x : Int</code>, then would result in the <code>IntArray</code> type, not matching the type <code>Array&lt;Int&gt;</code> in the method being overridden. <em>End Rationale]</em></p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_matching_arguments_with_parameters">17.10. Matching Arguments with Parameters</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_candidate_method_search">17.11. Candidate Method Search</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_potential_applicability">17.12. Potential Applicability</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_actual_applicability">17.13. Actual Applicability</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_overload_resolution">17.14. Overload Resolution</h3>
<div class="sect3">
<h4 id="_general_25">17.14.1. General</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_better_conversion">17.14.2. Better Conversion</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_better_candidate">17.14.3. Better Candidate</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect3">
<h4 id="_best_candidate">17.14.4. Best Candidate</h4>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_type_inference_2">17.15. Type Inference</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p>Expression Typing Facade
Computes a type for an expression.</p>
</div>
<div class="paragraph">
<p>Input:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>expression</p>
</li>
<li>
<p>context (ExpressionTypingContext)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TypeInfo for the expression</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Code: ExpressionTypingFacade.getTypeInfo()</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Type Info</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For each expression we collect type info, that means "what type does this expression have independently of context". By context dependency we call the dependency of the expected type for this expression. After the expected type for the expression becomes known, we complete analysis of the expression according to it.</p>
</div>
<div class="paragraph">
<p>[Example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun emptyList&lt;E&gt;(): List&lt;E&gt;
val list: List&lt;Int&gt; = emptyList()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the type of the expression emptyList() is List&lt;Int&gt;, but we know it because we declared it explicitly as a type of a variable (and therefore it became an expected type for the expression). If we examine this expression independently of context, it will have the type info List&lt;E&gt; where E is unknown.</p>
</div>
<div class="paragraph">
<p>Another example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun listOf&lt;E&gt;(vararg elements: E): List&lt;E&gt;
val list: List&lt;Int&gt; = listOf(1, "a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Type info of the expression listOf(1, "a") is List&lt;E&gt; where there are constraints on type E derived from actual arguments (1, "a"):
- E is a supertype of Int
- E is a supertype of String</p>
</div>
<div class="paragraph">
<p>But if we consider this expression in its context with expected type List&lt;Int&gt;, it occurred to be not typeable, because expected type adds a constraint
E is a subtype of Int that makes the constraints incompatible.
End Example]</p>
</div>
<div class="paragraph">
<p>TypeInfo for an expression is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>type that might have unknown yet type-arguments (T1&#8230;&#8203;Tn);</p>
</li>
<li>
<p>data flow info;</p>
</li>
<li>
<p>constraint system that imposes constraints on type-arguments (T1&#8230;&#8203;Tn) as well as some other variables; system might be empty.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Code: JetTypeInfo
Todo: now a constraint system corresponds to the resolved call, not to the expression.</p>
</div>
<div class="paragraph">
<p>Call Resolver</p>
</div>
<div class="paragraph">
<p>Input:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>call r.foo(a1&#8230;&#8203;an, fl1&#8230;&#8203;flm)</p>
</li>
<li>
<p>where fl1&#8230;&#8203; flm are function literal arguments;</p>
</li>
<li>
<p>context (ResolutionContext) including context dependency flag (DEPENDENT/INDEPENDENT)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>typeInfo</p>
</li>
<li>
<p>where constraint system is solved and type is known for INDEPENDENT mode</p>
</li>
<li>
<p>resolution results</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Code: CallResolver.doResolveCall()</p>
</div>
<div class="paragraph">
<p>The process of the call resolution should go in the following steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Resolve receiver and arguments type infos.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Analyze receiver and arguments in DEPENDENT mode:
r → typeInfo
ai → typeInfo</p>
</div>
<div class="paragraph">
<p>Analyze explicitly-typed function literal arguments (and their bodies). For implicitly-typed function literal argument we will be satisfied with its shape.
A shape of the function literal argument is:
- a type if it is explicitly-typed,
- a special placeholder indicating it is a function type and containing value parameter types and the number of the parameters (if they are explicitly specified) for implicitly-typed function literal.
For implicitly-typed function literal { (x, y) &#8594; x + y } a shape is (???, ???) → ???. Here ??? means "unknown type".</p>
</div>
<div class="ulist">
<ul>
<li>
<p>build and prioritize tasks / candidates (see Task Prioritizer)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Input:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>receiver type info</p>
</li>
<li>
<p>function name</p>
</li>
<li>
<p>context</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>resolution task (actually OrderedMultiTask)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The candidates are grouped and inside each group they can be ordered and unordered. The following interfaces describe this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface ResolutionTask {
 fun getStatus(): ResolutionStatus
 fun getResultingCall(): ResolvedCall?
}

interface SingleCandidateTask : ResolutionTask {
 val candidate: ResolutionCandidate
 val resolvedCall: ResolvedCall
}

interface OrderedMultiTask : ResolutionTask {
 val tasks: Iterable&lt;ResolutionTask&gt;
}

interface UnorderedMultiTask : ResolutionTask {
 val tasks: Set&lt;ResolutionTask&gt;
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Analyze tasks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All candidates that are stored in a task and its subtasks are resolved (by Resolve candidate function). Tasks should be built and analyzed lazily.
The SingleCandidateTask is successful if the candidate is successful.
The OrderedMultiTask is successful if it contains a successful task. The resulting candidate is the one of the first successful task.
The UnorderedMultiTask is successful if it contains successful tasks (not all of them must be successful) and there is a maximally specific one among their candidates.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Resolve (try) each candidate (see Resolve candidate)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Input:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>arguments and receiver type infos</p>
</li>
<li>
<p>shape of each function literal argument</p>
</li>
<li>
<p>resolution candidate</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>status</p>
</li>
<li>
<p>typeInfo</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Candidate resolution consists of two steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>map arguments to parameters (see Value Arguments to Parameters mapping);</p>
</li>
<li>
<p>check that constraint system built on assumptions "argument is a subtype of a formal parameter type" is not failure.</p>
</li>
<li>
<p>Resolve overloading conflicts (find the most specific candidate)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Input: the first task with successful candidates
Output: a candidate or an error</p>
</div>
<div class="paragraph">
<p>See Choosing the most specific candidate.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Complete resolution if the mode is INDEPENDENT (see Solve constraint system)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Input:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>typeInfo where</p>
</li>
<li>
<p>constraint system is non-trivial</p>
</li>
<li>
<p>all nested implicitly-typed function literal arguments were not analyzed</p>
</li>
<li>
<p>expected type</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>substitution for all type variables in the constraint system</p>
</li>
<li>
<p>analyzed bodies of implicitly-typed function literal arguments</p>
</li>
<li>
<p>result type of the expression</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Resolution Candidate</p>
</div>
<div class="paragraph">
<p>Sometimes function foo requires more than one receiver to be correctly resolved:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class A {
 fun B.foo() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In such cases when we resolve it two receivers should be available in the context. In the following example there are an explicit receiver b and an implicit receiver this of the type A:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun A.test1(b: B) {
 b.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One more example with two implicit receivers of types A and B:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun test2(a: A, b: B) {
  with (a) {
    with (b) {
      foo()
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will name a receiver that function is an extension to as extension receiver (B in the first example) and a receiver that function is a member of as dispatch receiver (A in the example).</p>
</div>
<div class="paragraph">
<p>Let us introduce the following notation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  dispatch receiver
 --------------------.foo
  extension receiver</code></pre>
</div>
</div>
<div class="paragraph">
<p>to denote the dispatch receiver and the extension receiver for concrete function invocation of foo.
In this notation foo denotes function descriptor.</p>
</div>
<div class="paragraph">
<p>For our examples it is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  this
 ------.foo
    b</code></pre>
</div>
</div>
<div class="paragraph">
<p>for invocation in test1 and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  a
 ---.foo
  b</code></pre>
</div>
</div>
<div class="paragraph">
<p>for invocation in test2.</p>
</div>
<div class="paragraph">
<p>Actually, for second example it is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  this@A
 ---------.foo
  this@B</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>this@A</code>, <code>this@B</code>&#8201;&#8212;&#8201;implicit extension receivers for corresponding function literals, but for simplicity we will sometimes write a, b.
We write dash symbol to indicate the absence of dispatch receiver or extension receiver.
For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  a
 ---.foo
  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>describes an invocation a.foo where a has type A and foo is a member of A:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class A { fun foo() {} }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  -
 ---.foo
  a</code></pre>
</div>
</div>
<div class="paragraph">
<p>describes an invocation a.foo where foo is declared as extension function to A:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class A
fun A.foo() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To shorten notation in complicated cases, let us denote a</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  a
 ---.foo
  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>as <code>a.foo^m</code> and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>  -
 ---.foo
  a</code></pre>
</div>
</div>
<div class="paragraph">
<p>as <code>a.foo^e</code>.</p>
</div>
<div class="paragraph">
<p>So Resolution Candidate is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>function descriptor</p>
</li>
<li>
<p>dispatch receiver</p>
</li>
<li>
<p>extension receiver</p>
</li>
<li>
<p>Task Prioritizer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To be able to resolve <code>invoke</code> convention simultaneously with the usual invocation we have to resolve properties beforehand. Because <code>invoke</code> in invocation <code>r.foo()</code> can be extension to <code>R</code> or extension to (or member of) <code>Foo</code>, we should resolve two properties: with explicit receiver <code>r</code> and without. We will denote them as <code>r.foo</code> and <code>foo</code>. The expression <code>r.foo</code> can indicate a class object (or object) as well.</p>
</div>
<div class="paragraph">
<p>Input:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>invocation <code>r.foo(args){fl}</code> where</p>
</li>
<li>
<p><code>foo</code> is the name of the function by which all possible candidates will be found;</p>
</li>
<li>
<p>receiver <code>r</code> denotes any kind of expression and has the type <code>R&lt;T1&#8230;&#8203;Tn&gt;</code> (some of <code>Ti</code> may be unknown yet) or may be absent;</p>
</li>
<li>
<p><code>args</code> are value arguments (including function literal arguments that are invoked as usual, without convention), <code>fl</code>&#8201;&#8212;&#8201;the function literal argument (if any) that is invoked with special syntax.</p>
</li>
<li>
<p>implicits - all implicit receivers that are available in the context.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Output:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>prioritized resolution candidates for foo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The candidates for the simple invocation r.foo(x) with the explicit receiver r and the argument list x should be built by the following scheme:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Members. Will be denoted as r.foo^m</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>( x) :
r
 -
. foo(x)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Extensions. Will be denoted as r.foo^e</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>( x) :
implicits ∪ { - }
r
. foo(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which means</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>for (implicit in implicits) {
 add
implicit
r
. foo(x)
}
add -
r
. foo(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The extension candidates should be prioritized by implicit receiver. The union of members and extensions will be denoted simply as <code>r.foo*
( x)</code>. Note that all members and extensions are found with respect to available smart cast types of receiver <code>r</code>. The candidates within one group but found from different smart cast types have the same priority. It might turn out later there is the most specific candidate, so several candidates do not mean ambiguity at once. The call <code>r.foo(args){fl}</code> might contain implicit <code>invoke</code> invocations. Note that <code>invoke</code> members have more priority than <code>foo</code> extensions, which means the candidates for <code>invoke</code> calls should be built together with the usual ones.</p>
</div>
<div class="paragraph">
<p>[Note. (from the discussion 28.01.15)
If the receiver type is unknown yet (<code>T</code> where there are some constrains on <code>T</code>), it should be completed immediately. We do not want to collect all possible extension functions.
End Note]</p>
</div>
<div class="paragraph">
<p>If only type-parameters are unknown in the receiver type (e.g. <code>List&lt;T&gt;</code>), the candidates might be found for incomplete type, it is important for the Immutable map builder case support).</p>
</div>
<div class="paragraph">
<p>One should be very careful collecting all possible extensions of <code>List&lt;T&gt;</code>. On the one hand, all <code>T</code> substitutions should be considered (both extensions to <code>List&lt;String&gt;</code> and <code>List&lt;Int&gt;</code> may apply). On the other hand, some candidates might be thrown away using the current <code>T</code> substitution. (Say, if <code>T</code> is a subtype of <code>Number</code>, extension to <code>List&lt;String&gt;</code> is definitely inappropriate).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The receiver <code>r</code> exists.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Add candidates for the explicit receiver:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add members matching by all arguments: <code>r.foo^m(args, fl)</code>.</p>
</li>
<li>
<p>Add members for invoke. The following cases have the same priority.
a) <code>invoke</code> is positioned after foo: <code>r.foo^m</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>.invoke^m(args , fl) .</code></pre>
</div>
</div>
<div class="paragraph">
<p>b) <code>invoke</code> is positioned before the last function literal argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>r.foo^m(args).invoke^m(fl) .</code></pre>
</div>
</div>
<div class="paragraph">
<p>c) Both invocations are made through <code>invoke</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>r.foo^m.invoke^m(args).invoke^m(fl).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that it is possible to find appropriate <code>invoke</code> candidates only when resolution of receiver call is completed. This means that the computation of the last <code>invoke(fl)</code> should be deferred.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add extensions (member extensions and pure extensions) matching by all arguments: <code>r.foo^e(args, fl)</code>.</p>
</li>
<li>
<p>Add extensions for <code>invoke</code>. The following groups of candidates have the same priority, but inside each group the candidates should be prioritized by an implicit receiver. The same logic applies as in item 2, but now both members and extensions are under consideration:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>a) <code>invoke</code> is positioned after foo: <code>r.foo*.invoke*(args , fl)</code>.
b) <code>invoke</code> is positioned before the last function literal argument: <code>r.foo*(args).invoke*(fl)</code>.
c) Both invocations are made through <code>invoke</code>: <code>r.foo*.invoke*(args).invoke*(fl)</code>.</p>
</div>
<div class="paragraph">
<p>The <code>invoke</code> function can be an extension to the explicit receiver <code>r</code> as well:</p>
</div>
<div class="paragraph">
<p>d) foo</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>r
.invoke(args , fl)</code></pre>
</div>
</div>
<div class="paragraph">
<p>e) foo</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>r
.invoke(args).invoke*
( fl)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the cases d and e <code>invoke</code> is a member extension, which means it is an extension to <code>R</code> declared in the class <code>Foo</code>. So <code>foo</code> is a dispatch receiver for such invocation, <code>r</code> is an extension receiver. The case 4 is illustrated with the examples below.</p>
</div>
<div class="paragraph">
<p>II. The receiver r does not exist.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>At first, we find all local declarations named <code>foo</code>:</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>add locals
That means functions -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code> -
. foo and properties foo
 -
.invoke and -
foo .invoke</code></pre>
</div>
</div>
<div class="paragraph">
<p>where the function or the property <code>foo</code> is declared locally.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We repeat the process defined in a stage I trying all implicit receivers that are available in our scope:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>for (implicit in implicits) {
 add_candidates_for_explicit_receiver (implicit)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That means we sequentially imply that <code>foo(&#8230;&#8203;)</code> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>this.foo(...)
this@A.foo(...)
this@B.foo(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>this</code>, <code>this@A</code>, <code>this@B</code> are implicit receivers. Thus we have candidates sorted by implicit receiver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>At last we consider the case when there is no explicit receiver and <code>foo</code> is declared not locally:
add non-locals. Which means the same as case 1 but the function or the property foo is declared not locally.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>[Note. (from the discussion 29.01.15)
The direct loop through implicit receivers takes square time, because for each implicit receiver (as candidate for dispatch receiver) we check all implicit receivers (as candidates for extension receiver). But actually we need to collect only all members named <code>foo</code> of implicit receivers. So some preliminary work might be done to simplify answering whether given implicit receiver have a potentially applicable member-extension function with given name or not.
End Note]</p>
</div>
<div class="paragraph">
<p>[Example</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The most non-trivial case is when there are extensions to invoke.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>r.foo
 -
.invoke</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface R
val R.foo: Foo
interface Foo {
 fun invoke()
}
fun test(r: R) {
 r.foo()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>implicits ∪ { - }
r.foo .invoke</code></pre>
</div>
</div>
<div class="paragraph">
<p>That consists of the cases:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>r.foo .invoke</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface Foo
interface R { val foo: Foo } //or property can be an extension
fun Foo.invoke() {}
fun test(r: R) {
 r.foo()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>implicit(b)
r.foo .invoke</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface Foo
interface R { val foo: Foo } //or property can be an extension
interface B {
 fun Foo.invoke()
 fun test(r: R) {
 r.foo()
 }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>foo
r
.invoke</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface R
interface Foo {
 fun R.invoke()
}
fun test(r: R, foo: Foo) {
 r.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The real example for the last case is <code>ExtensionFunction</code> interfaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>public interface ExtensionFunction0&lt;in T, out R&gt; {
 public fun T.invoke() : R
}
fun test(f: Int.()-&gt;Unit) {
 1.f()
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>More real examples.</p>
</li>
<li>
<p><code>String.plus</code> in html builders.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun foo() =
 html {
 head {
 title { +"Foo" }
 }
 }
fun html(init: HTML.() -&gt; Unit): HTML
abstract class Tag(val name: String) {
 fun String.plus() {
 }
}
class HTML() : Tag("html") {
 fun head(init: Head.() -&gt; Unit)
}
class Head() : Tag("head") {
 fun title(init: Title.() -&gt; Unit)
}

class Title() : Tag("title")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following candidates are built for the +"Foo" invocation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1. "Foo"
 -
fun plus(other: Any?): String defined in jet.String
2. this@title
 "Foo" fun String.plus(): Unit defined in Title
3. this@head
 "Foo" fun String.plus(): Unit defined in Head
4. this@html
 "Foo" fun String.plus(): Unit defined in HTML
5.
 -
"Foo"
fun String?.plus(Any?)
fun IntArray.plus(Int)
...
fun Array&lt;T&gt;.plus(T)
fun Array&lt;T&gt;.plus(Iterator&lt;T&gt;)
...
fun Iterable&lt;T&gt;.plus(T)
The first candidate is a member in a class String ( r
 -
. foo(x) ).</code></pre>
</div>
</div>
<div class="paragraph">
<p>The candidates 2-4 are member extensions sorted by implicit receivers</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>( implicits ∪ { - }
r
. foo (x) )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last candidates are extensions, most of which are incompatible by receiver type, but in the absence of more appropriate candidates the corresponding error will be generated. All 2-4 candidates are successful (appropriate), but the candidate list is sorted, and the result is the second one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>2. `invoke` vs. usual invocation
class A {
 fun bar(foo: (Int)-&gt;Int) {
 foo(42)
 }

 fun foo(p: Int) {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two candidates for the <code>foo(42)</code> invocation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1. -
-
 local val foo: (Int)-&gt;Int
&amp;
foo
 -
 fun invoke(Int) defined in Function1&lt;Int, Int&gt;
2. this
 -
 fun foo(Int) defined in A</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first candidate is successful, that means foo is resolved to the local variable.</p>
</div>
<div class="paragraph">
<p>Todo: Now <code>invoke</code> candidates are resolved a bit differently. In the proposed approach for <code>foo(42)</code> we have a bunch of candidates - functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ fun foo(Int), fun invoke(Int) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>But now we collect both functions and variables with the same name together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ fun foo(Int), val foo: Function&lt;Int, ...&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And for variables the corresponding <code>invoke</code> is resolved later in <code>CallTransformer</code>.</p>
</div>
<div class="paragraph">
<p>Code: TaskPrioritizer.computePrioritizedTasks.</p>
</div>
<div class="paragraph">
<p>Constraint system The most controversial idea of the proposing approach is that the constraint system should store references to implicitly-typed function literal arguments. They depend on unknown type variables and so cannot be analyzed at once, but can add some additional information after being analyzed.</p>
</div>
<div class="paragraph">
<p>The constraint system is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>map: type variable → type bounds;</p>
</li>
<li>
<p>type bounds consist of upper, lower and exact bounds on type variable; these bounds might equal to or contain other type variables;</p>
</li>
<li>
<p>references to implicitly-typed function literal arguments (knowing which type variables depend on function literal argument, and which function literal argument depend on);</p>
</li>
<li>
<p>information about errors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let us look at the example from the kotlin standard library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;E&gt; newHashSet(): HashSet&lt;E&gt;
fun &lt;T, C: MutableCollection&lt;T&gt;&gt;
 Iterable&lt;T&gt;.toCollection(result: C) : C
fun test(list: List&lt;Int&gt;) {
 list.toCollection(newHashSet())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constraint system for this example is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>type variables: E, T, C
type bounds: T → { lower bound: Int }
 C →
 { upper bound: MutableCollection&lt;T&gt;,
 lower bound: HashSet&lt;E&gt; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will see below how we are going to solve it. The following interface describes the operations that we want to do with the constraint system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface ConstraintSystem {
 fun registerTypeVariables(typeVariables)
 fun addSubtypeConstraint(constrainingTypeInfo, subjectType)
 fun addSupertypeConstraint(constrainingTypeInfo, subjectType)
 fun addFunctionLiteralArgument(fl)
 private fun addSimpleConstraint(Constraint)
 private fun addConstraintSystem(ConstraintSystem)
}
interface Constraint {
 val kind // SUBTYPE, SUPERTYPE or EQUAL
 val constrainingType
 val subjectType
}
interface VariableConstraint : Constraint {
 override val subjectType //is a type variable
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we register type variable, we add all upper bounds for it as constraints. When we add subtype or supertype constraint, we have to separately add <code>typeInfo.type</code> and <code>typeInfo.constraintSystem</code> to our system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>addSimpleConstraint(
 Constraint(kind, constrainingTypeInfo.type, subjectType)
addConstraintSystem(constrainingTypeInfo.constraintSystem)
fun addSimpleConstraint(Constraint)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we add a new simple constraint we reduce it. Reduction of the constraint includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>finding a common supertype of type constructors of subject type and constraining
type; it is an error if it is not found;</p>
</li>
<li>
<p>generating new constraints for corresponding type-arguments of subject type and
constraining type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Later we will need a function that in addition to generating new constraints takes a handler for processing every new one (that constraints a type variable, otherwise is can be reduced):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun reduceConstraint(c: Constraint,
 handler: (VariableConstraint)-&gt;Unit)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding a new <code>Constraint</code> may produce new type bounds for type variables. The process of updating the dependent type variables after generating constraints will be described below (see Constraint system incorporation).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun addConstraintSystem(ConstraintSystem)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we add the whole system, we add all data in it (type variables, type bounds and function literal arguments) to our system. The detail of implementation whether the reference to constraint system is stored or the data is copied is irrelevant here. The constraint for <code>constrainingTypeInfo.type</code> that we add before adding constraint system often ties together type variables from both systems (current and the one we
add).</p>
</div>
<div class="paragraph">
<p>Code: ConstraintSystem, ConstraintSystemImpl.</p>
</div>
<div class="paragraph">
<p>Todo: Now interdependence for type variables from different (outer and inner) calls is not supported.</p>
</div>
<div class="paragraph">
<p>Resolve candidate</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Input:

* invocation r.foo(a1
... an
, fl 1
... flm
)

* where fl1
... flm
 are function literal arguments;

* TypeInfo for receiver r ;
* TypeInfo for arguments a1
...an
 where all arguments were successfully mapped to
foo function's value parameters before;

* resolution candidate dispatch _ receiver
extension _ receiver
. foo (either dispatch_receiver, either
extension_receiver is r);

* dataFlowInfo that was obtained after analyzing arguments.
Output:

* status (SUCCESS or a specific error)
* TypeInfo for invocation (if success)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If in the invocation some type-parameters are specified, we consider a substituted function descriptor for foo instead. We build a constraint system that stores information about all unknown type-parameters
(of function <code>foo</code>, receiver and function arguments <code>a1</code>&#8230;&#8203;<code>an</code>). The following describes the constraints that are added to the system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val s = ConstraintSystem()
s.registerTypeVariables(foo.typeParameters)
s.addSubtypeConstraint(
 extension_receiver.typeInfo, foo.getExtensionReceiver.type)
s.addSubtypeConstraint(
 dispatch_receiver.typeInfo, foo.getDispatchReceiver.type)
for (arg_i in arguments) {
 s.addSubtypeConstraint(
 arg_i.typeInfo, foo.valueParameter_i.type)
}
for (fl in function_literal_arguments) {
 if (fl.isExplicitlyTyped)
 s.addSubtypeConstraint(
 fl.type, foo.valueParameter_for_fl.type)
 else
 s.addFunctionLiteralArgument(fl)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the constraint system is not incompatible (it will be discussed later), we return SUCCESS status and type info:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>TypeInfo(foo.getReturnType, dataFlowInfo, s)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Code: <code>CandidateResolver.performResolutionForCandidateCall()</code>.</p>
</div>
<div class="paragraph">
<p>Todo: Now function literals are not the part of the constraint system. Thus we cannot definitely say the right moment to analyze each literal (when all argument types are inferred), so we analyze some in <code>CandidateResolver.addConstraintForFunctionLiteral()</code> and complete analyzing all in <code>CallCompleter</code>.</p>
</div>
<div class="paragraph">
<p>Smart casts</p>
</div>
<div class="paragraph">
<p>If the receiver or the value argument has smart cast types, its type info is taken as the intersection of possible types. That means an intersection type may be added to the constraint system (which is a
non-denotable type). But as it may be added only as a lower bound, the result (the supertype of lower bounds) will always be denotable.</p>
</div>
<div class="paragraph">
<p>Code: <code>CandidateResolver.addConstraintForValueArgument()</code>;</p>
</div>
<div class="paragraph">
<p><code>updateResultTypeForSmartCasts()</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Value Arguments to Parameters mapping</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The complexity goes only when named arguments are mixed with positioned or some arguments with default values are omitted. The main rule is that positioned argument is always located at its position. Named
arguments that go before the last positioned argument should be used at the right position as well. It might be useful to place named argument before positioned, for example to name a boolean flag. If the mapping is not successful (there is unnecessary argument or a parameter without default value does not have a corresponding argument), a special error is generated. But the analysis does not stop (to be able to infer the resulting type and avoid generating too much red code).</p>
</div>
<div class="paragraph">
<p>Code: <code>ValueArgumentsToParametersMapper.</code></p>
</div>
<div class="paragraph">
<p>Todo: Now we do not allow to write a positioned argument after a named one.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Choosing the most specific candidate</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The informal intuition is that one candidate is more specific than another if any invocation handled by the first candidate could be passed on to the other one without a compile-time error.</p>
</div>
<div class="paragraph">
<p>Todo: In Java type inference is applied here (we might want the same approach).</p>
</div>
<div class="paragraph">
<p>Code: OverloadingConflictResolver.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Solve constraint system</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The reminder: the constraint system consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>map: type variable → type bounds;</p>
</li>
<li>
<p>references to function literal arguments;</p>
</li>
<li>
<p>information about errors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We have to find type substitution for each type variable that satisfies all its bounds. As variables may depend on each other, we have to find the right order to fix the value of a variable to avoid changing it later (that might make the process infinite). Let us emphasize several phases of the solving process (that can be repeated and go one after the other in any order):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Adding new constraint and inflating the system with all possible new bounds that can be derived from this new constraint and current bounds.</p>
</li>
<li>
<p>Fixing type variable.</p>
</li>
<li>
<p>Analyzing function literal argument body (that may add new type variables and constraints to our system).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let us say that a variable α depends on a variable β if there is a type bound on α that contains β as a type-argument or is β itself.</p>
</div>
<div class="paragraph">
<p>A function literal <code>fl</code> of the type <code>(A1,&#8230;&#8203; An)−&gt; R</code> depends on a variable β if its value argument type <code>Ai</code> mentions β . A variable α depends on a function literal <code>fl</code> if the result type <code>R</code> mentions α.  With "depends on" relation we can divide our set of variables and function literals into connected components. If there is a relation " α is subtype of β ", then variables α and β are in the same connected component, because they depend on each other. Let us divide some components even more to reach the state when the component is either a set of variables, either a function literal. To achieve this, we cut the dependencies of the last function literal in the component containing both variables and function literals.</p>
</div>
<div class="paragraph">
<p>The example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T, R&gt; foo(..., f: (T)-&gt;R, g: (R)-&gt;T)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the concrete invocation</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>foo(..., { x -&gt; ... }, { y -&gt; ... })</code></pre>
</div>
</div>
<div class="paragraph">
<p>we will have the following dependencies:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>T ← f ← R ← g ← T</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is one dependency component, but we would like to divide it. Therefore we do not add the dependency for the function literal if it creates a connected component with both variables and function literals, in our case <code>g ← T</code>, and have: <code>T ← f ← R ← g</code>. Repeating this process we separate each function literal into its own connected component. Note that we generate constraints for the arguments in an order they are
written in the code, so in an example above we say that the second function literal depends on return type of the first one (not vice versa).</p>
</div>
<div class="paragraph">
<p>Another example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun &lt;T&gt;foo(f: (T)-&gt;T)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We do not add the last dependency <code>f ← T</code>, having only <code>T ← f</code>. Having done this, we can consequently fix the values of the type variables and analyze function literal bodies, adding new constraints to the system. The "expected type" constraint is the last one to add (all constraints from the value arguments we have added already).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun solve(s: ConstraintSystem, expectedType) {
 s.addSupertypeConstraint(expectedType, foo.returnType)
 while (s.hasUnknownVariables()) {
 val e = s.getIndependentConnectedComponent()
 if (e is VariableSet) {
 fixVariables(e)
 }
 if (e is FunctionLiteral) {
 analyzeFunctionLiteralBody({ returnedExpression →
 s.addSubtypeConstraint(fl.type, returnedExpression.typeInfo)
 })
 }
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The easiest way to fix the variables that comes to mind is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun fixVariables(set: Set&lt;Variable&gt;) {
 for (v in set) {
 fixVariable(v)
 }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But this method will not work for some corner cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>variables: <code>U</code>, <code>V</code>, <code>W</code></p>
</li>
<li>
<p>constraints: <code>U &lt;: V</code>, <code>V &lt;: W</code>, <code>W &gt;: Int</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We try to fix <code>U</code> first, and generate an error "not enough information to infer type variable value". But we could get this info generating the value for <code>W</code> beforehand. So fixing variables should work like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun fixVariables(set: Set&lt;Variable&gt;) {
 for (v in set)
 fixWithDependent(v)
 for (v in set)
 if (!fixed(v))
 status ← error
}
fun fixWithDependent(v) {
 if (hasNoProperTypeBounds(v) || fixed(v)) return
 fixVariable(v)
 for (u in v.dependentVariables)
 fixWithDependent(u)
}
fun fixVariable(v)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fixing a variable means finding the type that satisfies all bounds on this variable. The result may depend on variance of type variable as well: subtype of all possible answers for covariant and invariant occurrences and supertype for contravariant (see the example below). Type bounds can be weak and strong. Weak bounds are derived only from type-parameter bounds, and all other bounds are strong. If a type variable has only weak bounds, we consider its value as undefined and generate an error "not enough information to infer type-parameter". If a type variable has both weak and strong bounds, all of them are used
to infer the result value. When we fix the variable, we try several suggestions and return the suggestion if it satisfies all bounds. The suggestions are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>exact bound,</p>
</li>
<li>
<p>supertype of lower bounds except number lower bounds,</p>
</li>
<li>
<p>supertype of number lower bounds,</p>
</li>
<li>
<p>supertype of all lower bounds,</p>
</li>
<li>
<p>intersection of upper bounds (if it is denotable).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here only proper bounds are considered, meaning only those which do not depend on other type variables. The number lower bounds are processed separately, because an algorithm to find their supertype differs from the one for usual bounds. Let us consider two number value types <code>NVT(1)</code> and <code>NVT(10000000000)</code>. The supertypes of <code>NVT(1)</code> are <code>Int</code>, <code>Byte</code>, <code>Short</code>, <code>Long</code>. <code>NVT(10000000000)</code> has only <code>Long</code> as its supertype (the number is too large to be stored in <code>Int</code>). We have to take intersection of supertypes (<code>Long</code> in the example) to find the correct value.</p>
</div>
<div class="paragraph">
<p>Code: <code>TypeBoundsImpl.computeValues()</code></p>
</div>
<div class="paragraph">
<p>For the type-parameter that can be found only in CONTRAVARIANT position in return type, the order of suggestions to try could be changed (try first intersection of upper bounds) to provide having the upper bound of possible answers as a result. That means maximal versus minimal type of the solution space. In the most cases for type-parameter in contravariant position maximal type equals minimum type, because only lower bounds are generated. It fails only with the type-parameter bounds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun foo&lt;T: R&gt;(T, Comparator&lt;R&gt;): Comparator&lt;T&gt;
interface A; interface B : A
foo(b, comparatorForA)
T &gt;: B,
Comparator&lt;R&gt; &gt;: Comparator&lt;A&gt; =&gt; R &lt;: A =&gt; T &lt;: A (with the use of `T &lt;: R`)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus the solution space is {<code>A</code>, <code>B</code>}. Maximal type is <code>A</code>, and returning of <code>Comparator&lt;A&gt;</code> is better, because it is a more precise type. However, that means in the following case we may want to return more precise type as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun bar&lt;T: A&gt;(T): Comparator&lt;T&gt;
bar(b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>But returning <code>Comparator&lt;A&gt;</code> may surprise one, because if <code>A</code> is just implicit <code>Any?</code>, to have always <code>Comparator&lt;Any?&gt;</code> is a bit odd. Note that using upper bounds in inference (not just checking them) is important for some cases (see KT-3372).</p>
</div>
<div class="paragraph">
<p>Note. (from discussion 03.03.15)
Let us assume we use type information for one 'elvis' or 'if' branch from another branch (if we represent special constructions 'if', 'elvis', '!!' as calls, it is difficult not to do so). Then some unexpected behavior may occur like in KT-6694:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface PsiElement {
 fun &lt;T: PsiElement&gt; findChildByType(i: Int): T?
}
interface JetSimpleNameExpression: PsiElement {
 open fun getReferencedNameElement(): PsiElement
}
interface JetLabelReferenceExpression : JetSimpleNameExpression {
 public override fun getReferencedNameElement() =
findChildByType(42) ?: this
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the expression <code>findChildByType(42)</code> has the type <code>JetLabelReferenceExpression</code>, which can lead to class cast exception in runtime (see the comment in the task for more detailed example). The proposed solution is described below. It might also be noted that for now we would like not to infer type-parameter without constraints on it, like (KT-5464):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val l = listOf() //compiler error</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Scala <code>List&lt;Nothing&gt;</code> is inferred for such a case. We definitely want to infer type parameter if it is not used in return type (KT-2656), but there are doubts whether to infer <code>List&lt;Nothing&gt;</code> as a type of <code>l</code> variable or not. If we infer <code>Nothing</code> by default, the problem KT-6694 can be fixed by not using the type information for one branch from another, because the following case will work anyway: <code>if (true) listOf(1, 2, 3) else listOf()</code>. However in Scala it is not the case: information from another <code>if</code> branch is used for inference, in spite of inferring <code>Nothing</code> by default in many cases (see the comment to KT-6901). The proposed solution is to consider a constraint from expected type with the highest priority. For the example above there are two constraints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>T &gt;: JetLabelReferenceExpression, T &lt;: PsiElement</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PsiElement</code> can be inferred because it is a constraint from expected type. However if we use the information for one 'elvis' or 'if' branch from another branch, the following declarations will inevitably lead to class cast exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val x = findChildByType(42) ?: this //exception</code></pre>
</div>
</div>
<div class="paragraph">
<p>With explicit variable type, we infer <code>PsiElement</code>, because it is the constraint from expected type and it has the highest priority:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val x: PsiElement = findChildByType(42) ?: this // ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>To support initial request (an example above), we should use a return type of overridden function as expected type for function body (see KT-6901), with the same highest priority as every expected type.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Constraint system incorporation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TODO: integrate the description of the algorithm from another document</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_threads_and_concurrency">18. Threads and Concurrency</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_26">18.1. General</h3>
<div class="paragraph">
<p>Not all platforms may provide multithreading.
TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_memory_model">18.2. Memory Model</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_race_conditions_2">18.3. Race Conditions</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_synchronization">18.4. Synchronization</h3>
<div class="paragraph">
<p>TODO: synchronized annotation</p>
</div>
</div>
<div class="sect2">
<h3 id="_thread_creation_and_termination">18.5. Thread Creation and Termination</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_interoperability">19. Java Interoperability</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_general_27">19.1. General</h3>
<div class="paragraph">
<p>One of design goals of the Kotlin language is to provide a seamless interoperability with Java code, both when invoking Java code from Kotlin, and when invoking Kotlin code from Java. In this section we describe some details about calling Java code from Kotlin.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Calling Java code from Kotlin</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most Java code can be used from Kotlin without any issues</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import java.util.*

fun demo(source: List&lt;Int&gt;) {
  val list = ArrayList&lt;Int&gt;()
  // `for`-loops work for Java collections:
  for (item in source)
    list.add(item)
  // Operator conventions work as well:
  for (i in 0..source.size() - 1)
    list[i] = source[i] // get and set are called
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Getters and Setters</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with <code>get</code> and single-argument methods with names starting with <code>set</code>) are represented as properties in Kotlin. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>import java.util.Calendar

fun calendarDemo() {
    val calendar = Calendar.getInstance()
    if (calendar.firstDayOfWeek == Calendar.SUNDAY) {  // call getFirstDayOfWeek()
        calendar.firstDayOfWeek = Calendar.MONDAY       // call setFirstDayOfWeek()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the Java class only has a setter, it will not be visible as a property in Kotlin, because Kotlin does not support set-only properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Methods returning <code>void</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a Java method returns <code>void</code>, it will return <code>Unit</code> when called from Kotlin. If that return value is used, it will be assigned at the call site by the Kotlin compiler, since the value itself is known in advance (being object <code>Unit</code>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Escaping for Java identifiers that are keywords in Kotlin</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some of the Kotlin keywords are valid identifiers in Java: <code>in</code>, <code>object</code>, <code>is</code>, etc. If a Java library uses a Kotlin keyword for a method, it still can be called escaping it with the backtick characters</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>foo.`is`(bar)</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Null-Safety and Platform Types</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any reference in Java may be null, which makes Kotlin requirements of strict null-safety impractical for objects coming from Java. Types of Java declarations are treated specially in Kotlin and called platform types. Null-checks are relaxed for such types, so that safety guarantees for them are the same as in Java.</p>
</div>
<div class="paragraph">
<p>Consider the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val list = ArrayList&lt;String&gt;() // non-null (constructor result)
list.add("Item")
val size = list.size() // non-null (primitive int)
val item = list[0] // platform type inferred (ordinary Java object)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we call methods on variables of platform types, Kotlin does not issue nullability errors at compile time, but the call may fail at runtime, because of a null-pointer exception or an assertion that Kotlin generates to prevent nulls from propagating:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>item.substring(1) // allowed, may throw an exception if item == null</code></pre>
</div>
</div>
<div class="paragraph">
<p>Platform types are <strong>non-denotable</strong>, meaning that one cannot write them down explicitly in the language. When a platform value is assigned to a Kotlin variable, we can rely on type inference (the variable will have an inferred platform type then, as <code>item</code> has in the example above), or we can choose the type that we expect (both nullable and non-null types are allowed):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val nullable: String? = item // allowed, always works
val notNull: String = item // allowed, may fail at runtime</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we choose a non-null type, the compiler will emit an assertion upon assignment. This prevents Kotlin non-null variables from holding nulls. Assertions are also emitted when we pass platform values to Kotlin functions expecting non-null values etc. Overall, the compiler does its best to prevent nulls from propagating far through the program (although sometimes this is impossible to eliminate entirely, because of generics).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Notation for Platform Types</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As mentioned above, platform types cannot be mentioned explicitly in the program, so there is no syntax for them in the language. Nevertheless, the compiler and IDE need to display them sometimes (in error messages, parameter info etc.), so we have a mnemonic notation for them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T!</code> means " <code>T</code> or <code>T?</code> ",</p>
</li>
<li>
<p><code>(Mutable)Collection&lt;T&gt;!</code> means "Java collection of <code>T</code> may be mutable or not, may be nullable or not",</p>
</li>
<li>
<p><code>Array&lt;(out) T&gt;!</code> means "Java array of <code>T</code> (or a subtype of <code>T</code>), nullable or not"</p>
</li>
<li>
<p>Nullability annotations</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports the JetBrains flavor of the nullability annotations (its description can be found at <a href="http://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html" class="bare">http://www.jetbrains.com/idea/help/nullable-and-notnull-annotations.html</a>). TODO: copy relevant information here (<code>@Nullable</code> and <code>@NotNull</code> from the <code>org.jetbrains.annotations</code> package).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mapped types</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kotlin treats some Java types specially. Such types are not loaded from Java "as is", but are <em>mapped</em> to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java primitive types are mapped to corresponding Kotlin types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| **Java type** | **Kotlin type**  |
|---------------|------------------|
| `byte`        | `kotlin.Byte`    |
| `short`       | `kotlin.Short`   |
| `int`         | `kotlin.Int`     |
| `long`        | `kotlin.Long`    |
| `char`        | `kotlin.Char`    |
| `float`       | `kotlin.Float`   |
| `double`      | `kotlin.Double`  |
| `boolean`     | `kotlin.Boolean` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some non-primitive built-in classes are also mapped:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| **Java type** | **Kotlin type**  |
|---------------|------------------|
| `java.lang.Object`       | `kotlin.Any!`    |
| `java.lang.Cloneable`    | `kotlin.Cloneable!`    |
| `java.lang.Comparable`   | `kotlin.Comparable!`    |
| `java.lang.Enum`         | `kotlin.Enum!`    |
| `java.lang.Annotation`   | `kotlin.Annotation!`    |
| `java.lang.Deprecated`   | `kotlin.Deprecated!`    |
| `java.lang.Void`         | `kotlin.Nothing!`    |
| `java.lang.CharSequence` | `kotlin.CharSequence!`   |
| `java.lang.String`       | `kotlin.String!`   |
| `java.lang.Number`       | `kotlin.Number!`     |
| `java.lang.Throwable`    | `kotlin.Throwable!`    |</code></pre>
</div>
</div>
<div class="paragraph">
<p>Collection types may be read-only or mutable in Kotlin, so Java collections are mapped as follows (all Kotlin types in this table reside in the package <code>kotlin</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| **Java type** | **Kotlin read-only type**  | **Kotlin mutable type** | **Loaded platform type** |
|---------------|------------------|----|----|
| `Iterator&lt;T&gt;`        | `Iterator&lt;T&gt;`        | `MutableIterator&lt;T&gt;`            | `(Mutable)Iterator&lt;T&gt;!`            |
| `Iterable&lt;T&gt;`        | `Iterable&lt;T&gt;`        | `MutableIterable&lt;T&gt;`            | `(Mutable)Iterable&lt;T&gt;!`            |
| `Collection&lt;T&gt;`      | `Collection&lt;T&gt;`      | `MutableCollection&lt;T&gt;`          | `(Mutable)Collection&lt;T&gt;!`          |
| `Set&lt;T&gt;`             | `Set&lt;T&gt;`             | `MutableSet&lt;T&gt;`                 | `(Mutable)Set&lt;T&gt;!`                 |
| `List&lt;T&gt;`            | `List&lt;T&gt;`            | `MutableList&lt;T&gt;`                | `(Mutable)List&lt;T&gt;!`                |
| `ListIterator&lt;T&gt;`    | `ListIterator&lt;T&gt;`    | `MutableListIterator&lt;T&gt;`        | `(Mutable)ListIterator&lt;T&gt;!`        |
| `Map&lt;K, V&gt;`          | `Map&lt;K, V&gt;`          | `MutableMap&lt;K, V&gt;`              | `(Mutable)Map&lt;K, V&gt;!`              |
| `Map.Entry&lt;K, V&gt;`    | `Map.Entry&lt;K, V&gt;`    | `MutableMap.MutableEntry&lt;K,V&gt;` | `(Mutable)Map.(Mutable)Entry&lt;K, V&gt;!` |</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java arrays are mapped as mentioned below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>| **Java type** | **Kotlin type**  |
|---------------|------------------|
| `int[]`       | `kotlin.IntArray!` |
| `String[]`    | `kotlin.Array&lt;(out) String&gt;!` |</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Java generics in Kotlin</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kotlin generics are a little different from Java. When importing Java types to Kotlin we perform some conversions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java wildcards are converted into type projections</p>
</li>
<li>
<p><code>Foo&lt;? extends Bar&gt;</code> becomes <code>Foo&lt;out Bar!&gt;!</code></p>
</li>
<li>
<p><code>Foo&lt;? super Bar&gt;</code> becomes <code>Foo&lt;in Bar!&gt;!</code></p>
</li>
<li>
<p>Java raw types are converted into star projections</p>
</li>
<li>
<p><code>List</code> becomes <code>List&lt;*&gt;!</code>, i.e. <code>List&lt;out Any?&gt;!</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Like in Java, in Kotlin generics are not retained at runtime, i.e. objects do not carry information about actual type-arguments passed to their constructors, i.e. <code>ArrayList&lt;Integer&gt;()</code> is indistinguishable from <code>ArrayList&lt;Character&gt;()</code>. This makes it impossible to perform <code>is</code>-checks that take generics into account. Kotlin only allows <code>is</code>-checks for star-projected generic types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>if (a is List&lt;Int&gt;) // Error: cannot check if it is really a List of Ints
// but
if (a is List&lt;*&gt;) // OK: no guarantees about the contents of the list</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Java Arrays</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Arrays in Kotlin are invariant, unlike Java. This means that Kotlin does not let us assign an <code>Array&lt;String&gt;</code> to an <code>Array&lt;Any&gt;</code>, which prevents a possible runtime failure. Passing an array of a subclass as an array of superclass to a Kotlin method is also prohibited, but for Java methods this is allowed (through platform types of the form <code>Array&lt;(out) String&gt;!</code>).</p>
</div>
<div class="paragraph">
<p>Arrays are used with primitive datatypes on the Java platform to avoid the cost of boxing/unboxing operations. As Kotlin hides those implementation details, a workaround is required to interface with Java code. There are specialized classes for every type of primitive array (<code>IntArray</code>, <code>DoubleArray</code>, <code>CharArray</code>, and so on) to handle this case. They are not related to the <code>Array</code> class and are compiled down to Java primitive arrays for maximum performance.</p>
</div>
<div class="paragraph">
<p>Suppose there is a Java method that accepts an int array of indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class JavaArrayExample {

    public void removeIndices(int[] indices) {
        // code here...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To pass an array of primitive values one can do the following in Kotlin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val javaObj = JavaArrayExample()
val array = intArrayOf(0, 1, 2, 3)
javaObj.removeIndices(array)  // passes int[] to method</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class JavaArrayExample {

    public void removeIndices(int... indices) {
        // code here...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case the spread operator <code>*</code> can be used to pass the <code>IntArray</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val javaObj = JavaArray()
val array = intArrayOf(0, 1, 2, 3)
javaObj.removeIndicesVarArg(*array)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is not possible to pass <strong>null</strong> to a method that is declared as varargs.</p>
</div>
<div class="paragraph">
<p>When compiling to JVM byte codes, the compiler optimizes access to arrays so that there is no overhead introduced:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val array = array(1, 2, 3, 4)
array[x] = array[x] * 2 // no actual calls to get() and set() generated
for (x in array) // no iterator created
  print(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even when we navigate with an index, it does not introduce any overhead</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>for (i in array.indices) // no iterator created
  array[i] += 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, <code>in</code>-checks have no overhead either</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>if (i in array.indices) { // same as (i &gt;= 0 &amp;&amp; i &lt; array.size)
  print(array[i])
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Operators</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since Java has no way of marking methods for which it makes sense to use the operator syntax, Kotlin allows using any Java methods with the right name and signature as operator overloads and other conventions (<code>invoke()</code> etc.). Calling Java methods using the infix call syntax is not allowed.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Checked Exceptions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Kotlin, all exceptions are unchecked, meaning that there is no requirement to catch any of them. So, when a Java method that declares a checked exception is called from Kotlin, a try/catch statement is not required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun render(list: List&lt;*&gt;, to: Appendable) {
  for (item in list)
    to.append(item.toString()) // Java would require us to catch IOException here
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Object Methods</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When Java types are imported into Kotlin, all the references of the type <code>java.lang.Object</code> are turned into <code>Any</code>. Since <code>Any</code> is not platform-specific, it only declares <code>toString()</code>, <code>hashCode()</code> and <code>equals()</code> as its members, so to make other members of <code>java.lang.Object</code> available, Kotlin uses extension functions.</p>
</div>
<div class="sect3">
<h4 id="_waitnotify">19.1.1. wait()/notify()</h4>
<div class="paragraph">
<p>Methods <code>wait</code> and <code>notify</code> declared in <code>java.lang.Object</code> are not available on references of type <code>Any</code>.</p>
</div>
<div class="paragraph">
<p>[Rationale:
[Effective Java](<a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html" class="bare">http://www.oracle.com/technetwork/java/effectivejava-136174.html</a>) Item 69 recommends to prefer concurrency utilities to <code>wait()</code> and <code>notify()</code>.
End rationale]
[Note: to workaround this restriction, an object can be explicitly cast to <code>java.lang.Object</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">(foo as java.lang.Object).wait()</code></pre>
</div>
</div>
<div class="paragraph">
<p>End Note]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>getClass()</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To retrieve the type information from an object, we use the javaClass extension property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val fooClass = foo.javaClass</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of Java&#8217;s <code>Foo.class</code> use <code>Foo::class.java</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val fooClass = Foo::class.java</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>clone()</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To override <code>clone</code>, a class needs to extend <code>kotlin.Cloneable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Example : Cloneable {
  override fun clone(): Any { ... }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>finalize()</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To implement a finalizer, a class has to declare a protected parameterless non-generic <code>Unit</code>-returning method named <code>finalize</code>, without using the <code>override</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class C {
  protected fun finalize() {
    // finalization logic
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Inheritance from Java classes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At most one Java-class (and arbitrary number of Java interfaces) can be a supertype for a class in Kotlin.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Accessing static members</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Static members of Java classes form "companion objects" for these classes. We cannot pass such a "companion object" around as a value, but can access the members explicitly, for example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>if (Character.isLetter(a)) {
  // ...
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Java Reflection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java reflection works on Kotlin classes and vice versa. Expressions <code>instance.javaClass</code> or <code>ClassName::class.java</code> can be used to to enter Java reflection through <code>java.lang.Class</code>.</p>
</div>
<div class="paragraph">
<p>Other supported cases include acquiring a Java getter/setter method or a backing field for a Kotlin property, a <code>KProperty</code> for a Java field, a Java method or constructor for a <code>KFunction</code> and vice versa.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SAM Conversions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</p>
</div>
<div class="paragraph">
<p>This can be used for creating instances of SAM interfaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val runnable = Runnable { println("This runs in a runnable") }</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;and in method calls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val executor = ThreadPoolExecutor()
// Java signature: void execute(Runnable command)
executor.execute { println("This runs in a thread pool") }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the Java class has multiple methods taking functional interfaces, a particular one can be chosen by using an adapter function that converts a lambda to a specific SAM type. Those adapter functions are also generated by the compiler when needed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>executor.execute(Runnable { println("This runs in a thread pool") })</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that SAM conversions only work for interfaces, not for abstract classes, even if those also have just a single abstract method.</p>
</div>
<div class="paragraph">
<p>Also note that this feature works only for Java interop; since Kotlin has proper function types, automatic conversion of functions into implementations of Kotlin interfaces is unnecessary and therefore unsupported.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Calling Kotlin code from Java</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kotlin code can be called from Java easily.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Property getters are turned into <strong>get</strong>-methods, and setters&#8201;&#8212;&#8201;into <strong>set</strong>-methods.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Package-Level Functions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All the functions and properties declared in a file <code>example.kt</code> inside a package <code>org.foo.bar</code> are put into a Java class named <code>org.foo.bar.ExampleKt</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// example.kt
package demo

class Foo

fun bar() {
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
new demo.Foo();
demo.ExampleKt.bar();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name of the generated Java class can be changed using the <code>@JvmName</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@file:JvmName("DemoUtils")

package demo

class Foo

fun bar() {
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
new demo.Foo();
demo.DemoUtils.bar();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Having multiple files which have the same generated Java class name (the same package and the same name or the same <code>@JvmName</code> annotation) is normally an error. However, the compiler has the ability to generate a single Java facade class which has the specified name and contains all the declarations from all the files which have that name. To enable the generation of such a facade, use the <code>@JvmMultifileClass</code> annotation in all of the files.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// oldutils.kt
@file:JvmName("Utils")
@file:JvmMultifileClass

package demo

fun foo() {
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// newutils.kt
@file:JvmName("Utils")
@file:JvmMultifileClass

package demo

fun bar() {
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
demo.Utils.foo();
demo.Utils.bar();</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Fields</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To expose a Kotlin property as a field in Java, it has to be annotates with the <code>@JvmField</code> annotation. The field will have the same visibility as the underlying property. A property with <code>@JvmField</code> can be created if it has a backing field, is not private, does not have <code>open</code>, <code>override</code> or <code>const</code> modifiers, and is not a delegated property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class C(id: String) {
    @JvmField val ID = id
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
class JavaClient {
    public String getID(C c) {
        return c.ID;
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Static Methods and Fields</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As mentioned above, Kotlin generates static methods for package-level functions. On top of that, it also generates static methods for functions defined in named objects or companion objects of classes and annotated as <code>@JvmStatic</code>. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class C {
  companion object {
    @JvmStatic fun foo() {}
    fun bar() {}
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, <code>foo</code> is static in Java, while <code>bar</code> is not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">C.foo(); // works fine
C.bar(); // error: not a static method</code></pre>
</div>
</div>
<div class="paragraph">
<p>Same for named objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>object Obj {
    @JvmStatic fun foo() {}
    fun bar() {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Obj.foo(); // works fine
Obj.bar(); // error
Obj.INSTANCE.bar(); // works, a call through the singleton instance
Obj.INSTANCE.foo(); // works too</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, public properties defined in objects and companion objects, as well as top-level properties annotated with <code>const</code>, are turned into static fields in Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// file example.kt

object Obj {
  val CONST = 1
}

const val MAX = 239</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Java:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int c = Obj.CONST;
int d = ExampleKt.MAX;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Handling signature clashes with <code>@JvmName</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Sometimes we have a named function in Kotlin, for which we need a different JVM name the byte code. The most prominent example happens due to type erasure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun List&lt;String&gt;.filterValid(): List&lt;String&gt;
fun List&lt;Int&gt;.filterValid(): List&lt;Int&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These two functions cannot be defined side-by-side, because their JVM signatures are the same: <code>filterValid(Ljava/util/List;)Ljava/util/List;</code>. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with <code>@JvmName</code> and specify a different name as an argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun List&lt;String&gt;.filterValid(): List&lt;String&gt;

@JvmName("filterValidInt")
fun List&lt;Int&gt;.filterValid(): List&lt;Int&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>From Kotlin they will be accessible by the same name <code>filterValid</code>, but from Java it will be <code>filterValid</code> and <code>filterValidInt</code>.</p>
</div>
<div class="paragraph">
<p>The same trick applies when we need to have a property <code>x</code> alongside with a function <code>getX</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>val x: Int
  @JvmName("getX_prop")
  get() = 15

fun getX() = 10</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Overloads Generation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Normally, when a Kotlin method is declared with default parameter values, it will be visible in Java only as a full signature, with all parameters present. To expose multiple overloads to Java callers, the @JvmOverloads annotation
can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@JvmOverloads fun f(a: String, b: Int = 0, c: String = "abc") {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For every parameter with a default value, this will generate one additional overload, which has this parameter and all parameters to the right of it in the parameter list removed. In this example, the following methods will be
generated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
void f(String a, int b, String c) { }
void f(String a, int b) { }
void f(String a) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The annotation also works for constructors, static methods etc. It cannot be used on abstract methods, including methods defined in interfaces.</p>
</div>
<div class="paragraph">
<p>Note that if a class has default values for all constructor parameters, a public no-argument constructor will be generated for it. This works even if the <code>@JvmOverloads</code> annotation is not specified.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Checked Exceptions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Kotlin does not have checked exceptions. So, normally, the Java signatures of Kotlin functions do not declare exceptions thrown. Thus if a function is declared in Kotlin like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>// example.kt
package demo

fun foo() {
  throw IOException()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider a scenario when it is necessary to call it from Java and catch the exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Java
try {
  demo.Example.foo();
}
catch (IOException e) { // error: foo() does not declare IOException in the throws list
  // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code will result in an error message from the Java compiler, because <code>foo()</code> does not declare <code>IOException</code>. To work around this problem, the <code>@Throws</code> annotation in Kotlin can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>@Throws(IOException::class)
fun foo() {
    throw IOException()
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Null-safety</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When calling Kotlin functions from Java, there is no mechanism to prevent Java code from passing <strong>null</strong> as a non-null parameter. Therefore, Kotlin generates runtime checks for all public functions that expect non-nulls. In case a null argument is passed, the <code>NullPointerException</code> will be thrown immediately upon entry to the function, before any statements in it are executed.</p>
</div>
<div class="paragraph">
<p>Generic types whose type-arguments is Nothing are represented as raw type in Java. TODO: what happens if arity &gt; 1?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Function Types in Kotlin on JVM</p>
</li>
<li>
<p>Brief overview</p>
</li>
<li>
<p>Treat extension functions almost like non-extension functions with one extra parameter, allowing to use them almost interchangeably.</p>
</li>
<li>
<p>Introduce a physical class <code>Function</code> and unlimited number of <strong>fictitious</strong> (synthetic) classes <code>Function0</code>, <code>Function1</code>, &#8230;&#8203; in the compiler front-end</p>
</li>
<li>
<p>On JVM, introduce <code>Function0</code>..<code>Function22</code>, which are optimized in a certain way, and <code>FunctionN</code> for functions with 23+ parameters. When passing a lambda to Kotlin from Java, one will need to implement one of these interfaces.</p>
</li>
<li>
<p>Also on JVM (under the hood) add abstract <code>FunctionImpl</code> which implements all of <code>Function0</code>..<code>Function22</code> and <code>FunctionN</code> (throwing exceptions), and which knows its arity. Kotlin lambdas are translated to subclasses of this abstract class, passing the correct arity to the super constructor.</p>
</li>
<li>
<p>Provide a way to get arity of an arbitrary <code>Function</code> object (pretty straightforward).</p>
</li>
<li>
<p>Hack <code>is/as Function5</code> on any numbered function in codegen (and probably <code>KClass.cast()</code> in reflection) to check against <code>Function</code> and its arity.</p>
</li>
<li>
<p>Extension functions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Extension function type <code>T.(P) -&gt; R</code> is now a shorthand for <code>@kotlin.extension Function2&lt;T, P, R&gt;</code>. <code>kotlin.extension</code> is a type annotation defined in built-ins. So effectively functions and extension functions now have the same type, which means that everything which takes a function will work with an extension function and vice versa.</p>
</div>
<div class="paragraph">
<p>To avoid ambiguities, the following restrictions are in effect:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A value of an extension function type cannot be called as a non-extension function, and a value of a non-extension function type cannot be called as an extension. This requires an additional diagnostic which only occurs when a call is resolved to the <code>invoke</code> with the wrong extension-ness.</p>
</li>
<li>
<p>Shape of a function literal argument or a function expression must exactly match the extension-ness of the corresponding parameter. An extension function literal or an extension function expression cannot be passed where a function is expected and vice versa. [Note: To workaround this restriction, it is possible to change the shape, assign literal to a variable or use the <code>as</code> operator. End Note]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, it is possible safely coerce values between function and extension function types, but they still have to be invoked in a way which specified in their type (with or without <code>@Extension</code>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Function0</code>, <code>Function1</code>, &#8230;&#8203; types</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The arity of the functional interface is not limited by the language, but can be limited by the platform.
<em>[Example:</em> a typical limitation on JVM is 255 on JVM. <em>End example]</em></p>
</div>
<div class="paragraph">
<p>These interfaces are named <code>Function0&lt;R&gt;</code>, <code>Function1&lt;P0, R&gt;</code>, &#8230;&#8203;, <code>Function42&lt;P0, P1, &#8230;&#8203;, P41, R&gt;</code>, &#8230;&#8203; in the package <code>kotlin</code>. They are <strong>fictitious</strong>, which means they have no sources and no runtime representation. Type checker creates the corresponding descriptors on demand, IDE creates corresponding source files on demand as well. Each of them inherits from <code>kotlin.Function</code> (described below) and contains only two functions, both of which are synthetically produced by the compiler:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>(declaration) <code>invoke</code> with no receiver, with the corresponding number of parameters and return type.</p>
</li>
<li>
<p>(synthesized) <code>invoke</code> with first type-parameter as the extension receiver type, and the rest as parameters and return type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Call resolution shall use the annotations on the type of the receiver of the call to select the correct <code>invoke</code> and to report the diagnostic if the <code>invoke</code> is ill-formed (see the previous block).</p>
</div>
<div class="paragraph">
<p>On JVM function types are erased to the physical classes defined in package <code>kotlin.jvm.internal</code>:
<code>Function0</code>, <code>Function1</code>, &#8230;&#8203;, <code>Function22</code>, and <code>FunctionN</code> for 23 parameters and above.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Function interface</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is also the empty interface <code>kotlin.Function&lt;R&gt;</code> which is a supertype for all functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package kotlin

interface Function&lt;out R&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a physical interface, declared in platform-agnostic built-ins. [Example: On JVM it is typically located in <code>kotlin-runtime.jar</code>. End example].
However its declaration is empty. [Rationale: Because every physical JVM function class <code>Function0</code>, <code>Function1</code>, &#8230;&#8203; inherits from it (and adds <code>invoke()</code>), it is desirable that a user is not required to provide overrides for anything besides <code>invoke()</code> when doing it from Java code. End rationale]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Functions with 0..22 parameters at runtime</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are 23 function interfaces in <code>kotlin.jvm.functions</code>: <code>Function0</code>, <code>Function1</code>, &#8230;&#8203;, <code>Function22</code>. Here is <code>Function1</code> declaration, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package kotlin.jvm.functions

interface Function1&lt;in P1, out R&gt; : kotlin.Function&lt;R&gt; {
    fun invoke(p1: P1): R
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These interfaces are supposed to be inherited from by Java classes when passing lambdas to Kotlin. They should not be used from Kotlin however, because normally one would use a function type there, most of the time even without mentioning built-in function classes: <code>(P1, P2, P3) -&gt; R</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Translation of Kotlin lambdas</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is also <code>FunctionImpl</code> abstract class at runtime which helps in implementing <code>arity</code> and vararg-invocation. It inherits from all the physical function classes, unfortunately.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package kotlin.jvm.internal;

// This class is implemented in Java because supertypes need to be raw classes
// for reflection to pick up correct generic signatures for inheritors
public abstract class FunctionImpl implements
    Function0, Function1, ..., ..., Function22,
    FunctionN   // See the next section on FunctionN
{
    public abstract int getArity();

    @Override
    public Object invoke() {
        // Default implementations of all "invoke"s invoke "invokeVararg"
        // This is needed for KFunctionImpl (see below)
        assert getArity() == 0;
        return invokeVararg();
    }

    @Override
    public Object invoke(Object p1) {
        assert getArity() == 1;
        return invokeVararg(p1);
    }

    ...
    @Override
    public Object invoke(Object p1, ..., Object p22) { ... }

    @Override
    public Object invokeVararg(Object... args) {
        throw new UnsupportedOperationException();
    }

    @Override
    public String toString() {
        // Some calculation involving generic runtime signatures
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each lambda is compiled to an anonymous class which inherits from <code>FunctionImpl</code> and implements the corresponding <code>invoke</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{ (s: String): Int -&gt; s.length }

// is translated to

object : FunctionImpl(), Function1&lt;String, Int&gt; {
    override fun getArity(): Int = 1

    /* bridge */ fun invoke(p1: Any?): Any? = ...
    override fun invoke(p1: String): Int = p1.length
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Functions with more than 22 parameters at runtime</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To support functions with many parameters there is a special interface in JVM runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package kotlin.jvm.functions

interface FunctionN&lt;out R&gt; : kotlin.Function&lt;R&gt; {
    val arity: Int
    fun invokeVararg(vararg p: Any?): R
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO: usual hierarchy problems: there are no such members in <code>kotlin.Function42</code> (it only has <code>invoke()</code>), so inheritance from <code>Function42</code> will need to be hacked somehow</p>
</div>
<div class="paragraph">
<p>And another type annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package kotlin.jvm.functions

annotation class arity(val value: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A lambda type with 42 parameters on JVM is translated to <code>@arity(42) FunctionN</code>.
A lambda is compiled to an anonymous class which overrides <code>invokeVararg()</code> instead of <code>invoke()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>object : FunctionImpl() {
    override fun getArity(): Int = 42

    override fun invokeVararg(vararg p: Any?): Any? { ... /* code */ }
    // TODO: maybe assert that p's size is 42 in the beginning of invokeVararg?
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>Function0</code>..<code>Function22</code> are provided primarily for Java interoperability and as an optimization for frequently used functions.</p>
</div>
<div class="paragraph">
<p>So when a large function is passed from Java to Kotlin, the object will need to inherit from <code>FunctionN</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>    // Kotlin
    fun fooBar(f: Function42&lt;*,*,...,*&gt;) = f(...)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    // Java
    fooBar(new FunctionN&lt;String&gt;() {
        @Override
        public int getArity() { return 42; }

        @Override
        public String invokeVararg(Object... p) { return "42"; }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>@arity(N) FunctionN&lt;R&gt;</code> coming from Java code will be treated as <code>(Any?, Any?, &#8230;&#8203;, Any?) -&gt; R</code>, where the number of parameters is <code>N</code>. If there is no <code>@arity</code> annotation on the type <code>FunctionN&lt;R&gt;</code>, it will not be loaded as a function type, but rather as just a classifier type with an argument.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Arity and invocation with vararg</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is an ability to get an arity of a function object and call it with variable number of arguments, provided by extensions in platform-agnostic built-ins.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package kotlin

@intrinsic val Function&lt;*&gt;.arity: Int
@intrinsic fun &lt;R&gt; Function&lt;R&gt;.invokeVararg(vararg p: Any?): R</code></pre>
</div>
</div>
<div class="paragraph">
<p>But they do not have any implementation there. The reason is, they need platform-specific function implementation to work efficiently. This is the JVM implementation of the <code>arity</code> intrinsic (<code>invokeVararg</code> is essentially the same):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun Function&lt;*&gt;.calculateArity(): Int {
    return if (function is FunctionImpl) {  // This handles the case of lambdas created from Kotlin
        function.arity  // Note the smart cast
    }
    else when (function) {  // This handles all other lambdas, i.e. created from Java
        is Function0 -&gt; 0
        is Function1 -&gt; 1
        ...
        is Function22 -&gt; 22
        is FunctionN -&gt; function.arity  // Note the smart cast
        else -&gt; throw UnsupportedOperationException()  // TODO: maybe do something funny here,
                                                       // e.g. find `invoke` reflectively
    }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>is</code>/<code>as</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The newly introduced <code>FunctionImpl</code> class inherits from all the <code>Function0</code>, <code>Function1</code>, &#8230;&#8203;, <code>FunctionN</code>. This means that <code>anyLambda is Function2&lt;*, *, *&gt;</code> will be true for any Kotlin lambda.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package kotlin.jvm.internal

// This is the intrinsic implementation
// Calls to this function are generated by codegen on `is` against a function type
fun isFunctionWithArity(x: Any?, n: Int): Boolean = (x as? Function).arity == n</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>[Note:</em> <code>as</code> should check if <code>isFunctionWithArity(instance, arity)</code>, and checkcast if it is or throw exception if not. A downside is that <code>instanceof Function5</code> obviously will not work correctly from Java. <em>End Note]</em></p>
</div>
<div class="paragraph">
<p>Also a warning is issued on <code>is Array&lt;Function2&lt;*, <strong>, *&gt;&gt;</code> and <code>as Array&lt;Function2&lt;</strong>, *, *&gt;&gt;</code>. [Rationale: There is no reasonable way how it could work for empty arrays, because there is no single instance of <code>FunctionImpl</code> to reach out and ask the arity. End rationale]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How this will help reflection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>KFunction*</code> interfaces are synthesized at compile-time identically to functions. The compiler shall resolve <code>KFunction{N}</code> for any <code>N</code>, IDEs should synthesize sources when needed, <code>is</code>/<code>as</code> should be handled similarly etc.</p>
</div>
<div class="paragraph">
<p>However, at runtime there will not be multitudes of `KFunction`s.</p>
</div>
<div class="paragraph">
<p>So for reflection there will be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>fictitious interfaces <code>KFunction0</code>, <code>KFunction1</code>, &#8230;&#8203;, <code>KFunction42</code>, &#8230;&#8203; (defined in <code>kotlin.reflect</code>)</p>
</li>
<li>
<p>physical interface <code>KFunction</code> (defined in <code>kotlin.reflect</code>)</p>
</li>
<li>
<p>physical JVM runtime implementation class <code>KFunctionImpl</code> (defined in <code>kotlin.reflect.jvm.internal</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As an example, <code>KFunction1</code> is a fictitious interface (in much the same manner that <code>Function1</code> is) which inherits from <code>Function1</code> and <code>KFunction</code>. The former lets one call a type-safe <code>invoke</code> on a callable reference, and the latter allows to use reflection features on the callable reference.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun foo(s: String) {}

fun test() {
    ::foo.invoke("")  // ok, calls Function1.invoke
    ::foo.name        // ok, calls KFunction.name
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mixed_projects">19.2. Mixed Projects</h3>
<div class="paragraph">
<p>A Kotlin compiler is able to co-operate with a Java compiles to enable building of mixed projects, where Java source files and Kotlin source files co-exist and are able to reference each other.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="_platform_types_2">19.3. Platform Types</h3>
<div class="paragraph">
<p>Because Java lacks built-in support for non-nullable types, some types exposed from Java to Kotlin need to be handled in a special way.</p>
</div>
<div class="paragraph">
<p>TODO: Flexible types.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sam_types">19.4. SAM Types</h3>
<div class="paragraph">
<p>A SAM type is an abstract class or interface with a single abstract method (SAM stands for "Single Abstract Method").
TODO: Conversions from lambda expressions to SAM types.</p>
</div>
</div>
<div class="sect2">
<h3 id="_optional_parameters">19.5. Optional Parameters</h3>
<div class="paragraph">
<p>On the JVM, if all of the parameters of the primary constructor have default values, the compiler will generate an additional parameterless constructor which will use the default values. This makes it easier to use Kotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_predefined_types_from_java_lang_package">19.6. Using predefined types from java.lang package</h3>
<div class="paragraph">
<p>In general, a predefined type of Java language (e.g. <code>java.lang.Object</code> or <code>java.lang.Integer</code>) should not be used in Kotlin code. The Kotlin standard library provides counterparts for them (e.g. kotlin.Any or kotlin.Int) that should be used instead. The counterparts are not exact clones of their Java prototypes. They may have different set of methods, generic types may declare variance on their type-parameters&#8201;&#8212;&#8201;they are designed to better fit Kotlin programming paradigm. The compiler shall issue a warning if a predefined Java type is used rather than its Kotlin counterpart.</p>
</div>
<div class="paragraph">
<p>If a Java API is used from Kotlin, and it exposes some of those basic types, then signatures in that API are automatically adjusted to replace Java types with their Kotlin counterparts.</p>
</div>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reflection">20. Reflection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_standard_library_overview">21. Standard Library Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_documentation_comments">22. Documentation Comments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_miscellaneous">23. Miscellaneous</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ALL RULES FROM THIS SECTION SHOULD BE MOVED TO OTHER SECTIONS WHERE THEY BELONG</p>
</div>
<div class="paragraph">
<p>An interface method without a body can be marked abstract, but this is redundant.</p>
</div>
<div class="paragraph">
<p>Property initializers are not allowed in interfaces.</p>
</div>
<div class="paragraph">
<p>Override member must have the same or wider visibility as the overridden member.</p>
</div>
<div class="paragraph">
<p>Annotations on type-parameters are not supported yet.</p>
</div>
<div class="paragraph">
<p>Spread operator&#8201;&#8212;&#8201;can pass an existing array, can join to create a new array.</p>
</div>
<div class="paragraph">
<p>Syntax for floating-point literals (including hex), round to zero, round to infinity, suffixes.</p>
</div>
<div class="paragraph">
<p>Generic properties.</p>
</div>
<div class="paragraph">
<p>Escape <code>\$</code></p>
</div>
<div class="paragraph">
<p>Capitalizing first letter of a property in its accessors' names.</p>
</div>
<div class="paragraph">
<p>Within default value for an optional parameter, the parameter is not definitely assigned (TODO: except within lambdas).</p>
</div>
<div class="paragraph">
<p>Visibility of generated componentN() methods in data classes is the same as visibility of the corresponding property.</p>
</div>
<div class="paragraph">
<p>Block cannot contains property declaration with setters, extension property declaration, or generic property declaration.</p>
</div>
<div class="paragraph">
<p>It is an error if right operand of / or % operator for any integral type is constant expression with zero value. Operators / and % for any integral type throw ArithmeticException if right operand is zero at runtime. Arithmetic operators overflow silently. Operator &gt; implements strict linear order on integral types. m&lt;n is equivalent to n&gt;m, m&lt;=n is equivalent to m&lt;n || m==n, m&gt;=n is equivalent to m&gt;n || m==n for integral types and type Char. The type Char supports binary operators +, - with the right operand of type Int, relational operators &gt;,&lt;,&gt;=,&lt;=. Every type (including nullable types) supports operators ==, !=, ===, !==, they are not mentioned  specifically for each type.</p>
</div>
<div class="paragraph">
<p><code>NaN != NaN</code>, if both operands of the same non-nullable floating-point type (so reflexivity and trichotomy properties for equality and comparison operators are violated). This does not apply for method <code>equals</code> invocations.</p>
</div>
<div class="paragraph">
<p>@external annotation is only allowed for top-level functions.</p>
</div>
<div class="paragraph">
<p>An enum constructor cannot explicitly delegate to <code>super</code>.</p>
</div>
<div class="paragraph">
<p><code>return</code> expression are not allowed in functions with expression body. return expression without label</p>
</div>
<div class="paragraph">
<p>return from nearest enclosing named function or anonymous function (TODO: it is more complicated).</p>
</div>
<div class="paragraph">
<p>Anonymous function can use expression body.</p>
</div>
<div class="paragraph">
<p>Type-parameter list is not allowed for anonymous functions.</p>
</div>
<div class="paragraph">
<p>A package name cannot be followed with <code>?.</code>. A class name cannot be followed with <code>?.</code> and a nested class name.</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203; }</code> is parsed as block or as function literal depending on context (e.g. function body, class body, after <code>for</code>, <code>if</code>, <code>else</code>, <code>do</code>, <code>while</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, after <code>-&gt;</code> in a when branch). To specify a function literal in a context where <code>{ &#8230;&#8203; }</code> would be parsed as a block, it can be parenthesized <code>({ &#8230;&#8203; })</code> or explicit parameter list can be provided <code>{ -&gt; &#8230;&#8203; }</code> (even if it is empty). (TODO: block/f. literal can be preceded by annotations and at most one label; providing several labels can force it to be parsed as f. literal)</p>
</div>
<div class="paragraph">
<p>TODO: empty or semicolon branches in if/else</p>
</div>
<div class="paragraph">
<p>An object declaration introduces both a type name and an object name.</p>
</div>
<div class="paragraph">
<p><code>else</code> branch must be the last branch in <code>when</code> expression.</p>
</div>
<div class="paragraph">
<p>Exhaustive when check.</p>
</div>
<div class="paragraph">
<p>Soft keywords:
abstract annotation by catch companion constructor dynamic enum file final
finally get import init inner internal open out override private protected
public reified sealed set vararg where</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http://youtrack.jetbrains.com/issue/KT-2877</pre>
</div>
</div>
<div class="paragraph">
<p>Relax this rule, but take care about identifier not supported by the platform.</p>
</div>
<div class="paragraph">
<p>Left names in dotted names can be merged symbols (even of different kinds, e.g. class and package), whose eventual meaning is determined by which names to the right are looked up in them.</p>
</div>
<div class="paragraph">
<p>Overloading is possible based on constraints only, provided that erased signatures are different.</p>
</div>
<div class="paragraph">
<p>To access a member of an enclosing class using a simple name it is necessary to have an access to <code>this</code> instance of an enclosing class. In some contexts (e.g. within object declarations) <code>this</code> instances of enclosing classes are not available, and hence an access to a member of an enclosing class is not possible using a simple name (unless there is an implicit receiver of the corresponding type introduced by other means, e.g. through an extension function, or by deriving the object from an enclosing class).</p>
</div>
<div class="paragraph">
<p>@synchronized and default parameter values</p>
</div>
<div class="paragraph">
<p>@synchronized and inline</p>
</div>
<div class="paragraph">
<p>annotations on annotation parameters</p>
</div>
<div class="paragraph">
<p>priority list for annotation targets: param, field, property, setter, getter</p>
</div>
<div class="paragraph">
<p>investigate: non-nullable types T!</p>
</div>
<div class="paragraph">
<p>investigate: import com.acme.A.foo where A is an object</p>
</div>
<div class="paragraph">
<p>import directives can import functional members only if they are top-level.</p>
</div>
<div class="paragraph">
<p>Secondary constructors cannot have val/var keywords in parameter declarations.</p>
</div>
<div class="paragraph">
<p>Recursive generic constraints.</p>
</div>
<div class="paragraph">
<p>annotations on init blocks.</p>
</div>
<div class="paragraph">
<p>Nested classes are not inherited, and need to be qualified with their declaring type when referenced from types derived from the declaring type (TODO: consider enabling inheritance for inner classes, or an equivalent to bring their constructors in scope in derived classes).</p>
</div>
<div class="paragraph">
<p>initializer block can have annotations with EXPRESSION target.</p>
</div>
<div class="paragraph">
<p>TODO: Do we support inheritance from inner classes outside of their declaring classes, and do we have any syntax similar to Java qualified superclass constructor invocation (JLS 8, §8.8.7.1 Explicit Constructor Invocations)?</p>
</div>
<div class="paragraph">
<p>At most 1 parameter of a function can be vararg, but not necessarily the last one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A : C { // Error
    public interface B {}
}

interface C : A.B { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is not allowed to manually inherit from Enum&lt;E&gt; type (TODO: implement).</p>
</div>
<div class="paragraph">
<p>Do we need <code>constructor</code> for primary constructors?</p>
</div>
<div class="paragraph">
<p>what is a non-empty package (in binary form and in source form)?</p>
</div>
<div class="paragraph">
<p>no backtracking</p>
</div>
<div class="paragraph">
<p>not including the last identifier</p>
</div>
<div class="paragraph">
<p>try to find visible type with next identifier</p>
</div>
<div class="paragraph">
<p>we depend on order of dependencies, and select the 1st type</p>
</div>
<div class="paragraph">
<p>all except last identifier resolve to a type</p>
</div>
<div class="paragraph">
<p>all import * directives create all unified scope enclosing the file scope</p>
</div>
<div class="paragraph">
<p>import * may import ambiguous members</p>
</div>
<div class="paragraph">
<p>import * may import nothing</p>
</div>
<div class="paragraph">
<p>inner classes from generic classes?</p>
</div>
<div class="paragraph">
<p>package members do not include subpackages</p>
</div>
<div class="paragraph">
<p>package members include type, props, funs (including extensions)</p>
</div>
<div class="paragraph">
<p>TODO: import from singletons?</p>
</div>
<div class="paragraph">
<p>import A&#8201;&#8212;&#8201;TODO: error?</p>
</div>
<div class="paragraph">
<p>Do we resolve simple names to top-level symbols in root package?</p>
</div>
<div class="paragraph">
<p>Repeat steps from the last case.</p>
</div>
<div class="paragraph">
<p>2 imports ends on the same identifier - error</p>
</div>
<div class="paragraph">
<p>if class found in 2 modules - select one, and import its constructors</p>
</div>
<div class="paragraph">
<p>all props and funs imported all with the same priority</p>
</div>
<div class="paragraph">
<p>ambiguous classes in type position?</p>
</div>
<div class="paragraph">
<p>fqn vs. canonical in java</p>
</div>
<div class="paragraph">
<p>stop package at generic arguments</p>
</div>
<div class="paragraph">
<p>TODO: members from default package</p>
</div>
<div class="paragraph">
<p>How do we place annotations for the element type int in the array type int[]?</p>
</div>
<div class="paragraph">
<p>If overriding member does not specify visibility and all overridden members have the same visibility (or there is only one overridden member), then the overriding method inherits that visibility. If not all overridden members have the same visibility, then the overriding method must specify it visibility explicitly, otherwise a compile-time error occurs. (TODO: verify this)</p>
</div>
<div class="sect2">
<h3 id="_import_directive_priorities">23.1. Import Directive Priorities</h3>
<div class="paragraph">
<p>Import directives priorities (from highest to lowest):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Explicit user imports</p>
</li>
<li>
<p>Current package symbols</p>
</li>
<li>
<p>Top-level packages</p>
</li>
<li>
<p>Explicit default imports</p>
</li>
<li>
<p>User imports with "*"</p>
</li>
<li>
<p>Default imports with "*"</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_anonymous_types_in_public_api">23.2. Anonymous Types in Public API</h3>
<div class="paragraph">
<p>Methods and properties can return anonymous type originating from object literals, or generic types constructed with anonymous types. These type are not denotable. In Java interop scenarios anonymous types are replaced with their first declared supertype, or Any if no supertype is specified. It potentially can result in type safety violations and heap pollution if, for example, Java overrides a method returning an anonymous type, and because the override return type is Any, it can return an object of unrelated type, that will be visible in Kotlin as an object of the anonymous types. Because JVM enforces type safety on a lower level, such scenarios will usually eventually result in CastClassException or ArrayStoreException, but it can occur in a distant position in code and may be difficult to debug.</p>
</div>
</div>
<div class="sect2">
<h3 id="_scripting">23.3. Scripting</h3>
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p>Importing a script means running it (if it has not been run before) and importing its symbols into the current scope. Imports may be allowed not only on the top of the file, but in other places of the program in the program. Script is similar to normal sequence of top-level declarations as they appear on top-level in a file, but may also contain executable statements between them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_misc">23.4. Misc</h3>
<div class="paragraph">
<p>TODO: <code>@setparam:</code></p>
</div>
<div class="paragraph">
<p>The declared visibility of an override must be not less than the declared visibility of the overridden member (TODO: declared includes default).</p>
</div>
<div class="paragraph">
<p>Local functions and local classes cannot have visibility modifiers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>9.4.1.3 Inheriting Methods with Override-Equivalent Signatures</p>
</li>
<li>
<p><code>operator</code> is inherited (at least one inheritance path is enough)</p>
</li>
<li>
<p>TODO: parameter names in functional types, no vararg, no duplicate parameter names in functional types, do we resolve to them in annotations?</p>
</li>
<li>
<p>local functions can be operators</p>
</li>
<li>
<p>TODO: no non-public set in interfaces</p>
</li>
<li>
<p>TODO: named arguments are not allowed for function types (both in () and .invoke() invocations)</p>
</li>
<li>
<p>TODO: top-level non-extension invoke cannot be operator (packageName() is not allowed)</p>
</li>
<li>
<p>TODO: x[i] is not translated to x.get.invoke(), because property get cannot be operator; function parameter or local cannot be operator</p>
</li>
<li>
<p>TODO: super.foo cannot refer to abstract member</p>
</li>
<li>
<p>TODO: arguments can be renamed in overrides, invocation uses name from static type of the target</p>
</li>
<li>
<p>TODO: an overriding function cannot provide default values for its parameters, they are always inherited. No more than 1 overridden declaration is allowed to provide a default value (even if values are identical)</p>
</li>
<li>
<p>TODO: order of evaluation for constants: topo sorting, no cycles</p>
</li>
<li>
<p>TODO: val property can be overridden by var property, but not vice versa</p>
</li>
<li>
<p>TODO: no private abstract accessors in properties</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A class can inherit multiple methods with the same signature, but unrelated return types, provided that it is abstract or overrides them with a method that is a subtype of all those return types (there is always at least one such type, namely Nothing).</p>
</div>
<div class="paragraph">
<p>When compiling to JVM, the name DefaultImpls in reserved in interfaces that provide default implementations for functional members. This name is used for nested class that is exposed to Java and contains the default implementations.</p>
</div>
<div class="paragraph">
<p>TODO: Spec DefaultImpls nested class, including representation of methods in generic interfaces (dependencies between type-parameters).</p>
</div>
<div class="paragraph">
<p>TODO: Spec <code>lateinit</code> properties (only var). There is no direct way to check if a lateinit property is already initialized (a workaround it to try to read from it and catch an exception), and there is no way to uninitialize it (set it to null to release a reference to an object). <code>kotlin.UninitializedPropertyAccessException</code>. The property type cannot be primitive or nullable type.
TODO: Spec null safety and possible violations</p>
</div>
<div class="paragraph">
<p>TODO: Spec heap pollution</p>
</div>
<div class="paragraph">
<p>TODO: Do we copy annotation from default implementations in interfaces to corresponding classes?</p>
</div>
<div class="paragraph">
<p>TODO: Synchronized in interfaces?</p>
</div>
<div class="paragraph">
<p>TODO: Spec const vals</p>
</div>
<div class="paragraph">
<p>TODO: Generic anonymous objects / local classes, out-projections?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun main(args: Array&lt;String&gt;) {
    fun f&lt;T&gt;(x : T) = object { val X = x };
    val s = listOf(f(1), f(""))
    val y = s[0].X
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO: pre- and postfix increment/decrement operators</p>
</div>
<div class="paragraph">
<p>TODO: (x is Int?) Nullable mark is redundant here and results in a warning.</p>
</div>
<div class="paragraph">
<p>TODO: @KotlinOperator and @KotlinInfix annotations for Java interop</p>
</div>
<div class="paragraph">
<p>Properties declared in parameter declarations cannot be <code>abstract</code> or <code>external</code>.</p>
</div>
<div class="paragraph">
<p>Modifier <code>abstract</code> is not applicable to property accessors.</p>
</div>
<div class="paragraph">
<p>Cannot have constraints both in <code>&lt;&#8230;&#8203;&gt;</code> and in <code>where</code>.</p>
</div>
<div class="paragraph">
<p>object instance is exposed to Java as INSTANCE field, for nested classed, also as class name</p>
</div>
<div class="paragraph">
<p>Only <code>is Array&lt;*&gt;</code></p>
</div>
<div class="paragraph">
<p>It is a suppressible error if an override changes parameter name from a superclass.</p>
</div>
<div class="paragraph">
<p>TODO: precedence between synthetic and extension member (e.g. <code>Runnable</code> vs. <code>Functional</code>); discrimination levels?
TODO: spec <code>Runnable { &#8230;&#8203; }</code></p>
</div>
<div class="paragraph">
<p>TODO: <code>vararg</code> can declare <code>Array&lt;Xxx&gt;</code> or <code>XxxArray</code>.</p>
</div>
<div class="paragraph">
<p>TODO: It is an error, if return type of <code>++</code>, <code>--</code> operators is not a subtype of their argument variable:
[Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>operator fun Any?.inc() : Any? = null

fun f() {
    var x = ""
    x++
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>End Example]</p>
</div>
<div class="paragraph">
<p>TODO: it is an error if a signature with <code>vararg</code> modifier overrides a signature without <code>vararg</code> modifier, or a signature without <code>vararg</code> modifier overrides a signature with <code>vararg</code> modifier. It is an error to inherit override-equivalent signatures that differ in <code>vararg</code> modifiers.</p>
</div>
<div class="sect3">
<h4 id="_method_overriding">23.4.1. Method Overriding</h4>
<div class="paragraph">
<p>[Examples</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo()
}

interface B : A // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface B inherits abstract method foo from its superinterface A.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo() { println() }
}

interface B : A // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface B inherits concrete method foo from its superinterface A.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo()
}

interface B {
    fun foo()
}

interface C : A, B // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface C inherits 2 abstract methods foo with the same signature from difference superinterfaces A and B.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo() { println() }
}

interface B {
    fun foo()
}

interface C : A, B // ERROR</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface C inherits multiple methods foo with the same signature from difference superinterfaces A and B, and there
is at least 1 concrete method among them. This results in an error.</p>
</div>
<div class="paragraph">
<p>The error can be resolved by declaring in the interface C an abstract or concrete method foo with the same signature
that overrides all inherited methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo() { println() }
}

interface B {
    fun foo()
}

interface C : A, B {
    override fun foo(); // OK
}</code></pre>
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo() { println() }
}

interface B : A {
    override fun foo()
}

interface C {
    fun foo()
}

interface D : A, B // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface D has superinterfaces that declare multiple methods foo with the same signature, but all concrete methods
are already overridden in the superinterfaces.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo() { println() }
}

interface B {
    fun foo()
}

interface C : A, B {
    override fun foo() { println() }
}

interface D : A, B, C // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface D has superinterfaces that declare multiple methods foo with the same signature, but there is a single
concrete method that already overrides all other methods.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo(x: String)
}

interface B&lt;T&gt; : A {
    fun foo(x: T) { println() }
}

interface C : A, B&lt;String&gt; // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a more tricky example involving generics. Although the declaration of the method foo in B&lt;T&gt; does not override
the method foo from A at its declaration, it nevertheless overrides it in the particular instantiation B&lt;String&gt; that is
inherited by C, so the interface C does not inherit conflicting methods.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo()
}

open class B {
    fun foo() { println() }
}

class C : B(), A // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rules for inheritance from superclass are different. The class C inherits the single concrete method foo from its superclass,
and also have a superinterface (or multiple superinterfaces) that declares abstract methods with the same signature.
In this case no error occurs, and the concrete method from the superclass overrides all abstract methods from superinterfaces.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo() { println() }
}

abstract class B {
    abstract fun foo()
}

abstract class C : B(), A // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the class C inherits the abstract method from its superclass, and it also overrides all methods from superinterfaces (abstract or concrete). The class C must have the <code>abstract</code> modifier, because it contains an abstract method.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo() { println() }
}

abstract class B {
    abstract fun foo()
}

class C : B(), A // ERROR</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case an error occurs, because the class C is not marked abstract.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface A {
    fun foo()
}

abstract class B : A

interface C : A {
    override fun foo() {
        println("C.foo")
    }
}

class D : B(), C // OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class B inherits abstract method foo from the interface B. The interface C overrides that method with a concrete method foo. The class D does not inherited the abstract method foo from its superclass, because it is already overridden by its superinterface C. Instead, the class D inherits the implementation of foo from C.</p>
</div>
<div class="paragraph">
<p>End Examples]</p>
</div>
<div class="paragraph">
<p>@JvmField can be applied to properties with backing fields (in particular, non-extensions). Not in an interface companion object.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO: infix decl restrictions: member/extension, 1 parameter, non-default, non-vararg</p>
</li>
<li>
<p>TODO: string interpolation, last character can be $. Interpolation starts after unescaped $ followed by identifier, reserved keyword, full <code>&#8230;&#8203;</code> identifier (not just ``) or {.</p>
</li>
<li>
<p>TODO: no super for extension member invocations</p>
</li>
<li>
<p>TODO: @JvmName is not applicable to non-final functions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TODO: Locals win over members, even if members are declared closer to the usage (a class declaration can be nested within a method body).
[Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun foo(bar: Bar) = object {
    val bar = bar // The bar on the right-hand side refers to the parameter bar
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>End Example]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO: intersection types and captured types leaking from (possibly nested) generic invocations to local variables.</p>
</li>
<li>
<p>TODO: (possible generic) extension method invocations on numeric literals 3.foo()</p>
</li>
<li>
<p>TODO: operands of compound assignments are evaluated only once.</p>
</li>
<li>
<p>TODO: invokeExtension convention.</p>
</li>
<li>
<p>TODO: conflict between nested constructor and synthetic valuesOf()</p>
</li>
<li>
<p>TODO: <code>public fun foo() = if(true) this else null;</code>&#8201;&#8212;&#8201;ERROR. type is private anonymous</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A function declaration can omit a specification of the return type, if the return type can be inferred from the function body, and the function body can be resolved without using any information about the return type. In particular, the return type specification cannot be omitted if the function is implemented recursively.</p>
</div>
<div class="paragraph">
<p>TODO: Comma-separated conditions are not allowed in <code>when</code> without argument. [Rationale: Commas can be confused with logical AND, but would mean OR if were allowed in this context. So, we require to use explicit <code>&amp;&amp;</code> or <code>||</code> operators if needed. End Rationale]</p>
</div>
<div class="paragraph">
<p>TODO: All token consisting of dots only (<code>.</code>, <code>..</code>, <code>&#8230;&#8203;</code>, etc.) are reserved. Currently only <code>.</code> and <code>..</code> can be used in valid programs. [Rationale: Without this rule expressions like <code>1&#8230;&#8203;2</code> would be parsed as <code>1 .. .2</code>&#8201;&#8212;&#8201;that has been proven to be confusing for some users. It also looks plausible that the token <code>&#8230;&#8203;</code> might be used in future versions of the language. End Rationale]</p>
</div>
<div class="paragraph">
<p>TODO: $ has special meaning in strings if both of the following are true:
* it does not immediately follow an unescaped backslash
* it is immediately followed by an identifier or keyword (in case the identifier is escaped, it must have opening and closing backtick
and non-empty body.)</p>
</div>
<div class="paragraph">
<p>TODO: Java package-local can be used in signatures of internal members declared in Kotlin (<a href="https://youtrack.jetbrains.com/issue/KT-9623" class="bare">https://youtrack.jetbrains.com/issue/KT-9623</a>).</p>
</div>
<div class="paragraph">
<p>TODO: @JvmSuppressWildcards(true).</p>
</div>
<div class="paragraph">
<p>TODO: @JvmStatic for overrides?</p>
</div>
<div class="paragraph">
<p>TODO: Parameter name vs. property name in init blocks and property initializers
TODO: Do not create raw type when Nothing
TODO: Array&#8217;s type-parameter is not reified anymore. What do we do with Array&lt;Nothing&gt;.</p>
</div>
<div class="paragraph">
<p>When applicable candidate members are compared for "betterness", for each explicitly provided argument, types of parameters corresponding to that argument are compared (irrespectively to whether they appear on the same position in method signatures). Type of parameters for which default values where automatically provided do not participate in "betterness" comparison.</p>
</div>
<div class="paragraph">
<p>Extension method with a receiver of numeric type is applicable on a literal receiver, even if the literal type does not match the received type exactly, but could be converted to it if it appeared in a regular argument position. E.g. fun Long.foo() can be applicable in 4.foo() invocation.</p>
</div>
<div class="paragraph">
<p>TODO: rename multi-declaration to destructuring  declarations, spec destructuring  declarations in for loops.</p>
</div>
<div class="paragraph">
<p>TODO: inline public API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>object X {
    private fun foo() {}
    public inline fun bar(x : () -&gt; Unit)
    {
        foo() // Public-API inline function cannot access non-public-API 'private final fun foo(): Unit defined in X'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule also extends to any nested object literals and default values of parameters.</p>
</div>
<div class="paragraph">
<p>TODO: companion object inherits from a class with companion object&#8201;&#8212;&#8201;it not transitive.
TODO: equals(null) &#8658; true</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun f() : Unit {
    return 1 // Error
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Out&lt;In&lt;Out&lt;Open&gt;&gt;&gt;&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO: Scala rules for primary ctors scopes</p>
</li>
<li>
<p>TODO: Accessibility constrains for delegated interfaces</p>
</li>
<li>
<p>TODO: order of evaluation between delegation expression and superclass arguments</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TODO: val properties must be assigned on all control-flow paths:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>class C {
    val a: Int
    init {
        if(true) {
            a = 3
        }
        else {
            a = 5
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a class declares or inherits at least one abstract functional member, the class must be declared abstract.</p>
</div>
</div>
<div class="sect3">
<h4 id="_intersection_types">23.4.2. Intersection types</h4>
<div class="paragraph">
<p>An intersection type is a special type that is not syntactically denotable in the language, but can arise during typechecking or type inference for certain expressions. We will denote an intersection type as <code>T1 &amp; T2 &amp; &#8230;&#8203; &amp; Tn</code> in the specification (but note that this is not a proper language syntax).</p>
</div>
<div class="paragraph">
<p>A particular method to be invoked is determined not only by the method name specified in an invocation, but is also affected by two mechanisms: method overloading and method overriding. Method overloading is an ability to declare multiple methods with the same name in the same declaration space that differ by their signatures, and to select at compile-time a particular signature to invoke based on arguments specified in an invocation. Method overriding is an ability to provide multiple implementations for the same method signature at different levels of inheritance (or interface implementation) hierarchy, and to select at run-time a particular implementation to invoke bases on the exact run-time type of the object whose method is being invoked.</p>
</div>
<div class="paragraph">
<p>Method overloading happens an compile-time and consists of several steps as described below. First, a set of visible methods with the same name is formed by a name lookup. Visibility of a particular method is determined based on its effective visibility and the location is source where the method invocation occurs. Second, applicable</p>
</div>
</div>
<div class="sect3">
<h4 id="_priority_of_candidates">23.4.3. Priority of candidates</h4>
<div class="paragraph">
<p>In general, a method invocation expression is enclosed in a linear hierarchy of nested scopes, each of those can introduce methods, extension methods and implicit receivers. In addition, each level of the hierarchy can introduce multiple methods, overloaded by signature. When a method invocation has a form of a simple name followed by an argument list, the simple name can, in general, denote either a local function, a member function or an extension function (in the latter case the extension function can be local or member). Before an overload resolution can be performed, a set of candidate functions has to be formed. Not all potentially applicable functions from all level are collected together. Instead, functions are grouped by their priority, and the groups are considered from highest priority to lowest, until a group that has at least one potentially applicable candidate is found. The hierarchy of priorities is not a simple copy of the hierarchy of nested scopes. Instead, it may contain multiple subhierarchies, each of them reflecting the hierarchy of nested scopes. The reason for that is an extension function invocation requires both a dispatch receiver and an extension receiver (TODO: check terminology) to be determined, and this may require multiple traversals through the hierarchy of scopes. TODO: fill details from <a href="https://jetbrains.quip.com/BfYcA0ITQ9FM" class="bare">https://jetbrains.quip.com/BfYcA0ITQ9FM</a></p>
</div>
<div class="paragraph">
<p><a href="https://youtrack.jetbrains.com/issue/KT-11128" class="bare">https://youtrack.jetbrains.com/issue/KT-11128</a>
SAM-converted signatures are internally represented as extension methods on classes whose member their prototype is. So, they lose in overload resolution to  members with less specific signatures. SAM conversion only happens to members
declared in Java (not in Kotlin), so they never can be extensions by themselves. Generics methods are not SAM-convertible (CHECK).</p>
</div>
<div class="paragraph">
<p>TODO: <a href="https://youtrack.jetbrains.com/issue/KT-7052" class="bare">https://youtrack.jetbrains.com/issue/KT-7052</a> (check corresponding Java rules).</p>
</div>
<div class="paragraph">
<p>"multi-declaration" &#8658; "destructuring"</p>
</div>
<div class="paragraph">
<p>[Note: In a situation when a method declared in Java has reference types in its signature, and needs to be overridden in Kotlin, in general it is not possible for the compiler to know whether any of those types were intended to have the <code>null</code> reference as one of their valid values. Still, this information may be known to the programmer from the documentation or by other means. So, the intended type in the overriding method&#8217;s signature may be either a non-nullable reference type or the corresponding nullable type. The programmer should be allowed to choose either of these alternative. Because the compiler cannot check the null-safety of the code in such cases, the responsibility for the correct choice lies with the programmer. End note] If a method declared in Java is overridden in Kotlin, and the original method declaration has reference types in its signature, then the overriding method is allowed to specify either non-nullable or nullable type at each occurrence of a reference type provided that, ignoring possible nullability, the specified type is the same type as the type in the corresponding position in the signature if the original method. If the method is further overridden in more derived types in Kotlin, those overriding methods must use the same types that where specified in the least derived override in written Kotlin.</p>
</div>
<div class="paragraph">
<p>TODO: discuss non-transitivity in subtyping in case { expr } &#8658; Unit &#8658; Unit?. See <a href="https://youtrack.jetbrains.com/issue/KT-7882" class="bare">https://youtrack.jetbrains.com/issue/KT-7882</a></p>
</div>
<div class="paragraph">
<p>The instance of a companion object is available within the immediately enclosing type as an implicit receiver, but
not as a qualified <code>this</code>. [Example: <a href="mailto:this@Companion.foo">this@Companion.foo</a>() is an error. End example]</p>
</div>
<div class="paragraph">
<p>Locals win.
[Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun bar(){
    fun foo() {
        class A {
            fun foo() {
                foo() // local foo() declared in top-level bar()
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>End example]</p>
</div>
<div class="paragraph">
<p>A local variable can shadow a name from an outer scope. The shadowing does not occur in its own initializer.</p>
</div>
<div class="paragraph">
<p>A label that is an argument to a function invocation can use the function name as a label for a return expression in its body.</p>
</div>
<div class="paragraph">
<p>Safe call operator e?.foo() normally promotes the result type of foo() to the corresponding nullable type, but if the type of e is non-nullable type or e is known to be not null due to a smart-cast, then a warning is issued that the . operator could be used instead of ?., and the result type of foo() is not promoted to the nullable type.</p>
</div>
<div class="paragraph">
<p>Parameters of a function (method, constructor, standalone function or an anonymous function) are always immutable variables. Catch parameters are always immutable variables</p>
</div>
<div class="paragraph">
<p>Values captured into local class declaration at the point of its declaration, rather than in the point of construction.
[Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>fun main(args: Array&lt;String&gt;) {
    var obj : Any? = null
    for (x in arrayOf(1, 2, 3)) {
        class C() {
            fun foo() = x
        }

        if(obj is C){
            println("$x, ${obj.foo()}")
        }
        obj = C()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This program prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>2, 1
3, 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>End example]</p>
</div>
<div class="paragraph">
<p>TODO: Order of evaluation top-level property initializers across multiple source files, effects of <code>inline</code>: <a href="https://jetbrains.slack.com/archives/kotlin-team/p1463993052000897" class="bare">https://jetbrains.slack.com/archives/kotlin-team/p1463993052000897</a></p>
</div>
<div class="paragraph">
<p>An upper bound of a type parameter cannot be an array, or an array projection.
[Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface C&lt;A, E&gt; where A : Array&lt;out E&gt; { } // Error</code></pre>
</div>
</div>
<div class="paragraph">
<p>End example]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO: coroutine modifier. Parameter must be of type <code>Controller.() -&gt; kotlin.coroutines.Coroutine&lt;Unit&gt;</code></p>
</li>
<li>
<p><code>coroutine</code> parameter of an <code>inline</code> function must be <code>noinline</code></p>
</li>
<li>
<p><code>coroutine</code> parameter cannot be <code>vararg</code></p>
</li>
<li>
<p>A signature can contain multiple <code>coroutine</code> parameters</p>
</li>
<li>
<p>A signature cannot contain more than 1 <code>coroutine</code> parameter</p>
</li>
<li>
<p>A non-function expression can be passed to a <code>coroutine parameter</code></p>
</li>
<li>
<p>A controller can be any type, including nullable type</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Nothing</code> has the same members as <code>Any</code>. None of these members can be actually invoked at run-time, and any such invocation is an unreachable code at compile-time.</p>
</div>
<div class="paragraph">
<p>If a type S is a supertype of a type T, then the nullable type S? is a supertype of the nullable type T?.
<code>Any</code> is a supertype of every class, object and interface type.</p>
</div>
<div class="paragraph">
<p>No class type except <code>Any</code> can be a supertype of an interface.</p>
</div>
<div class="paragraph">
<p>Subtyping relation is transitive: If a type S is a supertype of a type T, and the type T is a supertype of a type U, then the type S is a supertype of the type U.
Subtyping relation is irreflexive (strict): no type can be a supertype of itself. The corresponding non-strict reflexive relation is assignability. A type T is assignable to type S if either S is a supertype of T, or S is the same type as T.</p>
</div>
<div class="paragraph">
<p>TODO: define "sameness" for types. This is an equivalence relation, but unfortunately it is neither syntactically-based nor set-of-values-and-operations-on-them-based. The same type can have different syntactic forms. Two distinct types can have the same set of values and allow the same operations on those values.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-10-19 20:43:10 PDT
</div>
</div>
</body>
</html>