= Type system

[glossary]
== Glossary

[glossary]
`T`:: Type
`T!!`:: Non-nullable type
`T?`:: Nullable type
`{T!!}`:: Universe of non-nullable types
`{T?}`:: Universe of nullable types
stem:[\langle T\rangle]:: Value of type stem:[T]

== Introduction

Kotlin has a type system with the following main properties:

* hybrid static and gradual type checking
* null safety
* no unsafe implicit conversions
* unified root type
* nominal subtyping with bounded parametric polymorphism

TODO(static type checking, gradual type checking)

Null safety is enforced by having two type universes --- _nullable_ (with nullable types `T?`) and _non-nullable_ (with non-nullable types `T!!`). All operations footnote:[Except for TODO()] which are allowed on nullable types are safe, i.e., should never cause a runtime null pointer error.

Implicit conversions between types in Kotlin are limited to safe upcasts w.r.t. subtyping, meaning all other (unsafe) conversions must be explicit, done via either a conversion function or an <<Cast expression,explicit cast>>. However, Kotlin also supports smart casts --- a special kind of implicit conversions which are safe w.r.t. program control- and data-flow, which are covered in more detail <<Smart casts,here>>.

The unified supertype type for all types in Kotlin is `kotlin.Any?`, a nullable version of <<kotlin.Any>>.

Kotlin uses nominal subtyping, meaning subtyping relation is defined when a type is declared, with bounded parametric polymorphism, implemented as <<Generics,generics>>.

== Built-in types

Kotlin type system uses the following built-in types, which have special semantics and representation (or lack thereof).

=== `kotlin.Any` [[kotlin.Any]]

`kotlin.Any` is the unified supertype (stem:[\top]) for `{T!!}`, i.e., all types are subtypes of `kotlin.Any`, either explicitly, implicitly, or by transitivity of subtyping relation.

=== `kotlin.Nothing` [[kotlin.Nothing]]

`kotlin.Nothing` is the unified subtype (stem:[\bot]) for `{T!!}`, i.e., `kotlin.Nothing` is a subtype of all non-nullable types, including user-defined ones. This makes it an uninhabited type (as it is impossible for anything to be a function and an integer at the same time), meaning instances of this type can never exist at runtime; subsequently, there is no way to create an instance of `kotlin.Nothing` in Kotlin.

As the evaluation of an expression with `kotlin.Nothing` type can never complete normally, it is used to mark special situations, such as:

* non-terminating expressions
* exceptional control flow
* control flow transfer

=== `kotlin.Unit` [[kotlin.Unit]]

`kotlin.Unit` is a unit type, i.e., a type with only one value `kotlin.Unit`; all values of type `kotlin.Unit` should reference the same underlying `kotlin.Unit` object.

TODO(Compare to `void`)

== Nullability

Kotlin supports null safety by having two kinds of types --- nullable and non-nullable. All type declarations, built-in or user-defined, create non-nullable types, i.e., types which cannot hold `null` value at runtime.

To specify a nullable version of type `Foo`, one needs to use `Foo?` as a type. Redundant nullability specifiers are ignored --- `Foo???` is equivalent to `Foo?`.

NOTE: Informally, question mark means "`T?` may hold values of type T or value `null`"

If an operation is safe regardless of absence or presence of `null`, i.e., assignment of one nullable value to another, it can be used as-is for nullable types. For operations on `T?` which may violate null safety, one has the following null-safe options:

. Use safe operations
* <<Safe call expression,safe call>>
. Downcast from `T?` to `T!!`
* <<Cast expression,unsafe cast>>
* <<Type check expression,type check>> combined with <<Smart casts,smart casts>>
* Null check combined with <<Smart casts,smart casts>>
* <<Not-null assertion operator expression,not-null assertion operator>>
. Supply a default value to use instead of `null`
* <<Elvis operator expression,elvis operator>>

== Flexible types

Kotlin, being a multi-platform language, should support transparent interoperability with platform-dependent code. However, this presents a problem in that some platforms may not support null safety the way Kotlin does. To deal with this, Kotlin supports _gradual typing_ in the form of *flexible types*.

A flexible type represents a range of possible types between type `A` (lower bound) and type `B` (upper bound), written as `(A..B)`. One should note flexible types are non-denotable, i.e., one cannot explicitly declare a variable with flexible type, these types are created by the type system when needed.

To represent a valid flexible type, `(A..B)` should satisfy the following conditions:

* `A <: B`
* `not (B <: A)`
* `A` and `B` are *not* flexible types

== Platform types

TODO(Platform types as flexible types)
TODO(Reference different platforms)

== Subtyping

`<:`

== Generics

TODO(Here be a lot of dragons)
