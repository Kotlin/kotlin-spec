<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marat Akhin" />
  <meta name="author" content="Mikhail Belyaev" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../resources/css/main.css">
  <link rel="stylesheet" href="../resources/js/katex/katex.min.css">
  <script src="../resources/js/katex/katex.min.js"></script><script src="../resources/js/katex/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="../resources/js/katex/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script data-main="resources/js/main" src="https://requirejs.org/docs/release/2.3.6/minified/require.js"></script>
  <script>
      requirejs.config({
          waitSeconds: 10000
      });
  </script>
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
<p class="author">Marat Akhin</p>
<p class="author">Mikhail Belyaev</p>
</header>



























<div id="TOC">
<ul>
<li><a href="kotlincore.html#kotlincore" id="toc-element-kotlincore" class="toc-element">Kotlin/Core</a>
<ul>
<li><a href="introduction.html#introduction" id="toc-element-introduction" class="toc-element unnumbered">Introduction</a>
<ul>
<li><a href="introduction.html#feedback" id="toc-element-feedback" class="toc-element unnumbered">Feedback</a></li>
</ul></li>
<li><a href="syntax-and-grammar.html#syntax-and-grammar" id="toc-element-syntax-and-grammar" class="toc-element">Syntax and grammar</a>
<ul>
<li><a href="syntax-and-grammar.html#lexical-grammar" id="toc-element-lexical-grammar" class="toc-element">Lexical grammar</a>
<ul>
<li><a href="syntax-and-grammar.html#whitespace-and-comments" id="toc-element-whitespace-and-comments" class="toc-element">Whitespace and comments</a></li>
<li><a href="syntax-and-grammar.html#keywords-and-operators" id="toc-element-keywords-and-operators" class="toc-element">Keywords and operators</a></li>
<li><a href="syntax-and-grammar.html#literals" id="toc-element-literals" class="toc-element">Literals</a></li>
<li><a href="syntax-and-grammar.html#identifiers" id="toc-element-identifiers" class="toc-element">Identifiers</a></li>
<li><a href="syntax-and-grammar.html#string-mode-grammar" id="toc-element-string-mode-grammar" class="toc-element">String mode grammar</a></li>
<li><a href="syntax-and-grammar.html#tokens" id="toc-element-tokens" class="toc-element">Tokens</a></li>
</ul></li>
<li><a href="syntax-and-grammar.html#syntax-grammar" id="toc-element-syntax-grammar" class="toc-element">Syntax grammar</a></li>
<li><a href="syntax-and-grammar.html#documentation-comments" id="toc-element-documentation-comments" class="toc-element">Documentation comments</a></li>
</ul></li>
<li><a href="type-system.html#type-system" id="toc-element-type-system" class="toc-element">Type system</a>
<ul>
<li><a href="type-system.html#glossary" id="toc-element-glossary" class="toc-element unnumbered">Glossary</a></li>
<li><a href="type-system.html#introduction-1" id="toc-element-introduction-1" class="toc-element unnumbered">Introduction</a></li>
<li><a href="type-system.html#type-kinds" id="toc-element-type-kinds" class="toc-element">Type kinds</a>
<ul>
<li><a href="type-system.html#built-in-types" id="toc-element-built-in-types" class="toc-element">Built-in types</a>
<ul>
<li><a href="type-system.html#kotlin.any" id="toc-element-kotlin.any" class="toc-element"><code>kotlin.Any</code></a></li>
<li><a href="type-system.html#kotlin.nothing" id="toc-element-kotlin.nothing" class="toc-element"><code>kotlin.Nothing</code></a></li>
<li><a href="type-system.html#kotlin.function" id="toc-element-kotlin.function" class="toc-element"><code>kotlin.Function</code></a></li>
<li><a href="type-system.html#built-in-integer-types" id="toc-element-built-in-integer-types" class="toc-element">Built-in integer types</a></li>
<li><a href="type-system.html#array-types" id="toc-element-array-types" class="toc-element">Array types</a></li>
</ul></li>
<li><a href="type-system.html#classifier-types" id="toc-element-classifier-types" class="toc-element">Classifier types</a>
<ul>
<li><a href="type-system.html#simple-classifier-types" id="toc-element-simple-classifier-types" class="toc-element">Simple classifier types</a></li>
<li><a href="type-system.html#parameterized-classifier-types" id="toc-element-parameterized-classifier-types" class="toc-element">Parameterized classifier types</a></li>
</ul></li>
<li><a href="type-system.html#type-parameters" id="toc-element-type-parameters" class="toc-element">Type parameters</a>
<ul>
<li><a href="type-system.html#function-type-parameters" id="toc-element-function-type-parameters" class="toc-element">Function type parameters</a></li>
<li><a href="type-system.html#mixed-site-variance" id="toc-element-mixed-site-variance" class="toc-element">Mixed-site variance</a></li>
<li><a href="type-system.html#declaration-site-variance" id="toc-element-declaration-site-variance" class="toc-element">Declaration-site variance</a></li>
<li><a href="type-system.html#use-site-variance" id="toc-element-use-site-variance" class="toc-element">Use-site variance</a></li>
</ul></li>
<li><a href="type-system.html#type-capturing" id="toc-element-type-capturing" class="toc-element">Type capturing</a></li>
<li><a href="type-system.html#type-containment" id="toc-element-type-containment" class="toc-element">Type containment</a></li>
<li><a href="type-system.html#function-types" id="toc-element-function-types" class="toc-element">Function types</a>
<ul>
<li><a href="type-system.html#suspending-function-types" id="toc-element-suspending-function-types" class="toc-element">Suspending function types</a></li>
</ul></li>
<li><a href="type-system.html#flexible-types" id="toc-element-flexible-types" class="toc-element">Flexible types</a>
<ul>
<li><a href="type-system.html#dynamic-type" id="toc-element-dynamic-type" class="toc-element">Dynamic type</a></li>
<li><a href="type-system.html#platform-types" id="toc-element-platform-types" class="toc-element">Platform types</a></li>
</ul></li>
<li><a href="type-system.html#nullable-types" id="toc-element-nullable-types" class="toc-element">Nullable types</a>
<ul>
<li><a href="type-system.html#nullability-lozenge" id="toc-element-nullability-lozenge" class="toc-element">Nullability lozenge</a></li>
</ul></li>
<li><a href="type-system.html#intersection-types" id="toc-element-intersection-types" class="toc-element">Intersection types</a></li>
<li><a href="type-system.html#integer-literal-types" id="toc-element-integer-literal-types" class="toc-element">Integer literal types</a></li>
<li><a href="type-system.html#union-types" id="toc-element-union-types" class="toc-element">Union types</a></li>
</ul></li>
<li><a href="type-system.html#type-contexts-and-scopes" id="toc-element-type-contexts-and-scopes" class="toc-element">Type contexts and scopes</a>
<ul>
<li><a href="type-system.html#inner-and-nested-type-contexts" id="toc-element-inner-and-nested-type-contexts" class="toc-element">Inner and nested type contexts</a></li>
</ul></li>
<li><a href="type-system.html#subtyping" id="toc-element-subtyping" class="toc-element">Subtyping</a>
<ul>
<li><a href="type-system.html#subtyping-rules" id="toc-element-subtyping-rules" class="toc-element">Subtyping rules</a></li>
<li><a href="type-system.html#subtyping-for-flexible-types" id="toc-element-subtyping-for-flexible-types" class="toc-element">Subtyping for flexible types</a></li>
<li><a href="type-system.html#subtyping-for-intersection-types" id="toc-element-subtyping-for-intersection-types" class="toc-element">Subtyping for intersection types</a></li>
<li><a href="type-system.html#subtyping-for-integer-literal-types" id="toc-element-subtyping-for-integer-literal-types" class="toc-element">Subtyping for integer literal types</a></li>
<li><a href="type-system.html#subtyping-for-nullable-types" id="toc-element-subtyping-for-nullable-types" class="toc-element">Subtyping for nullable types</a></li>
</ul></li>
<li><a href="type-system.html#upper-and-lower-bounds" id="toc-element-upper-and-lower-bounds" class="toc-element">Upper and lower bounds</a>
<ul>
<li><a href="type-system.html#least-upper-bound" id="toc-element-least-upper-bound" class="toc-element">Least upper bound</a></li>
<li><a href="type-system.html#greatest-lower-bound" id="toc-element-greatest-lower-bound" class="toc-element">Greatest lower bound</a></li>
</ul></li>
<li><a href="type-system.html#type-approximation" id="toc-element-type-approximation" class="toc-element">Type approximation</a></li>
<li><a href="type-system.html#type-decaying" id="toc-element-type-decaying" class="toc-element">Type decaying</a></li>
<li><a href="type-system.html#references" id="toc-element-references" class="toc-element unnumbered">References</a></li>
</ul></li>
<li><a href="built-in-types-and-their-semantics.html#built-in-types-and-their-semantics" id="toc-element-built-in-types-and-their-semantics" class="toc-element">Built-in types and their semantics</a>
<ul>
<li><a href="built-in-types-and-their-semantics.html#kotlin.any-1" id="toc-element-kotlin.any-1" class="toc-element"><code>kotlin.Any</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.nothing-1" id="toc-element-kotlin.nothing-1" class="toc-element"><code>kotlin.Nothing</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.unit" id="toc-element-kotlin.unit" class="toc-element"><code>kotlin.Unit</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.boolean" id="toc-element-kotlin.boolean" class="toc-element"><code>kotlin.Boolean</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#built-in-integer-types-1" id="toc-element-built-in-integer-types-1" class="toc-element">Built-in integer types</a>
<ul>
<li><a href="built-in-types-and-their-semantics.html#integer-type-widening" id="toc-element-integer-type-widening" class="toc-element">Integer type widening</a></li>
</ul></li>
<li><a href="built-in-types-and-their-semantics.html#built-in-floating-point-arithmetic-types" id="toc-element-built-in-floating-point-arithmetic-types" class="toc-element">Built-in floating point arithmetic types</a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.char" id="toc-element-kotlin.char" class="toc-element"><code>kotlin.Char</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.string" id="toc-element-kotlin.string" class="toc-element"><code>kotlin.String</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.enum" id="toc-element-kotlin.enum" class="toc-element"><code>kotlin.Enum</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#built-in-array-types" id="toc-element-built-in-array-types" class="toc-element">Built-in array types</a>
<ul>
<li><a href="built-in-types-and-their-semantics.html#specialized-array-types" id="toc-element-specialized-array-types" class="toc-element">Specialized array types</a></li>
</ul></li>
<li><a href="built-in-types-and-their-semantics.html#iterator-types" id="toc-element-iterator-types" class="toc-element">Iterator types</a>
<ul>
<li><a href="built-in-types-and-their-semantics.html#specialized-iterator-types" id="toc-element-specialized-iterator-types" class="toc-element">Specialized iterator types</a></li>
</ul></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.throwable" id="toc-element-kotlin.throwable" class="toc-element"><code>kotlin.Throwable</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.comparable" id="toc-element-kotlin.comparable" class="toc-element"><code>kotlin.Comparable</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.function-1" id="toc-element-kotlin.function-1" class="toc-element"><code>kotlin.Function</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#built-in-annotation-types" id="toc-element-built-in-annotation-types" class="toc-element">Built-in annotation types</a></li>
<li><a href="built-in-types-and-their-semantics.html#reflection-support-builtin-types" id="toc-element-reflection-support-builtin-types" class="toc-element">Reflection support builtin types</a>
<ul>
<li><a href="built-in-types-and-their-semantics.html#kotlin.reflect.kclass" id="toc-element-kotlin.reflect.kclass" class="toc-element"><code>kotlin.reflect.KClass</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.reflect.kcallable" id="toc-element-kotlin.reflect.kcallable" class="toc-element"><code>kotlin.reflect.KCallable</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.reflect.kproperty" id="toc-element-kotlin.reflect.kproperty" class="toc-element"><code>kotlin.reflect.KProperty</code></a></li>
<li><a href="built-in-types-and-their-semantics.html#kotlin.reflect.kfunction" id="toc-element-kotlin.reflect.kfunction" class="toc-element"><code>kotlin.reflect.KFunction</code></a></li>
</ul></li>
</ul></li>
<li><a href="declarations.html#declarations" id="toc-element-declarations" class="toc-element">Declarations</a>
<ul>
<li><a href="declarations.html#glossary-1" id="toc-element-glossary-1" class="toc-element unnumbered">Glossary</a></li>
<li><a href="declarations.html#introduction-2" id="toc-element-introduction-2" class="toc-element unnumbered">Introduction</a></li>
<li><a href="declarations.html#classifier-declaration" id="toc-element-classifier-declaration" class="toc-element">Classifier declaration</a>
<ul>
<li><a href="declarations.html#class-declaration" id="toc-element-class-declaration" class="toc-element">Class declaration</a>
<ul>
<li><a href="declarations.html#constructor-declaration" id="toc-element-constructor-declaration" class="toc-element">Constructor declaration</a></li>
<li><a href="declarations.html#nested-and-inner-classifiers" id="toc-element-nested-and-inner-classifiers" class="toc-element">Nested and inner classifiers</a></li>
<li><a href="declarations.html#inheritance-delegation" id="toc-element-inheritance-delegation" class="toc-element">Inheritance delegation</a></li>
<li><a href="declarations.html#abstract-classes" id="toc-element-abstract-classes" class="toc-element">Abstract classes</a></li>
</ul></li>
<li><a href="declarations.html#data-class-declaration" id="toc-element-data-class-declaration" class="toc-element">Data class declaration</a></li>
<li><a href="declarations.html#enum-class-declaration" id="toc-element-enum-class-declaration" class="toc-element">Enum class declaration</a></li>
<li><a href="declarations.html#annotation-class-declaration" id="toc-element-annotation-class-declaration" class="toc-element">Annotation class declaration</a></li>
<li><a href="declarations.html#interface-declaration" id="toc-element-interface-declaration" class="toc-element">Interface declaration</a>
<ul>
<li><a href="declarations.html#functional-interface-declaration" id="toc-element-functional-interface-declaration" class="toc-element">Functional interface declaration</a></li>
</ul></li>
<li><a href="declarations.html#object-declaration" id="toc-element-object-declaration" class="toc-element">Object declaration</a></li>
<li><a href="declarations.html#classifier-initialization" id="toc-element-classifier-initialization" class="toc-element">Classifier initialization</a></li>
</ul></li>
<li><a href="declarations.html#function-declaration" id="toc-element-function-declaration" class="toc-element">Function declaration</a>
<ul>
<li><a href="declarations.html#function-signature" id="toc-element-function-signature" class="toc-element">Function signature</a></li>
<li><a href="declarations.html#named-positional-and-default-parameters" id="toc-element-named-positional-and-default-parameters" class="toc-element">Named, positional and default parameters</a></li>
<li><a href="declarations.html#variable-length-parameters" id="toc-element-variable-length-parameters" class="toc-element">Variable length parameters</a></li>
<li><a href="declarations.html#extension-function-declaration" id="toc-element-extension-function-declaration" class="toc-element">Extension function declaration</a></li>
<li><a href="declarations.html#inlining" id="toc-element-inlining" class="toc-element">Inlining</a></li>
<li><a href="declarations.html#tail-recursion-optimization" id="toc-element-tail-recursion-optimization" class="toc-element">Tail recursion optimization</a></li>
</ul></li>
<li><a href="declarations.html#property-declaration" id="toc-element-property-declaration" class="toc-element">Property declaration</a>
<ul>
<li><a href="declarations.html#read-only-property-declaration" id="toc-element-read-only-property-declaration" class="toc-element">Read-only property declaration</a></li>
<li><a href="declarations.html#mutable-property-declaration" id="toc-element-mutable-property-declaration" class="toc-element">Mutable property declaration</a></li>
<li><a href="declarations.html#local-property-declaration" id="toc-element-local-property-declaration" class="toc-element">Local property declaration</a></li>
<li><a href="declarations.html#getters-and-setters" id="toc-element-getters-and-setters" class="toc-element">Getters and setters</a></li>
<li><a href="declarations.html#delegated-property-declaration" id="toc-element-delegated-property-declaration" class="toc-element">Delegated property declaration</a></li>
<li><a href="declarations.html#extension-property-declaration" id="toc-element-extension-property-declaration" class="toc-element">Extension property declaration</a></li>
<li><a href="declarations.html#property-initialization" id="toc-element-property-initialization" class="toc-element">Property initialization</a></li>
<li><a href="declarations.html#constant-properties" id="toc-element-constant-properties" class="toc-element">Constant properties</a></li>
<li><a href="declarations.html#late-initialized-properties" id="toc-element-late-initialized-properties" class="toc-element">Late-initialized properties</a></li>
</ul></li>
<li><a href="declarations.html#type-alias" id="toc-element-type-alias" class="toc-element">Type alias</a></li>
<li><a href="declarations.html#declarations-with-type-parameters" id="toc-element-declarations-with-type-parameters" class="toc-element">Declarations with type parameters</a>
<ul>
<li><a href="declarations.html#type-parameter-variance" id="toc-element-type-parameter-variance" class="toc-element">Type parameter variance</a></li>
<li><a href="declarations.html#reified-type-parameters" id="toc-element-reified-type-parameters" class="toc-element">Reified type parameters</a></li>
</ul></li>
<li><a href="declarations.html#declaration-visibility" id="toc-element-declaration-visibility" class="toc-element">Declaration visibility</a></li>
</ul></li>
<li><a href="inheritance.html#inheritance" id="toc-element-inheritance" class="toc-element">Inheritance</a>
<ul>
<li><a href="inheritance.html#classifier-type-inheritance" id="toc-element-classifier-type-inheritance" class="toc-element">Classifier type inheritance</a>
<ul>
<li><a href="inheritance.html#abstract-classes-1" id="toc-element-abstract-classes-1" class="toc-element">Abstract classes</a></li>
<li><a href="inheritance.html#sealed-classes" id="toc-element-sealed-classes" class="toc-element">Sealed classes</a></li>
<li><a href="inheritance.html#inheritance-from-built-in-types" id="toc-element-inheritance-from-built-in-types" class="toc-element">Inheritance from built-in types</a></li>
</ul></li>
<li><a href="inheritance.html#overriding" id="toc-element-overriding" class="toc-element">Overriding</a></li>
</ul></li>
<li><a href="scopes-and-identifiers.html#scopes-and-identifiers" id="toc-element-scopes-and-identifiers" class="toc-element">Scopes and identifiers</a>
<ul>
<li><a href="scopes-and-identifiers.html#linked-scopes" id="toc-element-linked-scopes" class="toc-element">Linked scopes</a></li>
<li><a href="scopes-and-identifiers.html#identifiers-and-paths" id="toc-element-identifiers-and-paths" class="toc-element">Identifiers and paths</a></li>
<li><a href="scopes-and-identifiers.html#labels" id="toc-element-labels" class="toc-element">Labels</a></li>
</ul></li>
<li><a href="statements.html#statements" id="toc-element-statements" class="toc-element">Statements</a>
<ul>
<li><a href="statements.html#assignments" id="toc-element-assignments" class="toc-element">Assignments</a>
<ul>
<li><a href="statements.html#simple-assignments" id="toc-element-simple-assignments" class="toc-element">Simple assignments</a></li>
<li><a href="statements.html#operator-assignments" id="toc-element-operator-assignments" class="toc-element">Operator assignments</a></li>
<li><a href="statements.html#safe-assignments" id="toc-element-safe-assignments" class="toc-element">Safe assignments</a></li>
</ul></li>
<li><a href="statements.html#loop-statements" id="toc-element-loop-statements" class="toc-element">Loop statements</a>
<ul>
<li><a href="statements.html#while-loop-statement" id="toc-element-while-loop-statement" class="toc-element">While-loop statement</a></li>
<li><a href="statements.html#do-while-loop-statement" id="toc-element-do-while-loop-statement" class="toc-element">Do-while-loop statement</a></li>
<li><a href="statements.html#for-loop-statement" id="toc-element-for-loop-statement" class="toc-element">For-loop statement</a></li>
</ul></li>
<li><a href="statements.html#code-blocks" id="toc-element-code-blocks" class="toc-element">Code blocks</a>
<ul>
<li><a href="statements.html#coercion-to-kotlin.unit" id="toc-element-coercion-to-kotlin.unit" class="toc-element">Coercion to <code>kotlin.Unit</code></a></li>
</ul></li>
</ul></li>
<li><a href="expressions.html#expressions" id="toc-element-expressions" class="toc-element">Expressions</a>
<ul>
<li><a href="expressions.html#glossary-2" id="toc-element-glossary-2" class="toc-element unnumbered">Glossary</a></li>
<li><a href="expressions.html#introduction-3" id="toc-element-introduction-3" class="toc-element unnumbered">Introduction</a></li>
<li><a href="expressions.html#constant-literals" id="toc-element-constant-literals" class="toc-element">Constant literals</a>
<ul>
<li><a href="expressions.html#boolean-literals" id="toc-element-boolean-literals" class="toc-element">Boolean literals</a></li>
<li><a href="expressions.html#integer-literals" id="toc-element-integer-literals" class="toc-element">Integer literals</a>
<ul>
<li><a href="expressions.html#decimal-integer-literals" id="toc-element-decimal-integer-literals" class="toc-element">Decimal integer literals</a></li>
<li><a href="expressions.html#hexadecimal-integer-literals" id="toc-element-hexadecimal-integer-literals" class="toc-element">Hexadecimal integer literals</a></li>
<li><a href="expressions.html#binary-integer-literals" id="toc-element-binary-integer-literals" class="toc-element">Binary integer literals</a></li>
</ul></li>
<li><a href="expressions.html#the-types-for-integer-literals" id="toc-element-the-types-for-integer-literals" class="toc-element">The types for integer literals</a></li>
<li><a href="expressions.html#real-literals" id="toc-element-real-literals" class="toc-element">Real literals</a></li>
<li><a href="expressions.html#character-literals" id="toc-element-character-literals" class="toc-element">Character literals</a>
<ul>
<li><a href="expressions.html#escaped-characters" id="toc-element-escaped-characters" class="toc-element">Escaped characters</a></li>
</ul></li>
<li><a href="expressions.html#string-literals" id="toc-element-string-literals" class="toc-element">String literals</a></li>
<li><a href="expressions.html#null-literal" id="toc-element-null-literal" class="toc-element">Null literal</a></li>
</ul></li>
<li><a href="expressions.html#string-interpolation-expressions" id="toc-element-string-interpolation-expressions" class="toc-element">String interpolation expressions</a></li>
<li><a href="expressions.html#try-expression" id="toc-element-try-expression" class="toc-element">Try-expression</a></li>
<li><a href="expressions.html#conditional-expression" id="toc-element-conditional-expression" class="toc-element">Conditional expression</a></li>
<li><a href="expressions.html#when-expression" id="toc-element-when-expression" class="toc-element">When expression</a>
<ul>
<li><a href="expressions.html#exhaustive-when-expressions" id="toc-element-exhaustive-when-expressions" class="toc-element">Exhaustive when expressions</a></li>
</ul></li>
<li><a href="expressions.html#logical-disjunction-expression" id="toc-element-logical-disjunction-expression" class="toc-element">Logical disjunction expression</a></li>
<li><a href="expressions.html#logical-conjunction-expression" id="toc-element-logical-conjunction-expression" class="toc-element">Logical conjunction expression</a></li>
<li><a href="expressions.html#equality-expressions" id="toc-element-equality-expressions" class="toc-element">Equality expressions</a>
<ul>
<li><a href="expressions.html#reference-equality-expressions" id="toc-element-reference-equality-expressions" class="toc-element">Reference equality expressions</a></li>
<li><a href="expressions.html#value-equality-expressions" id="toc-element-value-equality-expressions" class="toc-element">Value equality expressions</a></li>
</ul></li>
<li><a href="expressions.html#comparison-expressions" id="toc-element-comparison-expressions" class="toc-element">Comparison expressions</a></li>
<li><a href="expressions.html#type-checking-and-containment-checking-expressions" id="toc-element-type-checking-and-containment-checking-expressions" class="toc-element">Type-checking and containment-checking expressions</a>
<ul>
<li><a href="expressions.html#type-checking-expression" id="toc-element-type-checking-expression" class="toc-element">Type-checking expression</a></li>
<li><a href="expressions.html#containment-checking-expression" id="toc-element-containment-checking-expression" class="toc-element">Containment-checking expression</a></li>
</ul></li>
<li><a href="expressions.html#elvis-operator-expression" id="toc-element-elvis-operator-expression" class="toc-element">Elvis operator expression</a></li>
<li><a href="expressions.html#range-expression" id="toc-element-range-expression" class="toc-element">Range expression</a></li>
<li><a href="expressions.html#additive-expression" id="toc-element-additive-expression" class="toc-element">Additive expression</a></li>
<li><a href="expressions.html#multiplicative-expression" id="toc-element-multiplicative-expression" class="toc-element">Multiplicative expression</a></li>
<li><a href="expressions.html#cast-expression" id="toc-element-cast-expression" class="toc-element">Cast expression</a></li>
<li><a href="expressions.html#prefix-expressions" id="toc-element-prefix-expressions" class="toc-element">Prefix expressions</a>
<ul>
<li><a href="expressions.html#annotated-expression" id="toc-element-annotated-expression" class="toc-element">Annotated expression</a></li>
<li><a href="expressions.html#prefix-increment-expression" id="toc-element-prefix-increment-expression" class="toc-element">Prefix increment expression</a></li>
<li><a href="expressions.html#prefix-decrement-expression" id="toc-element-prefix-decrement-expression" class="toc-element">Prefix decrement expression</a></li>
<li><a href="expressions.html#unary-minus-expression" id="toc-element-unary-minus-expression" class="toc-element">Unary minus expression</a></li>
<li><a href="expressions.html#unary-plus-expression" id="toc-element-unary-plus-expression" class="toc-element">Unary plus expression</a></li>
<li><a href="expressions.html#logical-not-expression" id="toc-element-logical-not-expression" class="toc-element">Logical not expression</a></li>
</ul></li>
<li><a href="expressions.html#postfix-operator-expressions" id="toc-element-postfix-operator-expressions" class="toc-element">Postfix operator expressions</a>
<ul>
<li><a href="expressions.html#postfix-increment-expression" id="toc-element-postfix-increment-expression" class="toc-element">Postfix increment expression</a></li>
<li><a href="expressions.html#postfix-decrement-expression" id="toc-element-postfix-decrement-expression" class="toc-element">Postfix decrement expression</a></li>
</ul></li>
<li><a href="expressions.html#not-null-assertion-expression" id="toc-element-not-null-assertion-expression" class="toc-element">Not-null assertion expression</a></li>
<li><a href="expressions.html#indexing-expressions" id="toc-element-indexing-expressions" class="toc-element">Indexing expressions</a></li>
<li><a href="expressions.html#call-and-property-access-expressions" id="toc-element-call-and-property-access-expressions" class="toc-element">Call and property access expressions</a>
<ul>
<li><a href="expressions.html#navigation-operators" id="toc-element-navigation-operators" class="toc-element">Navigation operators</a></li>
<li><a href="expressions.html#callable-references" id="toc-element-callable-references" class="toc-element">Callable references</a></li>
<li><a href="expressions.html#class-literals" id="toc-element-class-literals" class="toc-element">Class literals</a></li>
<li><a href="expressions.html#function-calls-and-property-access" id="toc-element-function-calls-and-property-access" class="toc-element">Function calls and property access</a></li>
<li><a href="expressions.html#spread-operator-expressions" id="toc-element-spread-operator-expressions" class="toc-element">Spread operator expressions</a></li>
</ul></li>
<li><a href="expressions.html#function-literals" id="toc-element-function-literals" class="toc-element">Function literals</a>
<ul>
<li><a href="expressions.html#anonymous-function-declarations" id="toc-element-anonymous-function-declarations" class="toc-element">Anonymous function declarations</a></li>
<li><a href="expressions.html#lambda-literals" id="toc-element-lambda-literals" class="toc-element">Lambda literals</a></li>
</ul></li>
<li><a href="expressions.html#object-literals" id="toc-element-object-literals" class="toc-element">Object literals</a>
<ul>
<li><a href="expressions.html#functional-interface-lambda-literals" id="toc-element-functional-interface-lambda-literals" class="toc-element">Functional interface lambda literals</a></li>
</ul></li>
<li><a href="expressions.html#this-expressions" id="toc-element-this-expressions" class="toc-element">This-expressions</a></li>
<li><a href="expressions.html#super-forms" id="toc-element-super-forms" class="toc-element">Super-forms</a></li>
<li><a href="expressions.html#jump-expressions" id="toc-element-jump-expressions" class="toc-element">Jump expressions</a>
<ul>
<li><a href="expressions.html#throw-expressions" id="toc-element-throw-expressions" class="toc-element">Throw expressions</a></li>
<li><a href="expressions.html#return-expressions" id="toc-element-return-expressions" class="toc-element">Return expressions</a></li>
<li><a href="expressions.html#continue-expression" id="toc-element-continue-expression" class="toc-element">Continue expression</a></li>
<li><a href="expressions.html#break-expression" id="toc-element-break-expression" class="toc-element">Break expression</a></li>
</ul></li>
</ul></li>
<li><a href="operator-overloading.html#operator-overloading" id="toc-element-operator-overloading" class="toc-element">Operator overloading</a>
<ul>
<li><a href="operator-overloading.html#destructuring-declarations" id="toc-element-destructuring-declarations" class="toc-element">Destructuring declarations</a></li>
</ul></li>
<li><a href="packages-and-imports.html#packages-and-imports" id="toc-element-packages-and-imports" class="toc-element">Packages and imports</a>
<ul>
<li><a href="packages-and-imports.html#importing" id="toc-element-importing" class="toc-element">Importing</a></li>
<li><a href="packages-and-imports.html#modules" id="toc-element-modules" class="toc-element">Modules</a></li>
</ul></li>
<li><a href="overload-resolution.html#overload-resolution" id="toc-element-overload-resolution" class="toc-element">Overload resolution</a>
<ul>
<li><a href="overload-resolution.html#glossary-3" id="toc-element-glossary-3" class="toc-element unnumbered">Glossary</a></li>
<li><a href="overload-resolution.html#introduction-4" id="toc-element-introduction-4" class="toc-element unnumbered">Introduction</a></li>
<li><a href="overload-resolution.html#receivers" id="toc-element-receivers" class="toc-element">Receivers</a></li>
<li><a href="overload-resolution.html#the-forms-of-call-expression" id="toc-element-the-forms-of-call-expression" class="toc-element">The forms of call-expression</a></li>
<li><a href="overload-resolution.html#callables-and-invoke-convention" id="toc-element-callables-and-invoke-convention" class="toc-element">Callables and <code>invoke</code> convention</a></li>
<li><a href="overload-resolution.html#c-level-partition" id="toc-element-c-level-partition" class="toc-element">c-level partition</a></li>
<li><a href="overload-resolution.html#building-the-overload-candidate-set-ocs" id="toc-element-building-the-overload-candidate-set-ocs" class="toc-element">Building the overload candidate set (OCS)</a>
<ul>
<li><a href="overload-resolution.html#fully-qualified-call" id="toc-element-fully-qualified-call" class="toc-element">Fully-qualified call</a></li>
<li><a href="overload-resolution.html#call-with-an-explicit-receiver" id="toc-element-call-with-an-explicit-receiver" class="toc-element">Call with an explicit receiver</a>
<ul>
<li><a href="overload-resolution.html#call-with-an-explicit-type-receiver" id="toc-element-call-with-an-explicit-type-receiver" class="toc-element">Call with an explicit type receiver</a></li>
</ul></li>
<li><a href="overload-resolution.html#infix-function-call" id="toc-element-infix-function-call" class="toc-element">Infix function call</a></li>
<li><a href="overload-resolution.html#operator-call" id="toc-element-operator-call" class="toc-element">Operator call</a></li>
<li><a href="overload-resolution.html#call-without-an-explicit-receiver" id="toc-element-call-without-an-explicit-receiver" class="toc-element">Call without an explicit receiver</a></li>
<li><a href="overload-resolution.html#call-with-named-parameters" id="toc-element-call-with-named-parameters" class="toc-element">Call with named parameters</a></li>
<li><a href="overload-resolution.html#call-with-trailing-lambda-expressions" id="toc-element-call-with-trailing-lambda-expressions" class="toc-element">Call with trailing lambda expressions</a></li>
<li><a href="overload-resolution.html#call-with-specified-type-parameters" id="toc-element-call-with-specified-type-parameters" class="toc-element">Call with specified type parameters</a></li>
</ul></li>
<li><a href="overload-resolution.html#determining-function-applicability-for-a-specific-call" id="toc-element-determining-function-applicability-for-a-specific-call" class="toc-element">Determining function applicability for a specific call</a>
<ul>
<li><a href="overload-resolution.html#rationale" id="toc-element-rationale" class="toc-element">Rationale</a></li>
<li><a href="overload-resolution.html#description" id="toc-element-description" class="toc-element">Description</a></li>
</ul></li>
<li><a href="overload-resolution.html#choosing-the-most-specific-candidate-from-the-overload-candidate-set" id="toc-element-choosing-the-most-specific-candidate-from-the-overload-candidate-set" class="toc-element">Choosing the most specific candidate from the overload candidate set</a>
<ul>
<li><a href="overload-resolution.html#rationale-1" id="toc-element-rationale-1" class="toc-element">Rationale</a></li>
<li><a href="overload-resolution.html#algorithm-of-msc-selection" id="toc-element-algorithm-of-msc-selection" class="toc-element">Algorithm of MSC selection</a></li>
</ul></li>
<li><a href="overload-resolution.html#resolving-callable-references" id="toc-element-resolving-callable-references" class="toc-element">Resolving callable references</a>
<ul>
<li><a href="overload-resolution.html#resolving-callable-references-not-used-as-arguments-to-a-call" id="toc-element-resolving-callable-references-not-used-as-arguments-to-a-call" class="toc-element">Resolving callable references not used as arguments to a call</a></li>
<li><a href="overload-resolution.html#bidirectional-resolution-for-callable-calls" id="toc-element-bidirectional-resolution-for-callable-calls" class="toc-element">Bidirectional resolution for callable calls</a></li>
</ul></li>
<li><a href="overload-resolution.html#type-inference-and-overload-resolution" id="toc-element-type-inference-and-overload-resolution" class="toc-element">Type inference and overload resolution</a></li>
<li><a href="overload-resolution.html#conflicting-overloads" id="toc-element-conflicting-overloads" class="toc-element">Conflicting overloads</a></li>
</ul></li>
<li><a href="control--and-data-flow-analysis.html#control--and-data-flow-analysis" id="toc-element-control--and-data-flow-analysis" class="toc-element">Control- and data-flow analysis</a>
<ul>
<li><a href="control--and-data-flow-analysis.html#control-flow-graph" id="toc-element-control-flow-graph" class="toc-element">Control flow graph</a>
<ul>
<li><a href="control--and-data-flow-analysis.html#expressions-1" id="toc-element-expressions-1" class="toc-element">Expressions</a>
<ul>
<li><a href="control--and-data-flow-analysis.html#function-calls-and-operators" id="toc-element-function-calls-and-operators" class="toc-element">Function calls and operators</a></li>
<li><a href="control--and-data-flow-analysis.html#conditional-expressions" id="toc-element-conditional-expressions" class="toc-element">Conditional expressions</a></li>
<li><a href="control--and-data-flow-analysis.html#boolean-operators" id="toc-element-boolean-operators" class="toc-element">Boolean operators</a></li>
<li><a href="control--and-data-flow-analysis.html#other-expressions" id="toc-element-other-expressions" class="toc-element">Other expressions</a></li>
</ul></li>
<li><a href="control--and-data-flow-analysis.html#statements-1" id="toc-element-statements-1" class="toc-element">Statements</a></li>
<li><a href="control--and-data-flow-analysis.html#declarations-1" id="toc-element-declarations-1" class="toc-element">Declarations</a></li>
<li><a href="control--and-data-flow-analysis.html#examples" id="toc-element-examples" class="toc-element">Examples</a></li>
<li><a href="control--and-data-flow-analysis.html#kotlin.nothing-and-its-influence-on-the-cfg" id="toc-element-kotlin.nothing-and-its-influence-on-the-cfg" class="toc-element"><code>kotlin.Nothing</code> and its influence on the CFG</a></li>
</ul></li>
<li><a href="control--and-data-flow-analysis.html#performing-analyses-on-the-control-flow-graph" id="toc-element-performing-analyses-on-the-control-flow-graph" class="toc-element">Performing analyses on the control-flow graph</a>
<ul>
<li><a href="control--and-data-flow-analysis.html#preliminary-analysis-and-operatornamemathitkilldataflow-instruction" id="toc-element-preliminary-analysis-and-operatornamemathitkilldataflow-instruction" class="toc-element">Preliminary analysis and <span class="math inline">\(\operatorname{\mathit{killDataFlow}}\)</span> instruction</a></li>
<li><a href="control--and-data-flow-analysis.html#variable-initialization-analysis" id="toc-element-variable-initialization-analysis" class="toc-element">Variable initialization analysis</a></li>
<li><a href="control--and-data-flow-analysis.html#smart-casting-analysis" id="toc-element-smart-casting-analysis" class="toc-element">Smart casting analysis</a></li>
</ul></li>
<li><a href="control--and-data-flow-analysis.html#references-1" id="toc-element-references-1" class="toc-element unnumbered">References</a></li>
</ul></li>
<li><a href="kotlin-type-constraints.html#kotlin-type-constraints" id="toc-element-kotlin-type-constraints" class="toc-element">Kotlin type constraints</a>
<ul>
<li><a href="kotlin-type-constraints.html#type-constraint-definition" id="toc-element-type-constraint-definition" class="toc-element">Type constraint definition</a></li>
<li><a href="kotlin-type-constraints.html#type-constraint-solving" id="toc-element-type-constraint-solving" class="toc-element">Type constraint solving</a>
<ul>
<li><a href="kotlin-type-constraints.html#checking-constraint-system-soundness" id="toc-element-checking-constraint-system-soundness" class="toc-element">Checking constraint system soundness</a>
<ul>
<li><a href="kotlin-type-constraints.html#a-sample-bound-inference-algorithm" id="toc-element-a-sample-bound-inference-algorithm" class="toc-element">A sample bound inference algorithm</a></li>
</ul></li>
<li><a href="kotlin-type-constraints.html#finding-optimal-constraint-system-solution" id="toc-element-finding-optimal-constraint-system-solution" class="toc-element">Finding optimal constraint system solution</a></li>
<li><a href="kotlin-type-constraints.html#the-relations-on-types-as-constraints" id="toc-element-the-relations-on-types-as-constraints" class="toc-element">The relations on types as constraints</a></li>
</ul></li>
</ul></li>
<li><a href="type-inference.html#type-inference" id="toc-element-type-inference" class="toc-element">Type inference</a>
<ul>
<li><a href="type-inference.html#smart-casts" id="toc-element-smart-casts" class="toc-element">Smart casts</a>
<ul>
<li><a href="type-inference.html#data-flow-framework" id="toc-element-data-flow-framework" class="toc-element">Data-flow framework</a>
<ul>
<li><a href="type-inference.html#smart-cast-lattices" id="toc-element-smart-cast-lattices" class="toc-element">Smart cast lattices</a></li>
<li><a href="type-inference.html#smart-cast-transfer-functions" id="toc-element-smart-cast-transfer-functions" class="toc-element">Smart cast transfer functions</a></li>
</ul></li>
<li><a href="type-inference.html#smart-cast-types" id="toc-element-smart-cast-types" class="toc-element">Smart cast types</a></li>
<li><a href="type-inference.html#smart-cast-sink-stability" id="toc-element-smart-cast-sink-stability" class="toc-element">Smart cast sink stability</a>
<ul>
<li><a href="type-inference.html#effectively-immutable-smart-cast-sinks" id="toc-element-effectively-immutable-smart-cast-sinks" class="toc-element">Effectively immutable smart cast sinks</a></li>
</ul></li>
<li><a href="type-inference.html#loop-handling" id="toc-element-loop-handling" class="toc-element">Loop handling</a></li>
<li><a href="type-inference.html#bound-smart-casts" id="toc-element-bound-smart-casts" class="toc-element">Bound smart casts</a></li>
</ul></li>
<li><a href="type-inference.html#local-type-inference" id="toc-element-local-type-inference" class="toc-element">Local type inference</a></li>
<li><a href="type-inference.html#function-signature-type-inference" id="toc-element-function-signature-type-inference" class="toc-element">Function signature type inference</a>
<ul>
<li><a href="type-inference.html#named-and-anonymous-function-declarations" id="toc-element-named-and-anonymous-function-declarations" class="toc-element">Named and anonymous function declarations</a></li>
<li><a href="type-inference.html#statements-with-lambda-literals" id="toc-element-statements-with-lambda-literals" class="toc-element">Statements with lambda literals</a></li>
</ul></li>
</ul></li>
<li><a href="runtime-type-information.html#runtime-type-information" id="toc-element-runtime-type-information" class="toc-element">Runtime type information</a>
<ul>
<li><a href="runtime-type-information.html#runtime-available-types" id="toc-element-runtime-available-types" class="toc-element">Runtime-available types</a></li>
<li><a href="runtime-type-information.html#reflection" id="toc-element-reflection" class="toc-element">Reflection</a></li>
</ul></li>
<li><a href="exceptions.html#exceptions" id="toc-element-exceptions" class="toc-element">Exceptions</a>
<ul>
<li><a href="exceptions.html#catching-exceptions" id="toc-element-catching-exceptions" class="toc-element">Catching exceptions</a></li>
<li><a href="exceptions.html#throwing-exceptions" id="toc-element-throwing-exceptions" class="toc-element">Throwing exceptions</a></li>
</ul></li>
<li><a href="annotations.html#annotations" id="toc-element-annotations" class="toc-element">Annotations</a>
<ul>
<li><a href="annotations.html#annotation-values" id="toc-element-annotation-values" class="toc-element">Annotation values</a></li>
<li><a href="annotations.html#annotation-retention" id="toc-element-annotation-retention" class="toc-element">Annotation retention</a></li>
<li><a href="annotations.html#annotation-targets" id="toc-element-annotation-targets" class="toc-element">Annotation targets</a></li>
<li><a href="annotations.html#annotation-declarations" id="toc-element-annotation-declarations" class="toc-element">Annotation declarations</a></li>
<li><a href="annotations.html#built-in-annotations" id="toc-element-built-in-annotations" class="toc-element">Built-in annotations</a></li>
</ul></li>
<li><a href="coroutines.html#coroutines" id="toc-element-coroutines" class="toc-element">Coroutines</a>
<ul>
<li><a href="coroutines.html#suspending-functions" id="toc-element-suspending-functions" class="toc-element">Suspending functions</a></li>
<li><a href="coroutines.html#coroutines-1" id="toc-element-coroutines-1" class="toc-element">Coroutines</a></li>
</ul></li>
<li><a href="concurrency.html#concurrency" id="toc-element-concurrency" class="toc-element">Concurrency</a></li>
</ul></li>
</ul>
</div>
<span style="visibility: hidden; counter-reset: chapter 1;"></span>
<h2 id="type-system">Type system</h2>
<h3 id="glossary" class="unnumbered">Glossary</h3>
<dl>
<dt><span class="math inline">\(T\)</span></dt>
<dd><span class="sentence">Type (with unknown nullability)</span>
</dd>
<dt><span class="math inline">\(T!!\)</span></dt>
<dd><span class="sentence"><a href="type-system.html#nullable-types">Non-nullable type</a></span>
</dd>
<dt><span class="math inline">\(T?\)</span></dt>
<dd><span class="sentence"><a href="type-system.html#nullable-types">Nullable type</a></span>
</dd>
<dt><span class="math inline">\(\{T\}\)</span></dt>
<dd><span class="sentence">Universe of all possible types</span>
</dd>
<dt><span class="math inline">\(\{T!!\}\)</span></dt>
<dd><span class="sentence">Universe of non-nullable types</span>
</dd>
<dt><span class="math inline">\(\{T?\}\)</span></dt>
<dd><span class="sentence">Universe of nullable types</span>
</dd>
<dt>Well-formed type</dt>
<dd><span class="sentence">A properly constructed type w.r.t. Kotlin type system</span>
</dd>
<dt><span class="math inline">\(\Gamma\)</span></dt>
<dd><span class="sentence">Type context</span>
</dd>
<dt><span class="math inline">\(A &lt;: B\)</span></dt>
<dd><span class="sentence">A is a subtype of B</span>
</dd>
<dt><span class="math inline">\(A \mathrel{\operatorname{\cancel{&lt;:&gt;}}}B\)</span></dt>
<dd><span class="sentence">A and B are not related w.r.t. subtyping</span>
</dd>
<dt>Type constructor</dt>
<dd><span class="sentence">An abstract type with one or more type parameters, which must be instantiated before use</span>
</dd>
<dt>Parameterized type</dt>
<dd><span class="sentence">A concrete type, which is the result of type constructor instantiation</span>
</dd>
<dt>Type parameter</dt>
<dd><span class="sentence">Formal type argument of a type constructor</span>
</dd>
<dt>Type argument</dt>
<dd><span class="sentence">Actual type argument in a parameterized type</span>
</dd>
<dt><span class="math inline">\(T\lbrack A_1, \ldots, A_n\rbrack\)</span></dt>
<dd><span class="sentence">The result of type constructor <span class="math inline">\(T\)</span> instantiation with type arguments <span class="math inline">\(A_i\)</span></span>
</dd>
<dt><span class="math inline">\(T\lbrack\sigma\rbrack\)</span></dt>
<dd><span class="sentence">The result of type constructor <span class="math inline">\(T(F_1, \ldots, F_n)\)</span> instantiation with the assumed substitution <span class="math inline">\(\sigma : F_1 = A_1, \ldots, F_n = A_n\)</span></span>
</dd>
<dt><span class="math inline">\(\sigma T\)</span></dt>
<dd><span class="sentence">The result of type substitution in type <span class="math inline">\(T\)</span> w.r.t. substitution <span class="math inline">\(\sigma\)</span></span>
</dd>
<dt><span class="math inline">\(K_T(F, A)\)</span></dt>
<dd><span class="sentence">Captured type from the <a href="type-system.html#type-capturing">type capturing</a> of type parameter <span class="math inline">\(F\)</span> and type argument <span class="math inline">\(A\)</span> in parameterized type <span class="math inline">\(T\)</span></span>
</dd>
<dt><span class="math inline">\(T\langle K_1, \ldots, K_n\rangle\)</span></dt>
<dd><span class="sentence">The result of type capturing for parameterized type <span class="math inline">\(T\)</span> with <em>captured</em> types <span class="math inline">\(K_i\)</span></span>
</dd>
<dt><span class="math inline">\(T\langle \tau \rangle\)</span></dt>
<dd><span class="sentence">The result of type capturing for parameterized type <span class="math inline">\(T(F_1, \ldots, F_n)\)</span> with <em>captured</em> substitution <span class="math inline">\(\tau : F_1 = K_1, \ldots, F_n = K_n\)</span></span>
</dd>
<dt><span class="math inline">\(A \mathbin{\operatorname{\&amp;}}B\)</span></dt>
<dd><span class="sentence">Intersection type of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span></span>
</dd>
<dt><span class="math inline">\(A \mathbin{\operatorname{|}}B\)</span></dt>
<dd><span class="sentence">Union type of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span></span>
</dd>
<dt><span class="math inline">\(\operatorname{\text{GLB}}\)</span></dt>
<dd><span class="sentence">Greatest lower bound</span>
</dd>
<dt><span class="math inline">\(\operatorname{\text{LUB}}\)</span></dt>
<dd><span class="sentence">Least upper bound</span>
</dd>
</dl>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Not everything is in the glossary, make some criteria of what goes where)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Cleanup glossary)</span></p>
</div>
</div>
<h3 id="introduction-1" class="unnumbered">Introduction</h3>
<div class="paragraph">
<p><span class="sentence">Similarly to most other programming languages, Kotlin operates on data in the form of <em>values</em> or <em>objects</em>, which have <em>types</em>  descriptions of what is the expected behaviour and possible values for their datum. </span><span class="sentence">An empty value is represented by a special <code>null</code> object; most operations with it result in runtime <a href="exceptions.html#exceptions">errors or exceptions</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin has a type system with the following main properties.</span></p>
</div>
<ul>
<li><span class="sentence">Hybrid static, gradual and flow type checking;</span></li>
<li><span class="sentence">Null safety;</span></li>
<li><span class="sentence">No unsafe implicit conversions;</span></li>
<li><span class="sentence">Unified top and bottom types;</span></li>
<li><span class="sentence">Nominal subtyping with bounded parametric polymorphism and mixed-site variance.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Type safety (consistency between compile and runtime types) is verified <em>statically</em>, at compile time, for the majority of Kotlin types. </span><span class="sentence">However, for better interoperability with platform-dependent code Kotlin also support a variant of <em>gradual types</em> in the form of <a href="type-system.html#flexible-types">flexible types</a>. </span><span class="sentence">Even more so, in some cases the compile-time type of a value may <em>change</em> depending on the control- and data-flow of the program; a feature usually known as <em>flow typing</em>, represented in Kotlin as <a href="type-inference.html#smart-casts">smart casts</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Null safety is enforced by having two type universes: <em>nullable</em> (with nullable types <span class="math inline">\(T?\)</span>) and <em>non-nullable</em> (with non-nullable types <span class="math inline">\(T!!\)</span>). </span><span class="sentence">A value of any non-nullable type cannot contain <code>null</code>, meaning all operations within the non-nullable type universe are safe w.r.t. empty values, i.e., should never result in a runtime error caused by <code>null</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit conversions between types in Kotlin are limited to safe upcasts w.r.t. subtyping, meaning all other (unsafe) conversions must be explicit, done via either a conversion function or an <a href="expressions.html#cast-expression">explicit cast</a>. </span><span class="sentence">However, Kotlin also supports smart casts  a special kind of implicit conversions which are safe w.r.t. program control- and data-flow, which are covered in more detail <a href="type-inference.html#smart-casts">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The unified supertype type for all types in Kotlin is <span class="math inline">\(\operatorname{\texttt{kotlin.Any?}}\)</span>, a <a href="type-system.html#nullable-types">nullable</a> version of <a href="built-in-types-and-their-semantics.html#kotlin.any-1"><span class="math inline">\(\operatorname{\texttt{kotlin.Any}}\)</span></a>. </span><span class="sentence">The unified subtype type for all types in Kotlin is <a href="built-in-types-and-their-semantics.html#kotlin.nothing-1"><span class="math inline">\(\operatorname{\texttt{kotlin.Nothing}}\)</span></a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin uses nominal subtyping, meaning subtyping relation is defined when a type is declared, with bounded parametric polymorphism, implemented as generics via <a href="type-system.html#parameterized-classifier-types">parameterized types</a>. </span><span class="sentence">Subtyping between these parameterized types is defined through <a href="type-system.html#mixed-site-variance">mixed-site variance</a>.</span></p>
</div>
<h3 id="type-kinds">Type kinds</h3>
<div class="paragraph">
<p><span class="sentence">For the purposes of this section, we establish the following type kinds  different flavours of types which exist in the Kotlin type system.</span></p>
</div>
<ul>
<li><span class="sentence"><a href="type-system.html#built-in-types">Built-in types</a></span></li>
<li><span class="sentence"><a href="type-system.html#classifier-types">Classifier types</a></span></li>
<li><span class="sentence"><a href="type-system.html#type-parameters">Type parameters</a></span></li>
<li><span class="sentence"><a href="type-system.html#function-types">Function types</a></span></li>
<li><span class="sentence"><a href="type-system.html#array-types">Array types</a></span></li>
<li><span class="sentence"><a href="type-system.html#flexible-types">Flexible types</a></span></li>
<li><span class="sentence"><a href="type-system.html#nullable-types">Nullable types</a></span></li>
<li><span class="sentence"><a href="type-system.html#intersection-types">Intersection types</a></span></li>
<li><span class="sentence"><a href="type-system.html#union-types">Union types</a></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">We distinguish between <em>concrete</em> and <em>abstract</em> types. </span><span class="sentence">Concrete types are types which are assignable to values. </span><span class="sentence">Abstract types need to be instantiated as concrete types before they can be used as types for values.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for brevity, we omit specifying that a type is concrete. </span><span class="sentence">All types not described as abstract are implicitly concrete.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">We further distinguish <em>concrete</em> types between <em>class</em> and <em>interface</em> types; as Kotlin is a language with single inheritance, sometimes it is important to discriminate between these kinds of types. </span><span class="sentence">Any given concrete type may be either a class or an interface type, but never both.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">We also distinguish between <em>denotable</em> and <em>non-denotable</em> types. </span><span class="sentence">The former are types which are expressible in Kotlin and can be written by the end-user. </span><span class="sentence">The latter are special types which are <em>not</em> expressible in Kotlin and are used by the compiler in <a href="type-inference.html#type-inference">type inference</a>, <a href="type-inference.html#smart-casts">smart casts</a>, etc.</span></p>
</div>
<h4 id="built-in-types">Built-in types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin type system uses the following built-in types, which have special semantics and representation (or lack thereof).</span></p>
</div>
<h5 id="kotlin.any"><code>kotlin.Any</code></h5>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\texttt{kotlin.Any}}\)</span> is the unified <a href="type-system.html#subtyping">supertype</a> (<span class="math inline">\(\top\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., all non-nullable types are subtypes of <span class="math inline">\(\operatorname{\texttt{kotlin.Any}}\)</span>, either explicitly, implicitly, or by <a href="type-system.html#subtyping">subtyping relation</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: additional details about <span class="math inline">\(\operatorname{\texttt{kotlin.Any}}\)</span> are available <a href="built-in-types-and-their-semantics.html#kotlin.any-1">here</a>.</span></p>
</div>
</blockquote>
<h5 id="kotlin.nothing"><code>kotlin.Nothing</code></h5>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\texttt{kotlin.Nothing}}\)</span> is the unified <a href="type-system.html#subtyping">subtype</a> (<span class="math inline">\(\bot\)</span>) for <span class="math inline">\(\{T\}\)</span>, i.e., <span class="math inline">\(\operatorname{\texttt{kotlin.Nothing}}\)</span> is a subtype of all well-formed Kotlin types, including user-defined ones. </span><span class="sentence">This makes it an uninhabited type (as it is impossible for anything to be, for example, a function and an integer at the same time), meaning instances of this type can never exist at runtime; subsequently, there is no way to create an instance of <span class="math inline">\(\operatorname{\texttt{kotlin.Nothing}}\)</span> in Kotlin.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: additional details about <span class="math inline">\(\operatorname{\texttt{kotlin.Nothing}}\)</span> are available <a href="built-in-types-and-their-semantics.html#kotlin.nothing-1">here</a>.</span></p>
</div>
</blockquote>
<h5 id="kotlin.function"><code>kotlin.Function</code></h5>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\texttt{kotlin.Function}}(R)\)</span> is the unified supertype of all <a href="type-system.html#function-types">function types</a>. </span><span class="sentence">It is parameterized over function return type <code>R</code>.</span></p>
</div>
<h5 id="built-in-integer-types">Built-in integer types</h5>
<div class="paragraph">
<p><span class="sentence">Kotlin supports the following signed integer types.</span></p>
</div>
<ul>
<li><span class="sentence"><code>kotlin.Int</code></span></li>
<li><span class="sentence"><code>kotlin.Short</code></span></li>
<li><span class="sentence"><code>kotlin.Byte</code></span></li>
<li><span class="sentence"><code>kotlin.Long</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Besides their use as types, integer types are important w.r.t. <a href="type-system.html#integer-literal-types">integer literal types</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: additional details about built-in integer types are available <a href="built-in-types-and-their-semantics.html#built-in-integer-types-1">here</a>.</span></p>
</div>
</blockquote>
<h5 id="array-types">Array types</h5>
<div class="paragraph">
<p><span class="sentence">Kotlin arrays are represented as a <a href="type-system.html#parameterized-classifier-types">parameterized type</a> <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(T)\)</span>, where <span class="math inline">\(T\)</span> is the type of the stored elements, which supports <code>get</code>/<code>set</code> operations. </span><span class="sentence">The <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(T)\)</span> type follows the rules of regular type constructors and parameterized types w.r.t. subtyping.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: unlike Java, arrays in Kotlin are declared as invariant. </span><span class="sentence">To use them in a co- or contravariant way, one should use <a href="type-system.html#use-site-variance">use-site variance</a>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In addition to the general <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(T)\)</span> type, Kotlin also has the following specialized array types:</span></p>
</div>
<ul>
<li><span class="sentence"><code>DoubleArray</code> (for <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Double}})\)</span>)</span></li>
<li><span class="sentence"><code>FloatArray</code> (for <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Float}})\)</span>)</span></li>
<li><span class="sentence"><code>LongArray</code> (for <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Long}})\)</span>)</span></li>
<li><span class="sentence"><code>IntArray</code> (for <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Int}})\)</span>)</span></li>
<li><span class="sentence"><code>ShortArray</code> (for <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Short}})\)</span>)</span></li>
<li><span class="sentence"><code>ByteArray</code> (for <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Byte}})\)</span>)</span></li>
<li><span class="sentence"><code>CharArray</code> (for <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Char}})\)</span>)</span></li>
<li><span class="sentence"><code>BooleanArray</code> (for <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Boolean}})\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These array types structurally match the corresponding <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(T)\)</span> type; i.e., <code>IntArray</code> has the same methods and properties as <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Int}})\)</span>. </span><span class="sentence">However, they are <strong>not</strong> related by subtyping; meaning one cannot pass a <code>BooleanArray</code> argument to a function expecting an <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{kotlin.Boolean}})\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the presence of such specialized types allows the compiler to perform additional array-related optimizations.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: specialized and non-specialized array types match modulo their iterator types, which are also specialized; <code>Iterator&lt;Int&gt;</code> is specialized to <code>IntIterator</code>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><em>Array type specialization</em> <span class="math inline">\(\operatorname{\text{ATS}}(A)\)</span> is a transformation of a generic <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(T)\)</span> type to a corresponding specialized version, which works as follows.</span></p>
</div>
<ul>
<li><span class="sentence">if <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(T)\)</span> has a specialized version <code>TArray</code>, <span class="math inline">\(\operatorname{\text{ATS}}(\operatorname{\texttt{kotlin.Array}}(T)) = \texttt{TArray}\)</span></span></li>
<li><span class="sentence">if <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(T)\)</span> does not have a specialized version, <span class="math inline">\(\operatorname{\text{ATS}}(\operatorname{\texttt{kotlin.Array}}(T)) = \operatorname{\texttt{kotlin.Array}}(T)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\text{ATS}}\)</span> takes an important part in how <a href="declarations.html#variable-length-parameters">variable length parameters</a> are handled.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: additional details about built-in array types are available <a href="#built-in-array-types-1">here</a>.</span></p>
</div>
</blockquote>
<h4 id="classifier-types">Classifier types</h4>
<div class="paragraph">
<p><span class="sentence">Classifier types represent regular types which are declared as <a href="declarations.html#class-declaration">classes</a>, <a href="declarations.html#interface-declaration">interfaces</a> or <a href="declarations.html#object-declaration">objects</a>. </span><span class="sentence">As Kotlin supports parametric polymorphism, there are two variants of classifier types: simple and parameterized.</span></p>
</div>
<h5 id="simple-classifier-types">Simple classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A simple classifier type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">type name <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed simple classifier type, <span class="math inline">\(T : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,m]: S_i\)</span> must be concrete, <a href="type-system.html#nullable-types">non-nullable</a>, well-formed type</span></li>
<li><span class="sentence">the transitive closure <span class="math inline">\(\mathbb{S}^*(T)\)</span> of the set of type supertypes <span class="math inline">\(\mathbb{S}(T : S_1, \ldots, S_m) = \{S_1, \ldots, S_m\} \cup \mathbb{S}(S_1) \cup \ldots \cup \mathbb{S}(S_m)\)</span> is <em>consistent</em>, i.e., does not contain two <a href="type-system.html#parameterized-classifier-types">parameterized types</a> with different type arguments.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// A well-formed type with no supertypes</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">interface</span> <span class="dt">Base</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">// A well-formed type with a single supertype Base</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">interface</span> <span class="dt">Derived</span> <span class="op">:</span> <span class="dt">Base</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">// An ill-formed type,</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">// as nullable type cannot be a supertype</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">interface</span> <span class="dt">Invalid</span> <span class="op">:</span> <span class="dt">Base</span>?</a></code></pre></div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for the purpose of different type system examples, we assume the presence of the following well-formed concrete types:</span></p>
</div>
<ul>
<li><span class="sentence">class <code>String</code></span></li>
<li><span class="sentence">interface <code>Number</code></span></li>
<li><span class="sentence">class <code>Int</code> <span class="math inline">\(&lt;:\)</span> <code>Number</code></span></li>
<li><span class="sentence">class <code>Double</code> <span class="math inline">\(&lt;:\)</span> <code>Number</code></span></li>
</ul>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <code>Number</code> is actually a built-in abstract class; we use it as an interface for illustrative purposes.</span></p>
</div>
</blockquote>
<h5 id="parameterized-classifier-types">Parameterized classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A classifier type constructor</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T(F_1, \ldots, F_n) : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">describes an abstract type and consists of</span></p>
</div>
<ul>
<li><span class="sentence">type name <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">type parameters <span class="math inline">\(F_1, \ldots, F_n\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed type constructor, <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: F_i\)</span> must be well-formed <a href="type-system.html#type-parameters">type parameter</a></span></li>
<li><span class="sentence"><span class="math inline">\(\forall j \in [1,m]: S_j\)</span> must be concrete, <a href="type-system.html#nullable-types">non-nullable</a>, well-formed type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To instantiate a type constructor, one provides it with type arguments, creating a concrete parameterized classifier type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T[A_1, \ldots, A_n]\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">which consists of</span></p>
</div>
<ul>
<li><span class="sentence">type constructor <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">type arguments <span class="math inline">\(A_1, \ldots, A_n\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed parameterized type, <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a well-formed type constructor with <span class="math inline">\(n\)</span> type parameters</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i\)</span> must be well-formed concrete type</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]:\)</span> variance of <span class="math inline">\(A_i\)</span> does not <a href="type-system.html#use-site-variance">contradict</a> variance of <span class="math inline">\(F_i\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i &lt;: \tau U_i\)</span>, where <span class="math inline">\(U_i\)</span> is the upper bound for <span class="math inline">\(F_i\)</span> and captured substitution <span class="math inline">\(\tau : F_1 = K_1, \ldots, F_n = K_n\)</span> manipulates <a href="type-system.html#type-capturing">captured types</a>.</span></li>
<li><span class="sentence">the transitive closure <span class="math inline">\(\mathbb{S}^*(T)\)</span> of the set of type supertypes <span class="math inline">\(\mathbb{S}(T\langle \tau \rangle : \tau S_1, \ldots, \tau S_m) = \{\tau S_1, \ldots, \tau S_m\} \cup \mathbb{S}(\tau S_1) \cup \ldots \cup \mathbb{S}(\tau S_m)\)</span> is <em>consistent</em>, i.e., does not contain two <a href="type-system.html#parameterized-classifier-types">parameterized types</a> with different type arguments.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// A well-formed type constructor with no supertypes</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">// A and B are unbounded type parameters</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">interface</span> <span class="dt">Generic</span><span class="op">&lt;</span><span class="dt">A</span>, <span class="dt">B</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co">// A well-formed type constructor</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co">//   with a single parameterized supertype</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">// Int and String are well-formed concrete types</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">interface</span> <span class="dt">ConcreteDerived</span><span class="op">&lt;</span><span class="dt">P</span>, <span class="dt">Q</span><span class="op">&gt;</span> <span class="op">:</span> <span class="dt">Generic</span><span class="op">&lt;</span><span class="dt">Int</span>, <span class="dt">String</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co">// A well-formed type constructor</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co">//   with a single parameterized supertype</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="co">// P and Q are type parameters of GenericDerived,</span></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co">//   used as type arguments of Generic</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="kw">interface</span> <span class="dt">GenericDerived</span><span class="op">&lt;</span><span class="dt">P</span>, <span class="dt">Q</span><span class="op">&gt;</span> <span class="op">:</span> <span class="dt">Generic</span><span class="op">&lt;</span><span class="dt">P</span>, <span class="dt">Q</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-15" title="15"></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="co">// An ill-formed type constructor,</span></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="co">//   as abstract type Generic</span></a>
<a class="sourceLine" id="cb2-18" title="18"><span class="co">//   cannot be used as a supertype</span></a>
<a class="sourceLine" id="cb2-19" title="19"><span class="kw">interface</span> <span class="dt">Invalid</span><span class="op">&lt;</span><span class="dt">P</span><span class="op">&gt;</span> <span class="op">:</span> <span class="dt">Generic</span></a>
<a class="sourceLine" id="cb2-20" title="20"></a>
<a class="sourceLine" id="cb2-21" title="21"></a>
<a class="sourceLine" id="cb2-22" title="22"><span class="co">// A well-formed type constructor with no supertypes</span></a>
<a class="sourceLine" id="cb2-23" title="23"><span class="co">// out A is a projected type parameter</span></a>
<a class="sourceLine" id="cb2-24" title="24"><span class="kw">interface</span> <span class="dt">Out</span><span class="op">&lt;</span><span class="kw">out</span> <span class="dt">A</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-25" title="25"></a>
<a class="sourceLine" id="cb2-26" title="26"></a>
<a class="sourceLine" id="cb2-27" title="27"><span class="co">// A well-formed type constructor with no supertypes</span></a>
<a class="sourceLine" id="cb2-28" title="28"><span class="co">// S : Number is a bounded type parameter</span></a>
<a class="sourceLine" id="cb2-29" title="29"><span class="co">// (S &lt;: Number)</span></a>
<a class="sourceLine" id="cb2-30" title="30"><span class="kw">interface</span> <span class="dt">NumberWrapper</span><span class="op">&lt;</span><span class="dt">S</span> <span class="op">:</span> <span class="dt">Number</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-31" title="31"></a>
<a class="sourceLine" id="cb2-32" title="32"><span class="co">// A well-formed type constructor</span></a>
<a class="sourceLine" id="cb2-33" title="33"><span class="co">//   with a single parameterized supertype</span></a>
<a class="sourceLine" id="cb2-34" title="34"><span class="co">// NumberWrapper&lt;Int&gt; is well-formed,</span></a>
<a class="sourceLine" id="cb2-35" title="35"><span class="co">//   as Int &lt;: Number</span></a>
<a class="sourceLine" id="cb2-36" title="36"><span class="kw">interface</span> <span class="dt">IntWrapper</span> <span class="op">:</span> <span class="dt">NumberWrapper</span><span class="op">&lt;</span><span class="dt">Int</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-37" title="37"></a>
<a class="sourceLine" id="cb2-38" title="38"><span class="co">// An ill-formed type constructor,</span></a>
<a class="sourceLine" id="cb2-39" title="39"><span class="co">//   as NumberWrapper&lt;String&gt; is an ill-formed parameterized type</span></a>
<a class="sourceLine" id="cb2-40" title="40"><span class="co">//   (String not(&lt;:&gt;) Number)</span></a>
<a class="sourceLine" id="cb2-41" title="41"><span class="kw">interface</span> <span class="dt">InvalidWrapper</span> <span class="op">:</span> <span class="dt">NumberWrapper</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span></a></code></pre></div>
</blockquote>
<h4 id="type-parameters">Type parameters</h4>
<div class="paragraph">
<p><span class="sentence">Type parameters are a special kind of types, which are introduced by type constructors. </span><span class="sentence">They are considered well-formed concrete types only in the type context of their declaring type constructor.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When creating a parameterized type from a type constructor, its type parameters with their respective type arguments go through <a href="type-system.html#type-capturing">capturing</a> and create <em>captured</em> types, which follow special rules described in more detail below.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type parameters may be either unbounded or bounded. </span><span class="sentence">By default, a type parameter <span class="math inline">\(F\)</span> is unbounded, which is the same as saying it is a bounded type parameter of the form <span class="math inline">\(F &lt;: \operatorname{\texttt{kotlin.Any?}}\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A bounded type parameter additionally specifies upper type bounds for the type parameter and is defined as <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span>, where <span class="math inline">\(B_i\)</span> is an i-th upper bound on type parameter <span class="math inline">\(F\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed bounded type parameter of type constructor <span class="math inline">\(T\)</span>, <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span> should satisfy either of the following sets of conditions.</span></p>
</div>
<ul>
<li><span class="sentence">Bounded type parameter with regular bounds:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter of type constructor <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: B_i\)</span> must be concrete, non-type-parameter, well-formed type</span></li>
<li><span class="sentence">No more than one of <span class="math inline">\(B_i\)</span> may be a class type</span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the last condition is a nod to the single inheritance nature of Kotlin: any type may be a subtype of no more than one class type. </span><span class="sentence">For any two class types, either these types are in a subtyping relation (and you should use the more specific type in the bounded type parameter), or they are unrelated (and the bounded type parameter is empty).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Actual support for multiple class type bounds would be needed only in very rare cases, such as the following example.</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">interface</span> <span class="dt">Foo</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">interface</span> <span class="dt">Bar</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">open</span> <span class="kw">class</span> <span class="dt">A</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">class</span> <span class="dt">B</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="op">:</span> <span class="dt">A</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="kw">class</span> <span class="dt">C</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="kw">where</span> T : A&lt;<span class="kw">out</span> Foo&gt;, T : B&lt;<span class="kw">out</span> Bar&gt;</a>
<a class="sourceLine" id="cb3-8" title="8"><span class="co">// A convoluted way of saying T &lt;: B&lt;out Foo &amp; Bar&gt;,</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="co">// which contains a non-denotable intersection type</span></a></code></pre></div>
</blockquote>
<ul>
<li><span class="sentence">Bounded type parameter with type parameter bound:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter of type constructor <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(i = 1\)</span> (i.e., there is a single upper bound)</span></li>
<li><span class="sentence"><span class="math inline">\(B_1\)</span> must be well-formed <a href="type-system.html#type-parameters">type parameter</a></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">From the definition, it follows <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span> can be represented as <span class="math inline">\(F &lt;: U\)</span> where <span class="math inline">\(U = B_1 \mathbin{\operatorname{\&amp;}}\ldots \mathbin{\operatorname{\&amp;}}B_n\)</span> (aka <a href="type-system.html#intersection-types">intersection type</a>).</span></p>
</div>
<h5 id="function-type-parameters">Function type parameters</h5>
<div class="paragraph">
<p><span class="sentence">Function type parameters are a flavor of type parameters, which are used in <a href="declarations.html#function-declaration">function declarations</a> to create parameterized functions. </span><span class="sentence">They are considered well-formed concrete types only in the type context of their declaring function.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: one may view such parameterized functions as a kind of function type constructors.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Function type parameters work similarly to regular type parameters, however, they have the following limitations.</span></p>
</div>
<ul>
<li><span class="sentence">Function type parameters does not support specifying <a href="type-system.html#mixed-site-variance">mixed-site variance</a>.</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<h5 id="mixed-site-variance">Mixed-site variance</h5>
<div class="paragraph">
<p><span class="sentence">To implement subtyping between parameterized types, Kotlin uses <em>mixed-site variance</em>  a combination of declaration- and use-site variance, which is easier to understand and reason about, compared to wildcards from Java. </span><span class="sentence">Mixed-site variance means you can specify, whether you want your parameterized type to be co-, contra- or invariant on some type parameter, both in type parameter (declaration-site) and type argument (use-site).</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Info: <em>variance</em> is a way of describing how <a href="type-system.html#subtyping">subtyping</a> works for <em>variant</em> parameterized types. </span><span class="sentence">With declaration-site variance, for two <a href="type-system.html#subtyping">non-equivalent</a> types <span class="math inline">\(A &lt;: B\)</span>, subtyping between <code>T&lt;A&gt;</code> and <code>T&lt;B&gt;</code> depends on the variance of type parameter <span class="math inline">\(F\)</span> for some type constructor <span class="math inline">\(T\)</span>.</span></p>
</div>
<ul>
<li><span class="sentence">if <span class="math inline">\(F\)</span> is covariant (<span class="math inline">\(\operatorname{\texttt{out\,}}F\)</span>), <code>T&lt;A&gt;</code> <span class="math inline">\(&lt;:\)</span> <code>T&lt;B&gt;</code></span></li>
<li><span class="sentence">if <span class="math inline">\(F\)</span> is contravariant(<span class="math inline">\(\operatorname{\texttt{in\,}}F\)</span>), <code>T&lt;A&gt;</code> <span class="math inline">\(:&gt;\)</span> <code>T&lt;B&gt;</code></span></li>
<li><span class="sentence">if <span class="math inline">\(F\)</span> is invariant (default), <code>T&lt;A&gt;</code> <span class="math inline">\(\mathrel{\operatorname{\cancel{&lt;:&gt;}}}\)</span> <code>T&lt;B&gt;</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Use-site variance allows the user to change the type variance of an <em>invariant</em> type parameter by specifying it on the corresponding type argument. </span><span class="sentence"><span class="math inline">\(\operatorname{\texttt{out\,}}A\)</span> means covariant type argument, <span class="math inline">\(\operatorname{\texttt{in\,}}A\)</span> means contravariant type argument; for two <a href="type-system.html#subtyping">non-equivalent</a> types <span class="math inline">\(A &lt;: B\)</span> and an invariant type parameter <span class="math inline">\(F\)</span> of some type constructor <span class="math inline">\(T\)</span>, subtyping for use-site variance has the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><code>T&lt;out A&gt;</code> <span class="math inline">\(&lt;:\)</span> <code>T&lt;out B&gt;</code></span></li>
<li><span class="sentence"><code>T&lt;in A&gt;</code> <span class="math inline">\(:&gt;\)</span> <code>T&lt;in B&gt;</code></span></li>
<li><span class="sentence"><code>T&lt;A&gt;</code> <span class="math inline">\(&lt;:\)</span> <code>T&lt;out A&gt;</code></span></li>
<li><span class="sentence"><code>T&lt;A&gt;</code> <span class="math inline">\(&lt;:\)</span> <code>T&lt;in A&gt;</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Important: by the transitivity of the subtyping operator these rules imply that the following also holds:</span></p>
</div>
<ul>
<li><span class="sentence"><code>T&lt;A&gt;</code> <span class="math inline">\(&lt;:\)</span> <code>T&lt;out B&gt;</code></span></li>
<li><span class="sentence"><code>T&lt;in A&gt;</code> <span class="math inline">\(:&gt;\)</span> <code>T&lt;B&gt;</code></span></li>
</ul>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin does not support specifying both co- and contravariance at the same time, i.e., it is impossible to have <code>T&lt;out A in B&gt;</code> neither on declaration- nor on use-site.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, covariant type parameter <span class="math inline">\(\operatorname{\texttt{out\,}}A\)</span> of type constructor <span class="math inline">\(T\)</span> means <span class="math inline">\(T\)</span> is a producer of <span class="math inline">\(A\)</span>s and gets them out; contravariant type parameter <span class="math inline">\(\operatorname{\texttt{in\,}}A\)</span> of type constructor <span class="math inline">\(T\)</span> means <span class="math inline">\(T\)</span> is a consumer of <span class="math inline">\(A\)</span>s and takes them in.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For further discussion about mixed-site variance and its practical applications, we readdress you to <a href="type-system.html#subtyping">subtyping</a>.</span></p>
</div>
<h5 id="declaration-site-variance">Declaration-site variance</h5>
<div class="paragraph">
<p><span class="sentence">A type parameter <span class="math inline">\(F\)</span> may be invariant, covariant or contravariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">By default, all type parameters are invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a covariant type parameter, it is marked as <span class="math inline">\(\operatorname{\texttt{out\,}}F\)</span>. </span><span class="sentence">To specify a contravariant type parameter, it is marked as <span class="math inline">\(\operatorname{\texttt{in\,}}F\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The variance information is used by <a href="type-system.html#subtyping">subtyping</a> and for checking allowed operations on values of co- and contravariant type parameters.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: declaration-site variance can be used only when declaring types, e.g., <a href="type-system.html#function-type-parameters">function type parameters</a> cannot be variant.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// A type constructor with an invariant type parameter</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">interface</span> <span class="dt">Invariant</span><span class="op">&lt;</span><span class="dt">A</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">// A type constructor with a covariant type parameter</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">interface</span> <span class="dt">Out</span><span class="op">&lt;</span><span class="kw">out</span> <span class="dt">A</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">// A type constructor with a contravariant type parameter</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">interface</span> <span class="dt">In</span><span class="op">&lt;</span><span class="kw">in</span> <span class="dt">A</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="kw">fun</span> <span class="fu">testInvariant</span><span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">var</span> <span class="va">invInt</span><span class="op">:</span> <span class="dt">Invariant</span><span class="op">&lt;</span><span class="dt">Int</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="kw">var</span> <span class="va">invNumber</span><span class="op">:</span> <span class="dt">Invariant</span><span class="op">&lt;</span><span class="dt">Number</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb4-11" title="11">    </a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="cf">if</span> (random) invInt = invNumber <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="cf">else</span> invNumber = invInt <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb4-14" title="14">    </a>
<a class="sourceLine" id="cb4-15" title="15">    <span class="co">// Invariant type parameters do not create subtyping</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb4-17" title="17"></a>
<a class="sourceLine" id="cb4-18" title="18"><span class="kw">fun</span> <span class="fu">testOut</span><span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="kw">var</span> <span class="va">outInt</span><span class="op">:</span> <span class="dt">Out</span><span class="op">&lt;</span><span class="dt">Int</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb4-20" title="20">    <span class="kw">var</span> <span class="va">outNumber</span><span class="op">:</span> <span class="dt">Out</span><span class="op">&lt;</span><span class="dt">Number</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb4-21" title="21">    </a>
<a class="sourceLine" id="cb4-22" title="22">    <span class="cf">if</span> (random) outInt = outNumber <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb4-23" title="23">    <span class="cf">else</span> outNumber = outInt <span class="co">// OK</span></a>
<a class="sourceLine" id="cb4-24" title="24">    </a>
<a class="sourceLine" id="cb4-25" title="25">    <span class="co">// Covariant type parameters create &quot;same-way&quot; subtyping</span></a>
<a class="sourceLine" id="cb4-26" title="26">    <span class="co">//   Int &lt;: Number =&gt; Out&lt;Int&gt; &lt;: Out&lt;Number&gt;</span></a>
<a class="sourceLine" id="cb4-27" title="27">    <span class="co">// (more specific type Out&lt;Int&gt; can be assigned</span></a>
<a class="sourceLine" id="cb4-28" title="28">    <span class="co">//  to a less specific type Out&lt;Number&gt;)</span></a>
<a class="sourceLine" id="cb4-29" title="29"><span class="op">}</span></a>
<a class="sourceLine" id="cb4-30" title="30"></a>
<a class="sourceLine" id="cb4-31" title="31"><span class="kw">fun</span> <span class="fu">testIn</span><span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-32" title="32">    <span class="kw">var</span> <span class="va">inInt</span><span class="op">:</span> <span class="dt">In</span><span class="op">&lt;</span><span class="dt">Int</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb4-33" title="33">    <span class="kw">var</span> <span class="va">inNumber</span><span class="op">:</span> <span class="dt">In</span><span class="op">&lt;</span><span class="dt">Number</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb4-34" title="34">    </a>
<a class="sourceLine" id="cb4-35" title="35">    <span class="cf">if</span> (random) inInt = inNumber <span class="co">// OK</span></a>
<a class="sourceLine" id="cb4-36" title="36">    <span class="cf">else</span> inNumber = inInt <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb4-37" title="37">    </a>
<a class="sourceLine" id="cb4-38" title="38">    <span class="co">// Contravariant type parameters create &quot;opposite-way&quot; subtyping</span></a>
<a class="sourceLine" id="cb4-39" title="39">    <span class="co">//   Int &lt;: Number =&gt; In&lt;Int&gt; :&gt; In&lt;Number&gt;</span></a>
<a class="sourceLine" id="cb4-40" title="40">    <span class="co">// (more specific type In&lt;Number&gt; can be assigned</span></a>
<a class="sourceLine" id="cb4-41" title="41">    <span class="co">//  to a less specific type In&lt;Int&gt;)</span></a>
<a class="sourceLine" id="cb4-42" title="42"><span class="op">}</span></a></code></pre></div>
</blockquote>
<h5 id="use-site-variance">Use-site variance</h5>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports use-site variance, by specifying the variance for type arguments. </span><span class="sentence">Similarly to type parameters, one can have type arguments being co-, contra- or invariant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: use-site variance cannot be used when declaring a supertype top-level type argument.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">By default, all type arguments are invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a covariant type argument, it is marked as <span class="math inline">\(\operatorname{\texttt{out\,}}A\)</span>. </span><span class="sentence">To specify a contravariant type argument, it is marked as <span class="math inline">\(\operatorname{\texttt{in\,}}A\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin prohibits contradictory combinations of declaration- and use-site variance as follows.</span></p>
</div>
<ul>
<li><span class="sentence">It is a compile-time error to use a covariant type argument in a contravariant type parameter</span></li>
<li><span class="sentence">It is a compile-time error to use a contravariant type argument in a covariant type parameter</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In case one cannot specify any well-formed type argument, but still needs to use a parameterized type in a type-safe way, they may use <em>bivariant</em> type argument <span class="math inline">\(\star\)</span>, which is roughly equivalent to a combination of <span class="math inline">\(\operatorname{\texttt{out\,}}\operatorname{\texttt{kotlin.Any?}}\)</span> and <span class="math inline">\(\operatorname{\texttt{in\,}}\operatorname{\texttt{kotlin.Nothing}}\)</span> (for further details, see <a href="type-system.html#subtyping">subtyping</a>).</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <span class="math inline">\(T[\star]\)</span> means I can give out something very generic (<span class="math inline">\(\operatorname{\texttt{kotlin.Any?}}\)</span>) and cannot take in anything.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// A type constructor with an invariant type parameter</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">interface</span> <span class="dt">Inv</span><span class="op">&lt;</span><span class="dt">A</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">fun</span> <span class="fu">test</span><span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="kw">var</span> <span class="va">invInt</span><span class="op">:</span> <span class="dt">Inv</span><span class="op">&lt;</span><span class="dt">Int</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="kw">var</span> <span class="va">invNumber</span><span class="op">:</span> <span class="dt">Inv</span><span class="op">&lt;</span><span class="dt">Number</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">var</span> <span class="va">outInt</span><span class="op">:</span> <span class="dt">Inv</span><span class="op">&lt;</span><span class="kw">out</span> <span class="dt">Int</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="kw">var</span> <span class="va">outNumber</span><span class="op">:</span> <span class="dt">Inv</span><span class="op">&lt;</span><span class="kw">out</span> <span class="dt">Number</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">var</span> <span class="va">inInt</span><span class="op">:</span> <span class="dt">Inv</span><span class="op">&lt;</span><span class="kw">in</span> <span class="dt">Int</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="kw">var</span> <span class="va">inNumber</span><span class="op">:</span> <span class="dt">Inv</span><span class="op">&lt;</span><span class="kw">in</span> <span class="dt">Number</span><span class="op">&gt;</span> <span class="op">=</span> ...</a>
<a class="sourceLine" id="cb5-11" title="11">    </a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="cf">when</span> (random) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-13" title="13">        <span class="dv">1</span> -&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb5-14" title="14">            inInt = invInt    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb5-15" title="15">            <span class="co">// T&lt;in Int&gt; :&gt; T&lt;Int&gt;</span></a>
<a class="sourceLine" id="cb5-16" title="16">            </a>
<a class="sourceLine" id="cb5-17" title="17">            inInt = invNumber <span class="co">// OK</span></a>
<a class="sourceLine" id="cb5-18" title="18">            <span class="co">// T&lt;in Int&gt; :&gt; T&lt;in Number&gt; :&gt; T&lt;Number&gt;</span></a>
<a class="sourceLine" id="cb5-19" title="19">        <span class="op">}</span></a>
<a class="sourceLine" id="cb5-20" title="20">        <span class="dv">2</span> -&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb5-21" title="21">            outNumber = invInt    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb5-22" title="22">            <span class="co">// T&lt;out Number&gt; :&gt; T&lt;out Int&gt; :&gt; T&lt;Int&gt;</span></a>
<a class="sourceLine" id="cb5-23" title="23">            </a>
<a class="sourceLine" id="cb5-24" title="24">            outNumber = invNumber <span class="co">// OK</span></a>
<a class="sourceLine" id="cb5-25" title="25">            <span class="co">// T&lt;out Number&gt; :&gt; T&lt;Number&gt;</span></a>
<a class="sourceLine" id="cb5-26" title="26">        <span class="op">}</span></a>
<a class="sourceLine" id="cb5-27" title="27">        <span class="dv">3</span> -&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb5-28" title="28">            invInt = inInt  <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb5-29" title="29">            invInt = outInt <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb5-30" title="30">            <span class="co">// It is invalid to assign less specific type</span></a>
<a class="sourceLine" id="cb5-31" title="31">            <span class="co">// to a more specific one</span></a>
<a class="sourceLine" id="cb5-32" title="32">            <span class="co">//   T&lt;Int&gt; &lt;: T&lt;in Int&gt;</span></a>
<a class="sourceLine" id="cb5-33" title="33">            <span class="co">//   T&lt;Int&gt; &lt;: T&lt;out Int&gt;</span></a>
<a class="sourceLine" id="cb5-34" title="34">        <span class="op">}</span></a>
<a class="sourceLine" id="cb5-35" title="35">        <span class="dv">4</span> -&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb5-36" title="36">            inInt = outInt    <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb5-37" title="37">            inInt = outNumber <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb5-38" title="38">            <span class="co">// types with co- and contravariant type parameters</span></a>
<a class="sourceLine" id="cb5-39" title="39">            <span class="co">// are not connected by subtyping</span></a>
<a class="sourceLine" id="cb5-40" title="40">            <span class="co">//   T&lt;in Int&gt; not(&lt;:&gt;) T&lt;out Int&gt;</span></a>
<a class="sourceLine" id="cb5-41" title="41">        <span class="op">}</span></a>
<a class="sourceLine" id="cb5-42" title="42">    <span class="op">}</span></a>
<a class="sourceLine" id="cb5-43" title="43"><span class="op">}</span></a></code></pre></div>
</blockquote>
<h4 id="type-capturing">Type capturing</h4>
<div class="paragraph">
<p><span class="sentence">Type capturing (similarly to Java capture conversion) is used when instantiating type constructors; it creates <em>abstract captured</em> types based on the type information of both type parameters and arguments, which present a unified view on the resulting types and simplifies further reasoning.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The reasoning behind type capturing is closely related to variant parameterized types being a form of <em>bounded existential types</em>; e.g., <code>A&lt;out T&gt;</code> may be loosely considered as the following existential type: <span class="math inline">\(\exists X : X &lt;: T . A\langle X\rangle\)</span>. </span><span class="sentence">Informally, a bounded existential type describes a <em>set</em> of possible types, which satisfy its bound constraints. </span><span class="sentence">Before such a type can be used, it needs to be <em>opened</em> (or <em>unpacked</em>): existentially quantified type variables are lifted to fresh type variables with corresponding bounds. </span><span class="sentence">We call these type variables <em>captured</em> types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For a given type constructor <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span>, its instance <span class="math inline">\(T[\sigma] = T\langle \tau \rangle\)</span> uses the following rules to create captured type <span class="math inline">\(K_i\)</span> from the type parameter <span class="math inline">\(F_i\)</span> and type argument <span class="math inline">\(A_i\)</span>, at least one of which should have specified variance to create a captured type. </span><span class="sentence">In case both type parameter and type argument are invariant, their captured type is <em>equivalent</em> to <span class="math inline">\(A_i\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: type capturing is <strong>not</strong> recursive.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <strong>All</strong> applicable rules are used to create the resulting constraint set.</span></p>
</div>
</blockquote>
<ul>
<li><span class="sentence">For a covariant type parameter <span class="math inline">\(\operatorname{\texttt{out\,}}F_i\)</span>, if <span class="math inline">\(A_i\)</span> is an ill-formed type or a contravariant type argument, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i &lt;: A_i\)</span>.</span></li>
<li><span class="sentence">For a contravariant type parameter <span class="math inline">\(\operatorname{\texttt{in\,}}F_i\)</span>, if <span class="math inline">\(A_i\)</span> is an ill-formed type or a covariant type argument, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i :&gt; A_i\)</span>.</span></li>
<li><div class="paragraph">
<p><span class="sentence">For a bounded type parameter <span class="math inline">\(F_i &lt;: U_i \equiv B_1 \mathbin{\operatorname{\&amp;}}\ldots \mathbin{\operatorname{\&amp;}}B_m\)</span>, if <span class="math inline">\(\neg (A_i &lt;: \tau U_i)\)</span>, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i &lt;: \tau U_i\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: captured substitution <span class="math inline">\(\tau : F_1 = K_1, \ldots, F_n = K_n\)</span> manipulates captured types.</span></p>
</div>
</blockquote></li>
<li><span class="sentence">For a covariant type argument <span class="math inline">\(\operatorname{\texttt{out\,}}A_i\)</span>, if <span class="math inline">\(F_i\)</span> is a contravariant type parameter, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i &lt;: A_i\)</span>.</span></li>
<li><div class="paragraph">
<p><span class="sentence">For a contravariant type argument <span class="math inline">\(\operatorname{\texttt{in\,}}A_i\)</span>, if <span class="math inline">\(F_i\)</span> is a covariant type parameter, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i :&gt; A_i\)</span>.</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">For a bivariant type argument <span class="math inline">\(\star\)</span>, <span class="math inline">\(\operatorname{\texttt{kotlin.Nothing}}&lt;: K_i &lt;: \operatorname{\texttt{kotlin.Any?}}\)</span>.</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">Otherwise, <span class="math inline">\(K_i \equiv A_i\)</span>.</span></p>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">By construction, every captured type <span class="math inline">\(K\)</span> has the following form:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[\{L_1 &lt;: K, \ldots, L_p &lt;: K, K &lt;: U_1, \ldots, K &lt;: U_q\}\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">which can be represented as</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[L &lt;: K &lt;: U\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">where <span class="math inline">\(L = L_1 \mathbin{\operatorname{|}}\ldots \mathbin{\operatorname{|}}L_p\)</span> and <span class="math inline">\(U = U_1 \mathbin{\operatorname{\&amp;}}\ldots \mathbin{\operatorname{\&amp;}}U_q\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for implementation reasons the compiler may <a href="type-system.html#type-approximation">approximate</a> <span class="math inline">\(L\)</span> and/or <span class="math inline">\(U\)</span>; for example, in the current implementation <span class="math inline">\(L\)</span> is always approximated to be a single type.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as every captured type corresponds to a fresh type variable, two different captured types <span class="math inline">\(K_i\)</span> and <span class="math inline">\(K_j\)</span> which describe the same set of possible types (i.e., their constraint sets are equal) are <em>not</em> considered equal. </span><span class="sentence">However, in some cases <a href="type-inference.html#type-inference">type inference</a> may <a href="type-system.html#type-approximation">approximate</a> a captured type <span class="math inline">\(K\)</span> to a concrete type <span class="math inline">\(K^{\approx}\)</span>; in our case, it would be that <span class="math inline">\(K_i^{\approx} \equiv K_j^{\approx}\)</span>.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Need to think more about this part)</span></p>
</div>
</div>
<h4 id="type-containment">Type containment</h4>
<div class="paragraph">
<p><span class="sentence">Type containment operator <span class="math inline">\(\preceq\)</span> is used to decide, whether a type <span class="math inline">\(A\)</span> is contained in another type <span class="math inline">\(B\)</span> denoted <span class="math inline">\(A \preceq B\)</span>, for the purposes of establishing type argument <a href="type-system.html#subtyping">subtyping</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Let <span class="math inline">\(A, B\)</span> be concrete, well-defined non-type-parameter types, <span class="math inline">\(K_A, K_B\)</span> be captured types.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: type parameters <span class="math inline">\(F_i &lt;: U_i\)</span> are handled as if they have been converted to well-formed captured types <span class="math inline">\(K_i : \operatorname{\texttt{kotlin.Nothing}}&lt;: K_i &lt;: U_i\)</span>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\preceq\)</span> is defined as follows.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A \preceq B\)</span> if <span class="math inline">\(A \equiv B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \preceq \operatorname{\texttt{out\,}}B\)</span> if <span class="math inline">\(A &lt;: B\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A \preceq \operatorname{\texttt{in\,}}B\)</span> if <span class="math inline">\(A :&gt; B\)</span></span></p>
</div></li>
<li><span class="sentence"><span class="math inline">\(\operatorname{\texttt{out\,}}A \preceq \operatorname{\texttt{out\,}}B\)</span> if <span class="math inline">\(A &lt;: B\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\texttt{in\,}}A \preceq \operatorname{\texttt{in\,}}B\)</span> if <span class="math inline">\(A :&gt; B\)</span></span></p>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Rules for captured types follow the same structure.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(K_A \preceq K_B\)</span> if <span class="math inline">\(K_A \equiv K_B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(K_A \preceq \operatorname{\texttt{out\,}}K_B\)</span> if <span class="math inline">\(K_A &lt;: K_B\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(K_A \preceq \operatorname{\texttt{in\,}}K_B\)</span> if <span class="math inline">\(K_A :&gt; K_B\)</span></span></p>
</div></li>
<li><span class="sentence"><span class="math inline">\(\operatorname{\texttt{out\,}}K_A \preceq \operatorname{\texttt{out\,}}K_B\)</span> if <span class="math inline">\(K_A &lt;: K_B\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\texttt{in\,}}K_A \preceq \operatorname{\texttt{in\,}}K_B\)</span> if <span class="math inline">\(K_A :&gt; K_B\)</span></span></p>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In case we need to establish type containment between regular type <span class="math inline">\(A\)</span> and captured type <span class="math inline">\(K_B\)</span>, <span class="math inline">\(A\)</span> is converted to captured type <span class="math inline">\(K_A : A &lt;: K_A &lt;: A\)</span>.</span></p>
</div>
<h4 id="function-types">Function types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin has first-order functions; e.g., it supports function types, which describe the argument and return types of its corresponding function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A function type <span class="math inline">\(\operatorname{\text{FT}}\)</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[\operatorname{\text{FT}}(A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">argument types <span class="math inline">\(A_i\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and may be considered the following instantiation of a special type constructor <span class="math inline">\(\operatorname{\text{FunctionN}}(\operatorname{\texttt{in\,}}P_1, \ldots, \operatorname{\texttt{in\,}}P_n, \operatorname{\texttt{out\,}}R)\)</span> (please note the variance of type parameters)</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[\operatorname{\text{FT}}(A_1, \ldots, A_n) \rightarrow R \equiv \operatorname{\text{FunctionN}}[A_1, \ldots, A_n, R]\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">These <span class="math inline">\(\operatorname{\text{FunctionN}}\)</span> types follow the rules of regular type constructors and parameterized types w.r.t. subtyping.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A function type with receiver <span class="math inline">\(\operatorname{\text{FTR}}\)</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[\operatorname{\text{FTR}}(\operatorname{\text{RT}}, A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">receiver type <span class="math inline">\(\operatorname{\text{RT}}\)</span></span></li>
<li><span class="sentence">argument types <span class="math inline">\(A_i\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">From the type systems point of view, it is equivalent to the following function type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[\operatorname{\text{FTR}}(\operatorname{\text{RT}}, A_1, \ldots, A_n) \rightarrow R \equiv \operatorname{\text{FT}}(\operatorname{\text{RT}}, A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">i.e., receiver is considered as yet another argument of its function type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that, for example, these two types are equivalent w.r.t. type system</span></p>
</div>
<ul>
<li><span class="sentence"><code>Int.(Int) -&gt; String</code></span></li>
<li><span class="sentence"><code>(Int, Int) -&gt; String</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, these two types are <strong>not</strong> equivalent w.r.t. <a href="overload-resolution.html#overload-resolution">overload resolution</a>, as it distinguishes between functions with and without receiver.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Specify other cases when these two types are <strong>not</strong> equivalent)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Furthermore, all function types <span class="math inline">\(\operatorname{\text{FunctionN}}\)</span> are subtypes of a general argument-agnostic type <a href="built-in-types-and-their-semantics.html#kotlin.function-1"><span class="math inline">\(\operatorname{\texttt{kotlin.Function}}\)</span></a> for the purpose of unification; this subtyping relation is also used in <a href="overload-resolution.html#determining-function-applicability-for-a-specific-call">overload resolution</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: a compiler implementation may consider a function type <span class="math inline">\(\operatorname{\text{FunctionN}}\)</span> to have additional supertypes, if it is necessary.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// A function of type Function1&lt;Number, Number&gt;</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co">//   or (Number) -&gt; Number</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">fun</span> <span class="fu">foo</span><span class="op">(</span><span class="va">i</span><span class="op">:</span> <span class="dt">Number</span><span class="op">):</span> <span class="dt">Number</span> = ...</a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">// A valid assignment w.r.t. function type variance</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="co">// Function1&lt;in Int, out Any&gt; :&gt; Function1&lt;in Number, out Number&gt;</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">val</span> <span class="va">fooRef</span><span class="op">:</span> <span class="op">(</span><span class="dt">Int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">Any</span> <span class="op">=</span> ::foo</a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="co">// A function with receiver of type Function1&lt;Number, Number&gt;</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="co">//   or Number.() -&gt; Number</span></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="kw">fun</span> <span class="fu">Number</span><span class="op">.</span><span class="fu">bar</span><span class="op">():</span> <span class="dt">Number</span> = ...</a>
<a class="sourceLine" id="cb6-12" title="12"></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="co">// A valid assignment w.r.t. function type variance</span></a>
<a class="sourceLine" id="cb6-14" title="14"><span class="co">// Receiver is just yet another function argument</span></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="co">// Function1&lt;in Int, out Any&gt; :&gt; Function1&lt;in Number, out Number&gt;</span></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="kw">val</span> <span class="va">barRef</span><span class="op">:</span> <span class="op">(</span><span class="dt">Int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">Any</span> <span class="op">=</span> Number::bar</a></code></pre></div>
</blockquote>
<h5 id="suspending-function-types">Suspending function types</h5>
<div class="paragraph">
<p><span class="sentence">Kotlin supports structured concurrency in the form of <a href="coroutines.html#coroutines-1">coroutines</a> via <a href="coroutines.html#suspending-functions">suspending functions</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For the purposes of type system, a suspending function has a <em>suspending</em> function type <span class="math inline">\(\operatorname{\texttt{suspend}}\operatorname{\text{FT}}(A_1, \ldots, A_n) \rightarrow R\)</span>, which is <strong>unrelated by subtyping</strong> to any non-suspending function type. </span><span class="sentence">This is important for <a href="overload-resolution.html#overload-resolution">overload resolution</a> and <a href="type-inference.html#type-inference">type inference</a>, as it directly influences the types of function values and the applicability of different functions w.r.t. overloading.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Most function values have either non-suspending or suspending function type based on their declarations. </span><span class="sentence">However, as <a href="expressions.html#lambda-literals">lambda literals</a> do not have any explicitely declared function type, they are considered as possibly being both non-suspending and suspending function type, with the final selection done during <a href="type-inference.html#type-inference">type inference</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">fun</span> <span class="fu">foo</span><span class="op">(</span><span class="va">i</span><span class="op">:</span> <span class="dt">Int</span><span class="op">):</span> <span class="dt">String</span> = <span class="al">TODO()</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">fun</span> <span class="fu">bar</span><span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="kw">val</span> <span class="va">fooRef</span><span class="op">:</span> <span class="op">(</span><span class="dt">Int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">=</span> ::foo</a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="kw">val</span> <span class="va">fooLambda</span><span class="op">:</span> <span class="op">(</span><span class="dt">Int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">=</span> <span class="op">{</span> it.toString() <span class="op">}</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">val</span> <span class="va">suspendFooLambda</span><span class="op">:</span> <span class="kw">suspend</span> <span class="op">(</span><span class="dt">Int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">=</span> <span class="op">{</span> it.toString() <span class="op">}</span></a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="co">// Error: as suspending and non-suspending</span></a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="co">//   function types are unrelated</span></a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="co">// val error: suspend (Int) -&gt; String = ::foo</span></a>
<a class="sourceLine" id="cb7-11" title="11">    <span class="co">// val error: suspend (Int) -&gt; String = fooLambda</span></a>
<a class="sourceLine" id="cb7-12" title="12">    <span class="co">// val error: (Int) -&gt; String = suspendFooLambda</span></a>
<a class="sourceLine" id="cb7-13" title="13"><span class="op">}</span></a></code></pre></div>
</blockquote>
<h4 id="flexible-types">Flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin, being a multi-platform language, needs to support transparent interoperability with platform-dependent code. </span><span class="sentence">However, this presents a problem in that some platforms may not support null safety the way Kotlin does. </span><span class="sentence">To deal with this, Kotlin supports <em>gradual typing</em> in the form of flexible types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A flexible type represents a range of possible types between type <span class="math inline">\(L\)</span> (lower bound) and type <span class="math inline">\(U\)</span> (upper bound), written as <span class="math inline">\((L..U)\)</span>. </span><span class="sentence">One should note flexible types are <em>non-denotable</em>, i.e., one cannot explicitly declare a variable with flexible type, these types are created by the type system when needed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed flexible type, <span class="math inline">\((L..U)\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are well-formed concrete types</span></li>
<li><span class="sentence"><span class="math inline">\(L &lt;: U\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are <strong>not</strong> flexible types (but may contain other flexible types as some of their type arguments)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">As the name suggests, flexible types are flexible  a value of type <span class="math inline">\((L..U)\)</span> can be used in any context, where one of the possible types between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> is needed (for more details, see <a href="type-system.html#subtyping-for-flexible-types">subtyping rules for flexible types</a>). </span><span class="sentence">However, the actual runtime type <span class="math inline">\(T\)</span> will be a specific type satisfying <span class="math inline">\(\exists S : T &lt;: S \land L &lt;: S &lt;: U\)</span>, thus making the substitution possibly unsafe, which is why Kotlin generates dynamic assertions, when it is impossible to prove statically the safety of flexible type use.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO([Kotlin.*] Details of assertion generation?)</span></p>
</div>
</div>
<h5 id="dynamic-type">Dynamic type</h5>
<div class="paragraph">
<p><span class="sentence">Kotlin includes a special <code>dynamic</code> type, which in many contexts can be viewed as a flexible type <span class="math inline">\((\operatorname{\texttt{kotlin.Nothing}}..\operatorname{\texttt{kotlin.Any?}})\)</span>. </span><span class="sentence">By definition, this type represents <em>any</em> possible Kotlin type, and may be used to support interoperability with dynamically typed libraries, platforms or languages.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">However, as a platform may assign special meaning to the values of <code>dynamic</code> type, it may be handled differently from the regular flexible type. </span><span class="sentence">These differences are to be explained in the corresponding platform-dependent sections of this specification.</span></p>
</div>
<h5 id="platform-types">Platform types</h5>
<div class="paragraph">
<p><span class="sentence">The main use cases for flexible types are <em>platform types</em>  types which the Kotlin compiler uses, when interoperating with code written for another platform (e.g., Java). </span><span class="sentence">In this case all types on the interoperability boundary are subject to <em>flexibilization</em>  the process of converting a platform-specific type to a Kotlin-compatible flexible type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For further details on how <em>flexibilization</em> is done, see:</span></p>
</div>
<ul>
<li><span class="sentence">[Platform types for Java][TODO(need a way to have same section names in different parts of the spec)]</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: platform types should not be confused with <em>multi-platform projects</em>  another Kotlin feature targeted at supporting platform interop.</span></p>
</div>
</blockquote>
<h4 id="nullable-types">Nullable types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports null safety by having two type universes  nullable and non-nullable. </span><span class="sentence">All classifier type declarations, built-in or user-defined, create non-nullable types, i.e., types which cannot hold <code>null</code> value at runtime.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a nullable version of type <span class="math inline">\(T\)</span>, one needs to use <span class="math inline">\(T?\)</span> as a type. </span><span class="sentence">Redundant nullability specifiers are ignored  <span class="math inline">\(T?? \equiv T?\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, question mark means <span class="math inline">\(T?\)</span> may hold values of type <span class="math inline">\(T\)</span> or value <code>null</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed nullable type, <span class="math inline">\(T?\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a well-formed concrete type</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: if an operation is safe regardless of absence or presence of <code>null</code>, e.g., assignment of one nullable value to another, it can be used as-is for nullable types. </span><span class="sentence">For operations on <span class="math inline">\(T?\)</span> which may violate null safety, e.g., access to a property, one has the following null-safe options:</span></p>
</div>
<ol type="1">
<li><span class="sentence">Use safe operations</span>
<ul>
<li><span class="sentence"><a href="expressions.html#navigation-operators">safe call</a></span></li>
</ul></li>
<li><span class="sentence">Downcast from <span class="math inline">\(T?\)</span> to <span class="math inline">\(T!!\)</span></span>
<ul>
<li><span class="sentence"><a href="expressions.html#cast-expression">unsafe cast</a></span></li>
<li><span class="sentence"><a href="expressions.html#type-checking-expression">type check</a> combined with <a href="type-inference.html#smart-casts">smart casts</a></span></li>
<li><span class="sentence">null check combined with <a href="type-inference.html#smart-casts">smart casts</a></span></li>
<li><span class="sentence"><a href="expressions.html#not-null-assertion-expression">not-null assertion operator</a></span></li>
</ul></li>
<li><span class="sentence">Supply a default value to use if <code>null</code> is present</span>
<ul>
<li><span class="sentence"><a href="expressions.html#elvis-operator-expression">elvis operator</a></span></li>
</ul></li>
</ol>
</blockquote>
<h5 id="nullability-lozenge">Nullability lozenge</h5>
<blockquote>
<div class="diagram">
<img src='data:image/svg+xml;utf8,<?xml version="1.0"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:jfreesvg="http://www.jfree.org/jfreesvg/svg" width="289" height="194" text-rendering="auto" shape-rendering="auto">
<defs></defs>
<line x1="7.5" y1="7.5" x2="127.5" y2="7.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="277.5" y1="7.5" x2="397.5" y2="7.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="135" y1="52.5" x2="277.5" y2="52.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><g style="fill: rgb(0,0,0); fill-opacity: 1.0; stroke: none" transform="matrix(0.7,0,0,0.7,0,0)" ><path d="M 127.5 52.5 L 142.5 47.5 L 142.5 57.5 Z "/></g><line x1="7.5" y1="97.5" x2="127.5" y2="97.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="277.5" y1="97.5" x2="397.5" y2="97.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="202.5" y1="127.5" x2="292.5" y2="127.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="112.5" y1="142.5" x2="202.5" y2="142.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="7.5" y1="172.5" x2="127.5" y2="172.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="277.5" y1="172.5" x2="397.5" y2="172.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="135" y1="217.5" x2="277.5" y2="217.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><g style="fill: rgb(0,0,0); fill-opacity: 1.0; stroke: none" transform="matrix(0.7,0,0,0.7,0,0)" ><path d="M 127.5 217.5 L 142.5 212.5 L 142.5 222.5 Z "/></g><line x1="7.5" y1="262.5" x2="127.5" y2="262.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="277.5" y1="262.5" x2="397.5" y2="262.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="7.5" y1="7.5" x2="7.5" y2="97.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="127.5" y1="7.5" x2="127.5" y2="97.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="277.5" y1="7.5" x2="277.5" y2="97.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="397.5" y1="7.5" x2="397.5" y2="97.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="292.5" y1="97.5" x2="292.5" y2="127.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="202.5" y1="127.5" x2="202.5" y2="142.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="112.5" y1="142.5" x2="112.5" y2="165" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><g style="fill: rgb(0,0,0); fill-opacity: 1.0; stroke: none" transform="matrix(0.7,0,0,0.7,0,0)" ><path d="M 112.5 172.5 L 107.5 157.5 L 117.5 157.5 Z "/></g><line x1="7.5" y1="172.5" x2="7.5" y2="262.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="127.5" y1="172.5" x2="127.5" y2="262.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="277.5" y1="172.5" x2="277.5" y2="262.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="397.5" y1="172.5" x2="397.5" y2="262.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="54.5" y="60.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >A?</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="324.5" y="60.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >B?</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="47.5" y="225.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >A!!</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="317.5" y="225.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >B!!</text></g></svg>
' />
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Nullability lozenge represents valid possible <a href="type-system.html#subtyping">subtyping</a> relations between two nullable or non-nullable types in different combinations of their <em>versions</em>. </span><span class="sentence">For type <span class="math inline">\(T\)</span>, we call <span class="math inline">\(T!!\)</span> its non-nullable version, <span class="math inline">\(T?\)</span> its nullable version.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: trivial subtyping relation <span class="math inline">\(A!! &lt;: A?\)</span> is not represented in the nullability lozenge.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Nullability lozenge may also help in establishing subtyping between two types by following its structure.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Regular (non-type-variable) types are mapped to nullability lozenge <em>vertices</em>, as for them <span class="math inline">\(A\)</span> corresponds to <span class="math inline">\(A!!\)</span>, and <span class="math inline">\(A?\)</span> corresponds to <span class="math inline">\(A?\)</span>. </span><span class="sentence">Following the lozenge structure, for regular types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, as soon as we have established any valid subtyping between two versions of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, it implies subtyping between all other valid w.r.t. nullability lozenge combinations of versions of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type variable types (e.g., captured types or type parameters) are maped to either nullability lozenge <em>edges</em> or <em>vertices</em>, as for them <span class="math inline">\(T\)</span> corresponds to either <span class="math inline">\(T!!\)</span> or <span class="math inline">\(T?\)</span>, and <span class="math inline">\(T?\)</span> corresponds to <span class="math inline">\(T?\)</span>. </span><span class="sentence">Following the lozenge structure, for type variable type <span class="math inline">\(T\)</span> (i.e., either non-nullable or nullable version) we need to consider valid subtyping for both versions <span class="math inline">\(T!!\)</span> and <span class="math inline">\(T?\)</span> w.r.t. nullability lozenge.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example: if we have <span class="math inline">\(\operatorname{\texttt{kotlin.Int}}? &lt;: T?\)</span>, we also have <span class="math inline">\(\operatorname{\texttt{kotlin.Int}}!! &lt;: T?\)</span> and <span class="math inline">\(\operatorname{\texttt{kotlin.Int}}!! &lt;: T!!\)</span>, meaning we can establish <span class="math inline">\(\operatorname{\texttt{kotlin.Int}}!! &lt;: T \equiv \operatorname{\texttt{kotlin.Int}}&lt;: T\)</span>.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example: if we have <span class="math inline">\(T? &lt;: \operatorname{\texttt{kotlin.Int}}?\)</span>, we also have <span class="math inline">\(T!! &lt;: \operatorname{\texttt{kotlin.Int}}?\)</span> and <span class="math inline">\(T!! &lt;: \operatorname{\texttt{kotlin.Int}}!!\)</span>, however, we can establish only <span class="math inline">\(T &lt;: \operatorname{\texttt{kotlin.Int}}?\)</span>, as <span class="math inline">\(T &lt;: \operatorname{\texttt{kotlin.Int}}\)</span> would need <span class="math inline">\(T? &lt;: \operatorname{\texttt{kotlin.Int}}!!\)</span> which is forbidden by the nullability lozenge.</span></p>
</div>
</blockquote>
<h4 id="intersection-types">Intersection types</h4>
<div class="paragraph">
<p><span class="sentence">Intersection types are special <em>non-denotable</em> types used to express the fact that a value belongs to <em>all</em> of <em>several</em> types at the same time.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Intersection type of two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is denoted <span class="math inline">\(A \mathbin{\operatorname{\&amp;}}B\)</span> and is equivalent to the <a href="type-system.html#greatest-lower-bound">greatest lower bound</a> of its components <span class="math inline">\(\operatorname{\text{GLB}}(A, B)\)</span>. </span><span class="sentence">Thus, the normalization procedure for <span class="math inline">\(\operatorname{\text{GLB}}\)</span> may be used to <em>normalize</em> an intersection type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means intersection types are commutative and associative (following the GLB properties); e.g., <span class="math inline">\(A \mathbin{\operatorname{\&amp;}}B\)</span> is the same type as <span class="math inline">\(B \mathbin{\operatorname{\&amp;}}A\)</span>, and <span class="math inline">\(A \mathbin{\operatorname{\&amp;}}(B \mathbin{\operatorname{\&amp;}}C)\)</span> is the same type as <span class="math inline">\(A \mathbin{\operatorname{\&amp;}}B \mathbin{\operatorname{\&amp;}}C\)</span>.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for presentation purposes, we will henceforth order intersection type operands lexicographically based on their notation.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">When needed, the compiler may <em>approximate</em> an intersection type to a <em>denotable concrete</em> type using <a href="type-system.html#type-approximation">type approximation</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">One of the main uses of intersection types are <a href="type-inference.html#smart-casts">smart casts</a>.</span></p>
</div>
<h4 id="integer-literal-types">Integer literal types</h4>
<div class="paragraph">
<p><span class="sentence">An integer literal type containing types <span class="math inline">\(T_1, \ldots, T_N\)</span>, denoted <span class="math inline">\(\operatorname{\text{LTS}}(T_1, \ldots, T_N)\)</span> is a special <em>non-denotable</em> type designed for integer literals. </span><span class="sentence">Each type <span class="math inline">\(T_1, \ldots, T_N\)</span> must be one of the <a href="built-in-types-and-their-semantics.html#built-in-integer-types-1">built-in integer types</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Integer literal types are the types of <a href="expressions.html#integer-literals">integer literals</a> and have special handling w.r.t. <a href="type-system.html#subtyping-for-integer-literal-types">subtyping</a>.</span></p>
</div>
<h4 id="union-types">Union types</h4>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: Kotlin does <strong>not</strong> have union types in its type system. </span><span class="sentence">However, they make reasoning about several type system features easier. </span><span class="sentence">Therefore, we decided to include a brief intro to the union types here.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Union types are special <em>non-denotable</em> types used to express the fact that a value belongs to <em>one</em> of <em>several</em> possible types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Union type of two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is denoted <span class="math inline">\(A \mathbin{\operatorname{|}}B\)</span> and is equivalent to the <a href="type-system.html#least-upper-bound">least upper bound</a> of its components <span class="math inline">\(\operatorname{\text{LUB}}(A, B)\)</span>. </span><span class="sentence">Thus, the normalization procedure for <span class="math inline">\(\operatorname{\text{LUB}}\)</span> may be used to <em>normalize</em> a union type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Moreover, as union types are <em>not</em> used in Kotlin, the compiler always <em>decays</em> a union type to a <em>non-union</em> type using <a href="type-system.html#type-decaying">type decaying</a>.</span></p>
</div>
<h3 id="type-contexts-and-scopes">Type contexts and scopes</h3>
<div class="paragraph">
<p><span class="sentence">The way types and <a href="scopes-and-identifiers.html#scopes-and-identifiers">scopes</a> interoperate is very similar to how values and scopes work; this includes <a href="declarations.html#declaration-visibility">visibility</a>, accessing types via qualified names or <a href="packages-and-imports.html#importing">imports</a>. </span><span class="sentence">This means, in many cases, type contexts are equivalent to the corresponding scopes. </span><span class="sentence">However, there are several important differences, which we outline below.</span></p>
</div>
<h4 id="inner-and-nested-type-contexts">Inner and nested type contexts</h4>
<div class="paragraph">
<p><span class="sentence"><a href="type-system.html#type-parameters">Type parameters</a> are well-formed types in the type context (scope) of their declaring type constructor, including inner type declarations. </span><span class="sentence">However, type context for a <a href="declarations.html#nested-and-inner-classifiers"><em>nested</em> type declaration</a> <span class="math inline">\(\operatorname{\text{ND}}\)</span> of a parent type declaration <span class="math inline">\(\operatorname{\text{PD}}\)</span> does <strong>not</strong> include the type parameters of <span class="math inline">\(\operatorname{\text{PD}}\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: nested type declarations cannot capture parent type parameters, as they simply create a regular type available under a nested path.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">class</span> <span class="dt">Parent</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="kw">class</span> <span class="dt">Nested</span><span class="op">(</span><span class="kw">val</span> <span class="va">i</span><span class="op">:</span> <span class="dt">Int</span><span class="op">)</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="co">// Can use type parameter T as a type</span></a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="co">// in an inner class</span></a>
<a class="sourceLine" id="cb8-6" title="6">    <span class="kw">inner</span> <span class="kw">class</span> <span class="dt">Inner</span><span class="op">(</span><span class="kw">val</span> <span class="va">t</span><span class="op">:</span> <span class="dt">T</span><span class="op">)</span></a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8">    <span class="co">// Cannot use type parameter T as a type</span></a>
<a class="sourceLine" id="cb8-9" title="9">    <span class="co">// in a nested class</span></a>
<a class="sourceLine" id="cb8-10" title="10">    <span class="kw">class</span> <span class="dt">Error</span><span class="op">(</span><span class="kw">val</span> <span class="va">t</span><span class="op">:</span> <span class="dt">T</span><span class="op">)</span></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="op">}</span></a>
<a class="sourceLine" id="cb8-12" title="12"></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="kw">fun</span> <span class="fu">main</span><span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-14" title="14">    <span class="kw">val</span> <span class="va">nested</span> <span class="op">=</span> Parent.Nested(<span class="dv">42</span>)</a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16">    <span class="kw">val</span> <span class="va">inner</span> <span class="op">=</span> Parent&lt;<span class="kw">String</span>&gt;().Inner(<span class="st">&quot;42&quot;</span>)</a>
<a class="sourceLine" id="cb8-17" title="17"><span class="op">}</span></a></code></pre></div>
</blockquote>
<h3 id="subtyping">Subtyping</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin uses the classic notion of <em>subtyping</em> as <em>substitutability</em>  if <span class="math inline">\(S\)</span> is a subtype of <span class="math inline">\(T\)</span> (denoted as <span class="math inline">\(S &lt;: T\)</span>), values of type <span class="math inline">\(S\)</span> can be safely used where values of type <span class="math inline">\(T\)</span> are expected. </span><span class="sentence">The subtyping relation <span class="math inline">\(&lt;:\)</span> is:</span></p>
</div>
<ul>
<li><span class="sentence">reflexive (<span class="math inline">\(A &lt;: A\)</span>)</span></li>
<li><span class="sentence"><em>rigidly</em> transitive (<span class="math inline">\(A &lt;: B \land B &lt;: C \Rightarrow A &lt;: C\)</span> for non-flexible types <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <em>equivalent</em> (<span class="math inline">\(A \equiv B\)</span>), iff <span class="math inline">\(A &lt;: B \land B &lt;: A\)</span>. </span><span class="sentence">Due to the presence of flexible types, this relation is also only <em>rigidly</em> transitive, e.g., holds only for non-flexible types (see <a href="type-system.html#subtyping-for-flexible-types">here</a> for more details).</span></p>
</div>
<h4 id="subtyping-rules">Subtyping rules</h4>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, concrete types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \operatorname{\texttt{kotlin.Nothing}}&lt;: T &lt;: \operatorname{\texttt{kotlin.Any}}\)</span></span></li>
<li><span class="sentence">For any simple classifier type <span class="math inline">\(T : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: T &lt;: S_i\)</span></span></li>
<li><span class="sentence">For any parameterized type <span class="math inline">\(\widehat{T} = T\langle \tau \rangle: S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: \tau S_i\)</span></span></li>
<li><span class="sentence">For any two parameterized types <span class="math inline">\(\widehat{T} = T\langle \tau \rangle\)</span> and <span class="math inline">\(\widehat{T^\prime} = T\langle \tau^\prime \rangle\)</span> with captured type arguments <span class="math inline">\(K_i\)</span> and <span class="math inline">\(K_i^\prime\)</span> it is true that <span class="math inline">\(\widehat{T} &lt;: \widehat{T^\prime}\)</span> if <span class="math inline">\(\forall i \in [1,n]: K_i \preceq K_i^\prime\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for captured types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall K : \operatorname{\texttt{kotlin.Nothing}}&lt;: K &lt;: \operatorname{\texttt{kotlin.Any?}}\)</span></span></li>
<li><span class="sentence">For any two captured types <span class="math inline">\(L &lt;: K &lt;: U\)</span> and <span class="math inline">\(L^\prime &lt;: K^\prime &lt;: U^\prime\)</span>, it is true that <span class="math inline">\(K &lt;: K^\prime\)</span> if <span class="math inline">\(U &lt;: L^\prime\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for nullable types is checked separately and uses a special set of rules which are described <a href="type-system.html#subtyping-for-nullable-types">here</a>.</span></p>
</div>
<h4 id="subtyping-for-flexible-types">Subtyping for flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Flexible types (being flexible) follow a simple subtyping relation with other rigid (i.e., non-flexible) types. </span><span class="sentence">Let <span class="math inline">\(T, A, B, L, U\)</span> be rigid types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: T \Rightarrow (L..U) &lt;: T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(T &lt;: U \Rightarrow T &lt;: (L..U)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This captures the notion of flexible type <span class="math inline">\((L..U)\)</span> as something which may be used in place of any type in between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>. </span><span class="sentence">If we are to extend this idea to subtyping between <em>two</em> flexible types, we get the following definition.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: B \Rightarrow (L..U) &lt;: (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This is the most extensive definition possible, which, unfortunately, makes the type equivalence relation non-transitive. </span><span class="sentence">Let <span class="math inline">\(A, B\)</span> be two <em>different</em> types, for which <span class="math inline">\(A &lt;: B\)</span>. </span><span class="sentence">The following relations hold:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A &lt;: (A..B) \land (A..B) &lt;: A \Rightarrow A \equiv (A..B)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(B &lt;: (A..B) \land (A..B) &lt;: B \Rightarrow B \equiv (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, <span class="math inline">\(A \not \equiv B\)</span>.</span></p>
</div>
<h4 id="subtyping-for-intersection-types">Subtyping for intersection types</h4>
<div class="paragraph">
<p><span class="sentence">Intersection types introduce several new rules for subtyping. </span><span class="sentence">Let <span class="math inline">\(A, B, C, D\)</span> be non-nullable types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A \mathbin{\operatorname{\&amp;}}B &lt;: A\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \mathbin{\operatorname{\&amp;}}B &lt;: B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A &lt;: C \land B &lt;: D \Rightarrow A \mathbin{\operatorname{\&amp;}}B &lt;: C \mathbin{\operatorname{\&amp;}}D\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Moreover, any type <span class="math inline">\(T\)</span> with supertypes <span class="math inline">\(S_1, \ldots, S_N\)</span> is also a subtype of <span class="math inline">\(S_1 \mathbin{\operatorname{\&amp;}}\ldots \mathbin{\operatorname{\&amp;}}S_N\)</span>.</span></p>
</div>
<h4 id="subtyping-for-integer-literal-types">Subtyping for integer literal types</h4>
<div class="paragraph">
<p><span class="sentence">All integer literal type are equivalent w.r.t. subtyping, meaning that for any sets <span class="math inline">\(T_1, \ldots, T_K\)</span> and <span class="math inline">\(U_1, \ldots, U_N\)</span> of built-in integer types:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\operatorname{\text{LTS}}(T_1, \ldots, T_K) &lt;: \operatorname{\text{LTS}}(U_1, \ldots, U_N)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\operatorname{\text{LTS}}(U_1, \ldots, U_N) &lt;: \operatorname{\text{LTS}}(T_1, \ldots, T_K)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall T_i \in \{T_1, \ldots, T_K\} : \operatorname{\text{LTS}}(T_1, \ldots, T_K) &lt;: T_i\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall T_i \in \{T_1, \ldots, T_K\} : T_i &lt;: \operatorname{\text{LTS}}(T_1, \ldots, T_K)\)</span></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the last two rules mean <span class="math inline">\(\operatorname{\text{LTS}}(T_1, \ldots, T_K)\)</span> can be considered as an intersection type <span class="math inline">\(T_1 \mathbin{\operatorname{\&amp;}}\ldots \mathbin{\operatorname{\&amp;}}T_K\)</span> or as a union type <span class="math inline">\(T_1 \mathbin{\operatorname{|}}\ldots \mathbin{\operatorname{|}}T_K\)</span>, depending on the context. </span><span class="sentence">Viewing <span class="math inline">\(\operatorname{\text{LTS}}\)</span> as intersection type allows us to use integer literals where built-in integer types are expected. </span><span class="sentence">Making <span class="math inline">\(\operatorname{\text{LTS}}\)</span> behave as union type is needed to support cases when they appear in contravariant position.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">interface</span> <span class="dt">In</span><span class="op">&lt;</span><span class="kw">in</span> <span class="dt">T</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">fun</span> <span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> <span class="fu">T</span><span class="op">.</span><span class="fu">asIn</span><span class="op">():</span> <span class="dt">In</span><span class="op">&lt;</span><span class="dt">T</span><span class="op">&gt;</span> = ...</a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">fun</span> <span class="op">&lt;</span><span class="dt">S</span><span class="op">&gt;</span> <span class="fu">select</span><span class="op">(</span><span class="va">a</span><span class="op">:</span> <span class="dt">S</span>, <span class="va">b</span><span class="op">:</span> <span class="dt">In</span><span class="op">&lt;</span><span class="dt">S</span><span class="op">&gt;):</span> <span class="dt">S</span> = ...</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">fun</span> <span class="fu">ltsAsIntersection</span><span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="kw">val</span> <span class="va">a</span><span class="op">:</span> <span class="dt">Int</span> <span class="op">=</span> <span class="dv">42</span> <span class="co">// LTS(Byte, Short, Int, Long) &lt;: Int</span></a>
<a class="sourceLine" id="cb9-9" title="9">    </a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="kw">fun</span> <span class="fu">foo</span><span class="op">(</span><span class="va">a</span><span class="op">:</span> <span class="dt">Short</span><span class="op">)</span> <span class="op">{}</span></a>
<a class="sourceLine" id="cb9-11" title="11">    </a>
<a class="sourceLine" id="cb9-12" title="12">    foo(<span class="dv">1377</span>) <span class="co">// LTS(Short, Int, Long) &lt;: Short</span></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="op">}</span></a>
<a class="sourceLine" id="cb9-14" title="14"></a>
<a class="sourceLine" id="cb9-15" title="15"><span class="kw">fun</span> <span class="fu">ltsAsUnion</span><span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-16" title="16">    <span class="kw">val</span> <span class="va">a</span><span class="op">:</span> <span class="dt">Short</span> <span class="op">=</span> <span class="dv">42</span></a>
<a class="sourceLine" id="cb9-17" title="17">    </a>
<a class="sourceLine" id="cb9-18" title="18">    select(a, <span class="fl">1337.</span>asIn())</a>
<a class="sourceLine" id="cb9-19" title="19">        <span class="co">// For argument a:</span></a>
<a class="sourceLine" id="cb9-20" title="20">        <span class="co">//   Short &lt;: S</span></a>
<a class="sourceLine" id="cb9-21" title="21">        <span class="co">// For argument b:</span></a>
<a class="sourceLine" id="cb9-22" title="22">        <span class="co">//   In&lt;LTS(Short, Int, Long)&gt; &lt;: In&lt;S&gt; =&gt;</span></a>
<a class="sourceLine" id="cb9-23" title="23">        <span class="co">//     S &lt;: LTS(Short, Int, Long)</span></a>
<a class="sourceLine" id="cb9-24" title="24">        <span class="co">// Solution: S =:= Short</span></a>
<a class="sourceLine" id="cb9-25" title="25"><span class="op">}</span></a></code></pre></div>
</blockquote>
<h4 id="subtyping-for-nullable-types">Subtyping for nullable types</h4>
<div class="paragraph">
<p><span class="sentence">Subtyping for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is defined via <em>two</em> relations, both of which must hold.</span></p>
</div>
<ol type="1">
<li><span class="sentence">Regular subtyping <span class="math inline">\(&lt;:\)</span> for types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> using the <a href="type-system.html#nullability-lozenge">nullability lozenge</a></span></li>
<li><span class="sentence">Subtyping by nullability <span class="math inline">\(\mathrel{\operatorname{\stackrel{null}{&lt;:}}}\)</span></span></li>
</ol>
<div class="paragraph">
<p><span class="sentence">Subtyping by nullability <span class="math inline">\(\mathrel{\operatorname{\stackrel{null}{&lt;:}}}\)</span> for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> uses the following rules.</span></p>
</div>
<ol type="1">
<li><span class="sentence"><span class="math inline">\(A!! \mathrel{\operatorname{\stackrel{null}{&lt;:}}}B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \mathrel{\operatorname{\stackrel{null}{&lt;:}}}B\)</span> if <span class="math inline">\(\exists T!! : A &lt;: T!!\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \mathrel{\operatorname{\stackrel{null}{&lt;:}}}B?\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \mathrel{\operatorname{\stackrel{null}{&lt;:}}}B\)</span> if <span class="math inline">\(\nexists T!! : B &lt;: T!!\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A? \not \mathrel{\operatorname{\stackrel{null}{&lt;:}}}B\)</span></span></li>
</ol>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally: these rules represent the following idea derived from the nullability lozenge.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A \not \mathrel{\operatorname{\stackrel{null}{&lt;:}}}B\)</span> if <span class="math inline">\(B\)</span> is definitely non-nullable and <span class="math inline">\(A\)</span> may be nullable or <span class="math inline">\(B\)</span> may be non-nullable and <span class="math inline">\(A\)</span> is definitely nullable.</span></p>
</div>
</blockquote>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: these rules follow the structure of the nullability lozenge and check the absence of nullability violation <span class="math inline">\(A? \mathrel{\operatorname{\stackrel{null}{&lt;:}}}B!!\)</span> via underapproximating it using the <em>supertype</em> relation (as we cannot enumerate the <em>subtype</em> relation for <span class="math inline">\(B\)</span>).</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">class</span> <span class="dt">Foo</span><span class="op">&lt;</span><span class="dt">A</span>, <span class="dt">B</span> <span class="op">:</span> <span class="dt">A?</span><span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb10-2" title="2">    <span class="kw">val</span> <span class="va">b</span><span class="op">:</span> <span class="dt">B</span> <span class="op">=</span> mk()</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="kw">val</span> <span class="va">bQ</span><span class="op">:</span> <span class="dt">B?</span> <span class="op">=</span> mk()</a>
<a class="sourceLine" id="cb10-4" title="4">    </a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="co">// For this assignment to be well-formed,</span></a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="co">//   B must be a subtype of A</span></a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="co">// Subtyping by nullability holds per rule 4</span></a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="co">// Regular subtyping does not hold,</span></a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="co">//   as B &lt;: A? is not enough to show B &lt;: A</span></a>
<a class="sourceLine" id="cb10-10" title="10">    <span class="co">//   (we are missing B!! &lt;: A!!)</span></a>
<a class="sourceLine" id="cb10-11" title="11">    <span class="kw">val</span> <span class="va">ab</span><span class="op">:</span> <span class="dt">A</span> <span class="op">=</span> b <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb10-12" title="12"></a>
<a class="sourceLine" id="cb10-13" title="13">    <span class="co">// For this assignment to be well-formed,</span></a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="co">//   B? must be a subtype of A</span></a>
<a class="sourceLine" id="cb10-15" title="15">    <span class="co">// Subtyping by nullability does not hold per rule 5</span></a>
<a class="sourceLine" id="cb10-16" title="16">    <span class="kw">val</span> <span class="va">abQ</span><span class="op">:</span> <span class="dt">A</span> <span class="op">=</span> bQ <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb10-17" title="17">    </a>
<a class="sourceLine" id="cb10-18" title="18">    <span class="co">// For this assignment to be well-formed,</span></a>
<a class="sourceLine" id="cb10-19" title="19">    <span class="co">//   B must be a subtype of A?</span></a>
<a class="sourceLine" id="cb10-20" title="20">    <span class="co">// Subtyping by nullability holds per rule 3</span></a>
<a class="sourceLine" id="cb10-21" title="21">    <span class="co">// Regular subtyping does hold,</span></a>
<a class="sourceLine" id="cb10-22" title="22">    <span class="co">//   as B &lt;: A? is enough to show B &lt;: A?</span></a>
<a class="sourceLine" id="cb10-23" title="23">    <span class="kw">val</span> <span class="va">aQb</span><span class="op">:</span> <span class="dt">A?</span> <span class="op">=</span> b <span class="co">// OK</span></a>
<a class="sourceLine" id="cb10-24" title="24">    </a>
<a class="sourceLine" id="cb10-25" title="25">    <span class="co">// For this assignment to be well-formed,</span></a>
<a class="sourceLine" id="cb10-26" title="26">    <span class="co">//   B? must be a subtype of A?</span></a>
<a class="sourceLine" id="cb10-27" title="27">    <span class="co">// Subtyping by nullability holds per rule 3</span></a>
<a class="sourceLine" id="cb10-28" title="28">    <span class="co">// Regular subtyping does hold,</span></a>
<a class="sourceLine" id="cb10-29" title="29">    <span class="co">//   as B &lt;: A? is enough to show B? &lt;: A?</span></a>
<a class="sourceLine" id="cb10-30" title="30">    <span class="co">//   (taking the upper edge of the nullability lozenge)</span></a>
<a class="sourceLine" id="cb10-31" title="31">    <span class="kw">val</span> <span class="va">aQbQ</span><span class="op">:</span> <span class="dt">A?</span> <span class="op">=</span> bQ <span class="co">// OK</span></a>
<a class="sourceLine" id="cb10-32" title="32"><span class="op">}</span></a>
<a class="sourceLine" id="cb10-33" title="33"></a>
<a class="sourceLine" id="cb10-34" title="34"><span class="kw">class</span> <span class="dt">Bar</span><span class="op">&lt;</span><span class="dt">A</span>, <span class="dt">B</span> <span class="op">:</span> <span class="dt">A</span><span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb10-35" title="35">    <span class="kw">val</span> <span class="va">b</span><span class="op">:</span> <span class="dt">B</span> <span class="op">=</span> mk()</a>
<a class="sourceLine" id="cb10-36" title="36">    <span class="kw">val</span> <span class="va">bQ</span><span class="op">:</span> <span class="dt">B?</span> <span class="op">=</span> mk()</a>
<a class="sourceLine" id="cb10-37" title="37">    </a>
<a class="sourceLine" id="cb10-38" title="38">    <span class="co">// For this assignment to be well-formed,</span></a>
<a class="sourceLine" id="cb10-39" title="39">    <span class="co">//   B must be a subtype of A</span></a>
<a class="sourceLine" id="cb10-40" title="40">    <span class="co">// Subtyping by nullability holds per rule 4</span></a>
<a class="sourceLine" id="cb10-41" title="41">    <span class="co">// Regular subtyping does hold,</span></a>
<a class="sourceLine" id="cb10-42" title="42">    <span class="co">//   as B &lt;: A is enough to show B &lt;: A</span></a>
<a class="sourceLine" id="cb10-43" title="43">    <span class="kw">val</span> <span class="va">ab</span><span class="op">:</span> <span class="dt">A</span> <span class="op">=</span> b <span class="co">// OK</span></a>
<a class="sourceLine" id="cb10-44" title="44"></a>
<a class="sourceLine" id="cb10-45" title="45">    <span class="co">// For this assignment to be well-formed,</span></a>
<a class="sourceLine" id="cb10-46" title="46">    <span class="co">//   B? must be a subtype of A</span></a>
<a class="sourceLine" id="cb10-47" title="47">    <span class="co">// Subtyping by nullability does not hold per rule 5</span></a>
<a class="sourceLine" id="cb10-48" title="48">    <span class="kw">val</span> <span class="va">abQ</span><span class="op">:</span> <span class="dt">A</span> <span class="op">=</span> bQ <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb10-49" title="49">    </a>
<a class="sourceLine" id="cb10-50" title="50">    <span class="co">// For this assignment to be well-formed,</span></a>
<a class="sourceLine" id="cb10-51" title="51">    <span class="co">//   B must be a subtype of A?</span></a>
<a class="sourceLine" id="cb10-52" title="52">    <span class="co">// Subtyping by nullability holds per rule 3</span></a>
<a class="sourceLine" id="cb10-53" title="53">    <span class="co">// Regular subtyping does hold,</span></a>
<a class="sourceLine" id="cb10-54" title="54">    <span class="co">//   as B &lt;: A is enough to show B &lt;: A?</span></a>
<a class="sourceLine" id="cb10-55" title="55">    <span class="co">//   (taking the upper triangle of the nullability lozenge)</span></a>
<a class="sourceLine" id="cb10-56" title="56">    <span class="kw">val</span> <span class="va">aQb</span><span class="op">:</span> <span class="dt">A?</span> <span class="op">=</span> b <span class="co">// OK</span></a>
<a class="sourceLine" id="cb10-57" title="57">    </a>
<a class="sourceLine" id="cb10-58" title="58">    <span class="co">// For this assignment to be well-formed,</span></a>
<a class="sourceLine" id="cb10-59" title="59">    <span class="co">//   B? must be a subtype of A?</span></a>
<a class="sourceLine" id="cb10-60" title="60">    <span class="co">// Subtyping by nullability holds per rule 3</span></a>
<a class="sourceLine" id="cb10-61" title="61">    <span class="co">// Regular subtyping does hold,</span></a>
<a class="sourceLine" id="cb10-62" title="62">    <span class="co">//   as B &lt;: A is enough to show B? &lt;: A?</span></a>
<a class="sourceLine" id="cb10-63" title="63">    <span class="co">//   (taking the upper edge of the nullability lozenge)</span></a>
<a class="sourceLine" id="cb10-64" title="64">    <span class="kw">val</span> <span class="va">aQbQ</span><span class="op">:</span> <span class="dt">A?</span> <span class="op">=</span> bQ <span class="co">// OK</span></a>
<a class="sourceLine" id="cb10-65" title="65"><span class="op">}</span></a></code></pre></div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="diagram">
<img src='data:image/svg+xml;utf8,<?xml version="1.0"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:jfreesvg="http://www.jfree.org/jfreesvg/svg" width="299" height="79" text-rendering="auto" shape-rendering="auto">
<defs></defs>
<line x1="142.5" y1="52.5" x2="232.5" y2="52.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="307.5" y1="52.5" x2="330" y2="52.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><g style="fill: rgb(0,0,0); fill-opacity: 1.0; stroke: none" transform="matrix(0.7,0,0,0.7,0,0)" ><path d="M 337.5 52.5 L 322.5 57.5 L 322.5 47.5 Z "/></g><line x1="67.5" y1="37.5" x2="67.5" y2="75" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><g style="fill: rgb(0,0,0); fill-opacity: 1.0; stroke: none" transform="matrix(0.7,0,0,0.7,0,0)" ><path d="M 67.5 82.5 L 62.5 67.5 L 72.5 67.5 Z "/></g><line x1="142.5" y1="37.5" x2="142.5" y2="52.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="232.5" y1="37.5" x2="232.5" y2="52.5" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><line x1="412.5" y1="37.5" x2="412.5" y2="75" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><g style="fill: rgb(0,0,0); fill-opacity: 1.0; stroke: none" transform="matrix(0.7,0,0,0.7,0,0)" ><path d="M 412.5 82.5 L 407.5 67.5 L 417.5 67.5 Z "/></g><line x1="187.5" y1="52.5" x2="187.5" y2="75" style="stroke-width: 1.5;stroke: rgb(0,0,0);stroke-opacity: 1.0;stroke-linecap: square;" transform="matrix(0.7,0,0,0.7,0,0)" /><g style="fill: rgb(0,0,0); fill-opacity: 1.0; stroke: none" transform="matrix(0.7,0,0,0.7,0,0)" ><path d="M 187.5 82.5 L 182.5 67.5 L 192.5 67.5 Z "/></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="60.5" y="30.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >A</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="129.5" y="30.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >B?</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="212.5" y="30.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >C!!</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="405.5" y="30.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >A</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="60.5" y="105.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >B</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="180.5" y="105.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >T</text></g><g transform="matrix(0.7,0,0,0.7,0,0)"><text x="405.5" y="105.5" style="fill: rgb(0,0,0); fill-opacity: 1.0; font-family: monospace; font-size: 23px;" >T</text></g></svg>
' />
</div>
<div class="paragraph">
<p><span class="sentence">This example shows a situation, when the subtyping by nullability relation from <span class="math inline">\(T &lt;: C!!\)</span> is used to prove <span class="math inline">\(T &lt;: A\)</span>.</span></p>
</div>
</blockquote>
<h3 id="upper-and-lower-bounds">Upper and lower bounds</h3>
<div class="paragraph">
<p><span class="sentence">A type <span class="math inline">\(U\)</span> is an <em>upper bound</em> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> if <span class="math inline">\(A &lt;: U\)</span> and <span class="math inline">\(B &lt;: U\)</span>. </span><span class="sentence">A type <span class="math inline">\(L\)</span> is a <em>lower bound</em> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> if <span class="math inline">\(L &lt;: A\)</span> and <span class="math inline">\(L &lt;: B\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the type system of Kotlin is bounded by definition (the upper bound of all types is <span class="math inline">\(\operatorname{\texttt{kotlin.Any?}}\)</span>, and the lower bound of all types is <span class="math inline">\(\operatorname{\texttt{kotlin.Nothing}}\)</span>), any two types have at least one lower bound and at least one upper bound.</span></p>
</div>
</blockquote>
<h4 id="least-upper-bound">Least upper bound</h4>
<div class="paragraph">
<p><span class="sentence">The <em>least upper bound</em> <span class="math inline">\(\operatorname{\text{LUB}}(A, B)\)</span> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is an upper bound <span class="math inline">\(U\)</span> of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> such that there is no other upper bound of these types which is less by subtyping relation than <span class="math inline">\(U\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <span class="math inline">\(\operatorname{\text{LUB}}\)</span> is commutative, i.e., <span class="math inline">\(\operatorname{\text{LUB}}(A, B) = \operatorname{\text{LUB}}(B, A)\)</span>. </span><span class="sentence">This property is used in the subsequent description, e.g., other properties of <span class="math inline">\(\operatorname{\text{LUB}}\)</span> are defined only for a specific order of the arguments. </span><span class="sentence">Definitions following from commutativity of <span class="math inline">\(\operatorname{\text{LUB}}\)</span> are implied.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\text{LUB}}(A, B)\)</span> has the following properties, which may be used to <em>normalize</em> it. </span><span class="sentence">This normalization procedure, if finite, creates a <em>canonical</em> representation of LUB.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are considered to be non-flexible, unless specified otherwise.</span></p>
</div>
</blockquote>
<ul>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\text{LUB}}(A, A) = A\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A &lt;: B\)</span>, <span class="math inline">\(\operatorname{\text{LUB}}(A, B) = B\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A\)</span> is nullable, <span class="math inline">\(\operatorname{\text{LUB}}(A, B) = \operatorname{\text{LUB}}(A!!, B!!)?\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A = T\langle K_{A,1}, \ldots, K_{A,n}\rangle\)</span> and <span class="math inline">\(B = T\langle K_{B,1}, \ldots, K_{B,n}\rangle\)</span>, <span class="math inline">\(\operatorname{\text{LUB}}(A, B) = T\langle \phi(\eta(K_{A,1}), \eta(K_{B,1})), \ldots, \phi(\eta(K_{A,n}), \eta(K_{B,n}))\rangle\)</span>, where <span class="math inline">\(\eta(T)\)</span> and <span class="math inline">\(\phi(X, Y)\)</span> are defined as follows:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[
  \eta(K : L &lt;: K &lt;: U) = \{\operatorname{\texttt{out\,}}U, \operatorname{\texttt{in\,}}L\}
  \]</span></span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally: in many cases, one may view <span class="math inline">\(\eta(T)\)</span> as follows. </span><span class="sentence"><span class="math display">\[
\begin{aligned}
    \eta(\operatorname{\texttt{inv\,}}X) &amp;= \{\operatorname{\texttt{out\,}}X, \operatorname{\texttt{in\,}}X\} \\
    \eta(\operatorname{\texttt{out\,}}X) &amp;= \{\operatorname{\texttt{out\,}}X, \operatorname{\texttt{in\,}}\operatorname{\texttt{kotlin.Nothing}}\} \\
    \eta(\operatorname{\texttt{in\,}}X)  &amp;= \{\operatorname{\texttt{out\,}}\operatorname{\texttt{kotlin.Any?}}, \operatorname{\texttt{in\,}}X\} \\
    \eta(\star)   &amp;= \{\operatorname{\texttt{out\,}}\operatorname{\texttt{kotlin.Any?}}, \operatorname{\texttt{in\,}}\operatorname{\texttt{kotlin.Nothing}}\} 
\end{aligned}
\]</span></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[
  \begin{aligned}
      &amp;\phi(\{\operatorname{\texttt{out\,}}X_{out}, \operatorname{\texttt{in\,}}X_{in}\}, \{\operatorname{\texttt{out\,}}Y_{out}, \operatorname{\texttt{in\,}}Y_{in}\}) = \\
      &amp; \qquad \eta^{-1} (\{\operatorname{\texttt{out\,}}\operatorname{\text{LUB}}(X_{out}, Y_{out}), \operatorname{\texttt{in\,}}\operatorname{\text{GLB}}(X_{in}, Y_{in})\})
  \end{aligned}
  \]</span></span></p>
</div></li>
<li><span class="sentence">if <span class="math inline">\(A = (L_A..U_A)\)</span> and <span class="math inline">\(B = (L_B..U_B)\)</span>, <span class="math inline">\(\operatorname{\text{LUB}}(A, B) = (\operatorname{\text{LUB}}(L_A, L_B)..\operatorname{\text{LUB}}(U_A, U_B))\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A = (L_A..U_A)\)</span> and <span class="math inline">\(B\)</span> is not flexible, <span class="math inline">\(\operatorname{\text{LUB}}(A, B) = (\operatorname{\text{LUB}}(L_A, B)..\operatorname{\text{LUB}}(U_A, B))\)</span></span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: in some cases, the least upper bound is handled as described <a href="kotlin-type-constraints.html#the-relations-on-types-as-constraints">here</a>, from the point of view of type constraint system.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In the presence of recursively defined parameterized types, the algorithm given above is not guaranteed to terminate as there may not exist a finite representation of <span class="math inline">\(\operatorname{\text{LUB}}\)</span> for particular two types. </span><span class="sentence">The detection and handling of such situations (compile-time error or leaving the type in some kind of denormalized state) is implementation-defined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In some situations, it is needed to construct the least upper bound for more than two types, in which case the least upper bound operator <span class="math inline">\(\operatorname{\text{LUB}}(T_1, T_2, \ldots, T_N)\)</span> is defined as <span class="math inline">\(\operatorname{\text{LUB}}(T_1, \operatorname{\text{LUB}}(T_2, \ldots, T_N))\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(It is probably order-dependent or needs to be proven otherwise)</span></p>
</div>
</div>
<h4 id="greatest-lower-bound">Greatest lower bound</h4>
<div class="paragraph">
<p><span class="sentence">The <em>greatest lower bound</em> <span class="math inline">\(\operatorname{\text{GLB}}(A, B)\)</span> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is a lower bound <span class="math inline">\(L\)</span> of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> such that there is no other lower bound of these types which is greater by subtyping relation than <span class="math inline">\(L\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <span class="math inline">\(\operatorname{\text{GLB}}\)</span> is commutative, i.e., <span class="math inline">\(\operatorname{\text{GLB}}(A, B) = \operatorname{\text{GLB}}(B, A)\)</span>. </span><span class="sentence">This property is used in the subsequent description, e.g., other properties of <span class="math inline">\(\operatorname{\text{GLB}}\)</span> are defined only for a specific order of the arguments. </span><span class="sentence">Definitions following from commutativity of <span class="math inline">\(\operatorname{\text{GLB}}\)</span> are implied.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\text{GLB}}(A, B)\)</span> has the following properties, which may be used to <em>normalize</em> it. </span><span class="sentence">This normalization procedure, if finite, creates a <em>canonical</em> representation of GLB.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are considered to be non-flexible, unless specified otherwise.</span></p>
</div>
</blockquote>
<ul>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\operatorname{\text{GLB}}(A, A) = A\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A &lt;: B\)</span>, <span class="math inline">\(\operatorname{\text{GLB}}(A, B) = A\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A\)</span> is non-nullable, <span class="math inline">\(\operatorname{\text{GLB}}(A, B) = \operatorname{\text{GLB}}(A!!, B!!)\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A = T\langle K_{A,1}, \ldots, K_{A,n}\rangle\)</span> and <span class="math inline">\(B = T\langle K_{B,1}, \ldots, K_{B,n}\rangle\)</span>, <span class="math inline">\(\operatorname{\text{GLB}}(A, B) = T\langle \phi(\eta(K_{A,1}), \eta(K_{B,1})), \ldots, \phi(\eta(K_{A,n}), \eta(K_{B,n}))\rangle\)</span>, where <span class="math inline">\(\eta(T)\)</span> and <span class="math inline">\(\phi(X, Y)\)</span> are defined as follows:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[
  \eta(K : L &lt;: K &lt;: U) = \{\operatorname{\texttt{out\,}}U, \operatorname{\texttt{in\,}}L\}
  \]</span></span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally: in many cases, one may view <span class="math inline">\(\eta(T)\)</span> as follows. </span><span class="sentence"><span class="math display">\[
\begin{aligned}
    \eta(\operatorname{\texttt{inv\,}}X) &amp;= \{\operatorname{\texttt{out\,}}X, \operatorname{\texttt{in\,}}X\} \\
    \eta(\operatorname{\texttt{out\,}}X) &amp;= \{\operatorname{\texttt{out\,}}X, \operatorname{\texttt{in\,}}\operatorname{\texttt{kotlin.Nothing}}\} \\
    \eta(\operatorname{\texttt{in\,}}X)  &amp;= \{\operatorname{\texttt{out\,}}\operatorname{\texttt{kotlin.Any?}}, \operatorname{\texttt{in\,}}X\} \\
    \eta(\star)   &amp;= \{\operatorname{\texttt{out\,}}\operatorname{\texttt{kotlin.Any?}}, \operatorname{\texttt{in\,}}\operatorname{\texttt{kotlin.Nothing}}\} 
\end{aligned}
\]</span></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[
  \begin{aligned}
     &amp; {\phi(\{\operatorname{\texttt{out\,}}X_{out}, \operatorname{\texttt{in\,}}X_{in}\}, \{\operatorname{\texttt{out\,}}Y_{out}, \operatorname{\texttt{in\,}}Y_{in}\}) = } \\
     &amp; \qquad {(\eta^{-1} \circ \Omega)} (\{\operatorname{\texttt{out\,}}\operatorname{\text{GLB}}(X_{out}, Y_{out}), \operatorname{\texttt{in\,}}\operatorname{\text{LUB}}(X_{in}, Y_{in})\}) \\
     &amp; {\Omega(\{\operatorname{\texttt{out\,}}A, \operatorname{\texttt{in\,}}B\}) = } \\
     &amp; \qquad
       \begin{cases}
          \{\operatorname{\texttt{out\,}}A, \operatorname{\texttt{in\,}}B\}        &amp; \text{if } A :&gt; B \\
          \{\operatorname{\texttt{out\,}}A, \operatorname{\texttt{in\,}}\operatorname{\texttt{kotlin.Nothing}}\} &amp; \text{if } A &lt;: B \land A \not \equiv B
       \end{cases}
  \end{aligned}
  \]</span></span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the <span class="math inline">\(\Omega\)</span> function preserves type system consistency; <span class="math inline">\(\forall A, B : A &lt;: B \land A \not\equiv B\)</span>, type <span class="math inline">\(T\langle \{\operatorname{\texttt{out\,}}A, \operatorname{\texttt{in\,}}B\}\rangle\)</span> is the evidence of type <span class="math inline">\(T\langle X\rangle : X &lt;: A &lt;: B &lt;: X\)</span>, which makes the type system inconsistent. </span><span class="sentence">To avoid this situation, we overapproximate <span class="math inline">\(\operatorname{\texttt{in\,}}B\)</span> with <span class="math inline">\(\operatorname{\texttt{in\,}}\operatorname{\texttt{kotlin.Nothing}}\)</span> when needed. </span><span class="sentence">Further details are available in the <a href="control--and-data-flow-analysis.html#references-1">Mixed-site variance paper</a>.</span></p>
</div>
</blockquote>
<ul>
<li><span class="sentence">if <span class="math inline">\(A = (L_A..U_A)\)</span> and <span class="math inline">\(B = (L_B..U_B)\)</span>, <span class="math inline">\(\operatorname{\text{GLB}}(A, B) = (\operatorname{\text{GLB}}(L_A, L_B)..\operatorname{\text{GLB}}(U_A, U_B))\)</span></span></li>
<li><span class="sentence">if <span class="math inline">\(A = (L_A..U_A)\)</span> and <span class="math inline">\(B\)</span> is not flexible, <span class="math inline">\(\operatorname{\text{GLB}}(A, B) = (\operatorname{\text{GLB}}(L_A, B)..\operatorname{\text{GLB}}(U_A, B))\)</span></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: in some cases, the greatest lower bound is handled as described <a href="kotlin-type-constraints.html#the-relations-on-types-as-constraints">here</a>, from the point of view of type constraint system.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In the presence of recursively defined parameterized types, the algorithm given above is not guaranteed to terminate as there may not exist a finite representation of <span class="math inline">\(\operatorname{\text{GLB}}\)</span> for particular two types. </span><span class="sentence">The detection and handling of such situations (compile-time error or leaving the type in some kind of denormalized state) is implementation-defined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In some situations, it is needed to construct the least upper bound for more than two types, in which case the least upper bound operator <span class="math inline">\(\operatorname{\text{GLB}}(T_1, T_2, \ldots, T_N)\)</span> is defined as <span class="math inline">\(\operatorname{\text{GLB}}(T_1, \operatorname{\text{GLB}}(T_2, \ldots, T_N))\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(It is probably order-dependent or needs to be proven otherwise)</span></p>
</div>
</div>
<h3 id="type-approximation">Type approximation</h3>
<div class="paragraph">
<p><span class="sentence">As we mentioned <a href="type-system.html#type-kinds">before</a>, Kotlin type system has denotable and non-denotable types. </span><span class="sentence">In many cases, we need to <em>approximate</em> a non-denotable type, which appeared, for example, during type inference, into a denotable type, so that it can be used in the program. </span><span class="sentence">This is achieved via <em>type approximation</em>, which we describe below.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: at the moment, type approximation is applied only to <a href="type-system.html#intersection-types">intersection</a> and <a href="type-system.html#union-types">union</a> types.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Type approximation function <span class="math inline">\(\alpha\)</span> is defined as follows.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\alpha(A\langle \tau_A \rangle \mathbin{\operatorname{\&amp;}}B\langle \tau_B \rangle) = (\alpha {\downarrow} \circ \operatorname{\text{GLB}})(S\langle \tau_{A \rightarrow S} \rangle, S\langle \tau_{B \rightarrow S} \rangle)\)</span>, where type <span class="math inline">\(S\)</span> is the least common supertype of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, substitution <span class="math inline">\(\tau_{P \rightarrow Q}\)</span> is the result of chain applying substitutions from type <span class="math inline">\(P\)</span> to type <span class="math inline">\(Q :&gt; P\)</span>, <span class="math inline">\(\alpha {\downarrow}\)</span> is a function which applies type approximation function to the type arguments if needed;</span></li>
<li><span class="sentence"><span class="math inline">\(\alpha(A\langle \tau_A \rangle \mathbin{\operatorname{|}}B\langle \tau_B \rangle) = \alpha(\delta(A\langle \tau_A \rangle \mathbin{\operatorname{|}}B\langle \tau_B \rangle))\)</span>, where <span class="math inline">\(\delta\)</span> is the <a href="type-system.html#type-decaying">type decaying</a> function.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Type approximation for captured types)</span></p>
</div>
</div>
<h3 id="type-decaying">Type decaying</h3>
<div class="paragraph">
<p><span class="sentence">All <a href="type-system.html#union-types">union types</a> are subject to <em>type decaying</em>, when they are converted to a specific <a href="type-system.html#intersection-types">intersection type</a>, representable within Kotlin type system.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: at the moment, type decaying is applied only to <a href="type-system.html#union-types">union</a> types. </span><span class="sentence">Note: type decaying is comparable to how <em>least upper bound</em> computation works in Java.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Type decaying function <span class="math inline">\(\delta\)</span> is defined as follows.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\delta(A\langle \tau_A \rangle \mathbin{\operatorname{|}}B\langle \tau_B \rangle) = \mathbin{\operatorname{\&amp;}}_{S \in \mathbb{S}(A, B)} (\delta {\downarrow} \circ \operatorname{\text{GLB}})(S\langle \tau_{A \rightarrow S} \rangle, S\langle \tau_{B \rightarrow S} \rangle)\)</span>, where substitution <span class="math inline">\(\tau_{P \rightarrow Q}\)</span> is the result of chain applying substitutions from type <span class="math inline">\(P\)</span> to type <span class="math inline">\(Q :&gt; P\)</span>, <span class="math inline">\(\delta {\downarrow}\)</span> is a function which applies type decaying function to the type arguments if needed, <span class="math inline">\(\mathbb{S}(A, B)\)</span> is a set of most specific common supertypes of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: a set of most specific common supertypes <span class="math inline">\(\mathbb{S}(A, B)\)</span> is a reduction of a set of all common supertypes <span class="math inline">\(\mathbb{U}(A, B)\)</span>, which excludes all types <span class="math inline">\(T \in \mathbb{U}\)</span> such that <span class="math inline">\(\exists V \in \mathbb{U} : V \neq T \land V &lt;: T\)</span>.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Specify when we drop type arguments when doing type approximation / decaying business)</span></p>
</div>
</div>
<h3 id="references" class="unnumbered">References</h3>
<ol type="1">
<li><span class="sentence">Ross Tate. </span><span class="sentence">Mixed-site variance. FOOL, 2013.</span></li>
<li><span class="sentence">Ross Tate, Alan Leung, and Sorin Lerner. </span><span class="sentence">Taming wildcards in Javas type system. PLDI, 2011.</span></li>
</ol>
</body>
</html>
