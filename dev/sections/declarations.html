<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../resources/css/main.css">
  <script src="../resources/js/katex/katex.min.js"></script><script src="../resources/js/katex/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="../resources/js/katex/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script data-main="resources/js/main" src="https://requirejs.org/docs/release/2.3.6/minified/require.js"></script>
  <script>
      requirejs.config({
          waitSeconds: 10000
      });
  </script>
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
</header>



























<h2 id="declarations">Declarations</h2>
<h3 id="glossary-2">Glossary</h3>
<dl>
<dt>Entity</dt>
<dd><span class="sentence">Distinguishable part of a program</span>
</dd>
<dt>Identifier</dt>
<dd><span class="sentence">Name of a program entity</span>
</dd>
<dt>Path</dt>
<dd><span class="sentence">Sequence of identifiers which references a program entity in a given <a href="scopes-and-identifiers.html#scopes-and-identifiers">scope</a></span>
</dd>
</dl>
<h3 id="introduction-2">Introduction</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations in Kotlin are used to introduce entities (values, types, etc.); most declarations are <em>named</em>, i.e. they also assign an identifier to their own entity, however, some declarations may be <em>anonymous</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Every declaration is accessible in a particular <em>scope</em>, which is dependent both on where the declaration is located and on the declaration itself.</span></p>
</div>
<h3 id="classifier-declaration">Classifier declaration</h3>
<div id="grammar-rule-classDeclaration-pasted-0" class="grammar-rule">
<dl>
<dt><strong><em>classDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="syntax.html#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'class'</code> | <code>'interface'</code>)<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-primaryConstructor">primaryConstructor</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[({<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-classBody">classBody</a></em>) | ({<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-enumClassBody">enumClassBody</a></em>)]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectDeclaration-pasted-1" class="grammar-rule">
<dl>
<dt><strong><em>objectDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="syntax.html#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'object'</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Classifier declarations introduce new types to the program, of the forms described <a href="type-system.html#classifier-types">here</a>. </span><span class="sentence">There are three kinds of classifier declarations:</span></p>
</div>
<ul>
<li><span class="sentence">class declarations;</span></li>
<li><span class="sentence">interface declarations;</span></li>
<li><span class="sentence">object declarations.</span></li>
</ul>
<h4 id="class-declaration">Class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A simple class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">Name <span class="math inline">\(c\)</span>;</span></li>
<li><span class="sentence">Optional primary <a href="declarations.html#constructor-declaration">constructor declaration</a> <span class="math inline">\(\operatorname{\mathit{ptor}}\)</span>;</span></li>
<li><span class="sentence">Optional supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span>;</span></li>
<li><span class="sentence">Optional body <span class="math inline">\(b\)</span>, which may include the following:</span>
<ul>
<li><span class="sentence">secondary <a href="declarations.html#constructor-declaration">constructor declarations</a> <span class="math inline">\(\operatorname{\mathit{stor}}_1, \ldots, \operatorname{\mathit{stor}}_c\)</span>;</span></li>
<li><span class="sentence">instance initialization blocks <span class="math inline">\(\operatorname{\mathit{init}}_1, \ldots, \operatorname{\mathit{init}}_i\)</span>;</span></li>
<li><span class="sentence">property declarations <span class="math inline">\(\operatorname{\mathit{prop}}_1, \ldots, \operatorname{\mathit{prop}}_p\)</span>;</span></li>
<li><span class="sentence">function declarations <span class="math inline">\(\operatorname{\mathit{md}}_1, \ldots, \operatorname{\mathit{md}}_m\)</span>;</span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(\operatorname{\mathit{companionObj}}\)</span>;</span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(\operatorname{\mathit{nested}}\)</span>.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a simple classifier type <span class="math inline">\(c : S_1, \ldots, S_s\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Supertype specifiers are used to create inheritance relation between the declared type and the specified supertype. </span><span class="sentence">You can use classes and interfaces as supertypes, but not objects.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: if supertype specifiers are absent, the declared type is considered to be implicitly derived from <code>kotlin.Any</code>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">It is allowed to inherit from a single class only, i.e., multiple class inheritance is not supported. </span><span class="sentence">Multiple interface inheritance is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Instance initialization block describes a block of code which should be executed during <a href="declarations.html#classifier-initialization">object creation</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Property and function declarations in the class body introduce their respective entities in this class’ scope, meaning they are available only on an entity of the corresponding class.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Companion object declaration <code>companion object CO { ... }</code> for class <code>C</code> introduces an object, which is available under this class’ name or under the path <code>C.CO</code>. </span><span class="sentence">Companion object name may be omitted, in which case it is considered to be equal to <code>Companion</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Nested classifier declarations introduce new classifiers, available under this class’ name. </span><span class="sentence">Further details are available <a href="declarations.html#nested-and-inner-classifiers">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized class declaration, in addition to what constitutes a simple class declaration, also has a type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span> and extends the rules for a simple class declaration w.r.t. this type parameter list. </span><span class="sentence">Further details are described <a href="declarations.html#declarations-with-type-parameters">here</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// An open class with no supertypes</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">//</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">open</span> <span class="kw">class</span> Base</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">// A <span class="kw">class</span> inherited from `Base`</a>
<a class="sourceLine" id="cb1-6" title="6">//</a>
<a class="sourceLine" id="cb1-7" title="7">// Has a single read-only property `i`</a>
<a class="sourceLine" id="cb1-8" title="8">//   declared <span class="kw">in</span> its primary <span class="kw">constructor</span></a>
<a class="sourceLine" id="cb1-9" title="9">//</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">class</span> B(<span class="kw">val</span> <span class="va">i</span>: <span class="dt">Int</span>) : <span class="dt">Base</span>()</a>
<a class="sourceLine" id="cb1-11" title="11"></a>
<a class="sourceLine" id="cb1-12" title="12">// <span class="dt">An</span> <span class="kw">open</span> <span class="kw">class</span> with no superclasses</a>
<a class="sourceLine" id="cb1-13" title="13">//</a>
<a class="sourceLine" id="cb1-14" title="14">// Has a single read-only property `i`</a>
<a class="sourceLine" id="cb1-15" title="15">//   declared <span class="kw">in</span> its body</a>
<a class="sourceLine" id="cb1-16" title="16">//</a>
<a class="sourceLine" id="cb1-17" title="17">// Initial value for the property <span class="kw">is</span> calculated</a>
<a class="sourceLine" id="cb1-18" title="18">//   <span class="kw">in</span> the init block</a>
<a class="sourceLine" id="cb1-19" title="19">//</a>
<a class="sourceLine" id="cb1-20" title="20"><span class="kw">open</span> <span class="kw">class</span> C(<span class="va">arg</span>: <span class="dt">Int</span>) {</a>
<a class="sourceLine" id="cb1-21" title="21">    <span class="kw">val</span> <span class="va">i</span>: <span class="kw">Int</span></a>
<a class="sourceLine" id="cb1-22" title="22">    </a>
<a class="sourceLine" id="cb1-23" title="23">    init {</a>
<a class="sourceLine" id="cb1-24" title="24">        i = arg * arg</a>
<a class="sourceLine" id="cb1-25" title="25">    }</a>
<a class="sourceLine" id="cb1-26" title="26">}</a>
<a class="sourceLine" id="cb1-27" title="27"></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="co">// A class inherited from `C`</span></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="co">//   Does not have a primary constructor,</span></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="co">//   thus does not need to invoke the supertype constructor</span></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="co">//</span></a>
<a class="sourceLine" id="cb1-32" title="32"><span class="co">// The secondary constructor delegates to the supertype constructor</span></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="kw">class</span> D : <span class="dt">C</span> {</a>
<a class="sourceLine" id="cb1-34" title="34">    <span class="kw">constructor</span>(s: <span class="kw">String</span>) : <span class="kw">super</span>(s.toInt())</a>
<a class="sourceLine" id="cb1-35" title="35">}</a>
<a class="sourceLine" id="cb1-36" title="36"></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="co">// An open class inherited from `Base`</span></a>
<a class="sourceLine" id="cb1-38" title="38"><span class="co">//</span></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="co">// Has a companion object with a mutable property `name`</span></a>
<a class="sourceLine" id="cb1-40" title="40"><span class="kw">class</span> E : <span class="dt">Base</span>() {</a>
<a class="sourceLine" id="cb1-41" title="41">    <span class="kw">companion</span> <span class="kw">object</span> /* Companion */ {</a>
<a class="sourceLine" id="cb1-42" title="42">        <span class="kw">var</span> <span class="va">name</span> = <span class="st">&quot;I am a companion object of E!&quot;</span></a>
<a class="sourceLine" id="cb1-43" title="43">    }</a>
<a class="sourceLine" id="cb1-44" title="44">}</a></code></pre></div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> Pair(<span class="kw">val</span> <span class="va">a</span>: <span class="dt">Int</span>, <span class="kw">val</span> <span class="va">b</span>: <span class="dt">Int</span>) : <span class="dt">Comparable</span>&lt;<span class="dt">Pair</span>&gt; {</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">fun</span> <span class="fu">swap</span>(): <span class="dt">Pair</span> = Pair(b, a)</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">compareTo</span>(<span class="va">other</span>: <span class="dt">Pair</span>): <span class="dt">Int</span> {</a>
<a class="sourceLine" id="cb2-6" title="6">        <span class="kw">val</span> <span class="va">f</span> = a.compareTo(other.a)</a>
<a class="sourceLine" id="cb2-7" title="7">        <span class="cf">if</span> (f != <span class="dv">0</span>) <span class="kw">return</span> f</a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="kw">return</span> b.compareTo(other.b)</a>
<a class="sourceLine" id="cb2-9" title="9">    }</a>
<a class="sourceLine" id="cb2-10" title="10"></a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="kw">companion</span> <span class="kw">object</span> {</a>
<a class="sourceLine" id="cb2-12" title="12">        <span class="kw">fun</span> <span class="fu">duplet</span>(<span class="va">a</span>: <span class="dt">Int</span>) = Pair(a, a)</a>
<a class="sourceLine" id="cb2-13" title="13">    }</a>
<a class="sourceLine" id="cb2-14" title="14">}</a></code></pre></div>
</blockquote>
<h5 id="constructor-declaration">Constructor declaration</h5>
<div class="paragraph">
<p><span class="sentence">There are two types of class constructors in Kotlin: primary and secondary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A primary constructor is a concise way of describing class properties together with constructor parameters, and has the following form</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[\operatorname{\mathit{ptor}}: (p_1, \ldots, p_n)\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">where each of <span class="math inline">\(p_i\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">regular constructor parameter <span class="math inline">\(\operatorname{\mathit{name}}: \operatorname{\mathit{type}}\)</span>;</span></li>
<li><span class="sentence">read-only property constructor parameter <span class="math inline">\(\texttt{val}\ \operatorname{\mathit{name}}: \operatorname{\mathit{type}}\)</span>;</span></li>
<li><span class="sentence">mutable property constructor parameter <span class="math inline">\(\texttt{var}\ \operatorname{\mathit{name}}: \operatorname{\mathit{type}}\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Property constructor parameters, together with being regular constructor parameters, also declare class properties of the same name and type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: if a property constructor parameter with type <span class="math inline">\(T\)</span> is specified as <code>vararg</code>, its corresponding class property type is the result of <a href="type-system.html#array-types"><em>array type specialization</em></a> of type <code>Array&lt;</code><span class="math inline">\(\operatorname{\texttt{out\,}}T\)</span><code>&gt;</code>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">One can consider primary constructor parameters to have the following syntactic expansion.</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="kw">vararg</span> <span class="kw">val</span> <span class="va">d</span>: <span class="dt">Double</span>, <span class="kw">var</span> <span class="va">s</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d</span>, <span class="va">s</span>) {}</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="kw">vararg</span> <span class="va">d_</span>: <span class="dt">Double</span>, <span class="va">s_</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d_</span>, <span class="va">s_</span>) {</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="kw">val</span> <span class="va">d</span> = d_</a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="kw">var</span> <span class="va">s</span> = s_</a>
<a class="sourceLine" id="cb3-6" title="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">When accessing property constructor parameters inside the class body, one works with their corresponding properties; however, when accessing them in the supertype specifier list (e.g., as an argument to a superclass constructor invocation), we see them as actual parameters, which cannot be changed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class declaration has a primary constructor and also includes a class supertype specifier, that specifier must represent a valid invocation of the supertype constructor.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A secondary constructor describes an alternative way of creating a class instance and has only regular constructor parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class has a primary constructor, any secondary constructor must delegate to either the primary constructor or to another secondary constructor via <code>this(...)</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class does not have a primary constructor, its secondary constructors must delegate to either the superclass constructor via <code>super(...)</code> (if the superclass is present in the supertype specifier list) or to another secondary constructor via <code>this(...)</code>. </span><span class="sentence">If the only superclass is <code>kotlin.Any</code>, delegation is optional.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In all cases, it is forbidden if two or more secondary constructors form a delegation loop.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Class constructors (both primary and secondary) may have variable-argument parameters and default parameter values, just as regular functions. </span><span class="sentence">Please refer to the <a href="declarations.html#function-declaration">function declaration reference</a> for details.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class does not have neither primary, nor secondary constructors, it is assumed to implicitly have a default parameterless primary constructor. </span><span class="sentence">This also means that, if a class declaration includes a class supertype specifier, that specifier must represent a valid invocation of the supertype constructor.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">open</span> <span class="kw">class</span> Base</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">class</span> POKO : <span class="dt">Base</span>() {}</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">class</span> NotQuitePOKO : <span class="dt">Base</span> {</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="kw">constructor</span>() : <span class="kw">super</span>() {}</a>
<a class="sourceLine" id="cb4-7" title="7">}</a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="kw">class</span> Primary(<span class="kw">val</span> <span class="va">s</span>: <span class="dt">String</span>) : <span class="dt">Base</span>() {</a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="kw">constructor</span>(i: <span class="kw">Int</span>) : <span class="kw">this</span>(i.toString()) {}</a>
<a class="sourceLine" id="cb4-11" title="11"></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="kw">constructor</span>(d: <span class="kw">Double</span>) : <span class="kw">this</span>(d.toInt()) {}</a>
<a class="sourceLine" id="cb4-13" title="13"></a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="co">// Error, has primary ctor,</span></a>
<a class="sourceLine" id="cb4-15" title="15">    <span class="co">//   needs to delegate to primary or secondary ctor</span></a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="co">// constructor() : super() {}</span></a>
<a class="sourceLine" id="cb4-17" title="17">}</a>
<a class="sourceLine" id="cb4-18" title="18"></a>
<a class="sourceLine" id="cb4-19" title="19"><span class="kw">class</span> Secondary : <span class="dt">Base</span> {</a>
<a class="sourceLine" id="cb4-20" title="20">    <span class="kw">constructor</span>(i: <span class="kw">Int</span>) : <span class="kw">super</span>() {}</a>
<a class="sourceLine" id="cb4-21" title="21"></a>
<a class="sourceLine" id="cb4-22" title="22">    <span class="kw">constructor</span>(s: <span class="kw">String</span>) : <span class="kw">this</span>(s.toInt()) {}</a>
<a class="sourceLine" id="cb4-23" title="23"></a>
<a class="sourceLine" id="cb4-24" title="24">    <span class="co">// Ok, no primary ctor,</span></a>
<a class="sourceLine" id="cb4-25" title="25">    <span class="co">//   can delegate to `super(...)`</span></a>
<a class="sourceLine" id="cb4-26" title="26">    <span class="kw">constructor</span>() : <span class="kw">super</span>() {}</a>
<a class="sourceLine" id="cb4-27" title="27">}</a></code></pre></div>
</blockquote>
<h5 id="nested-and-inner-classifiers">Nested and inner classifiers</h5>
<div class="paragraph">
<p><span class="sentence">If a classifier declaration <span class="math inline">\(\operatorname{\text{ND}}\)</span> is <em>nested</em> in another classifier declaration <span class="math inline">\(\operatorname{\text{PD}}\)</span>, it creates a nested classifier type — a classifier type available under the path <span class="math inline">\(\operatorname{\text{PD}}.\operatorname{\text{ND}}\)</span>. </span><span class="sentence">In all other aspects, nested classifiers are equivalent to regular ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Inner</em> classes are a special kind of nested classifiers, which introduce types of objects associated (linked) with other (parent) objects. </span><span class="sentence">An inner class declaration <span class="math inline">\(\operatorname{\text{ID}}\)</span> nested in another classifier declaration <span class="math inline">\(\operatorname{\text{PD}}\)</span> may reference an <em>object</em> of type <span class="math inline">\(\operatorname{\text{ID}}\)</span> associated with it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This association happens when instantiating an object of type <span class="math inline">\(\operatorname{\text{ID}}\)</span>, as its constructor may be invoked only when a receiver of type <span class="math inline">\(\operatorname{\text{PD}}\)</span> is available, and this receiver becomes associated with the new instantiated object of type <span class="math inline">\(\operatorname{\text{ID}}\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For information on how type parameters of parent and nested / inner classifiers interoperate, we delegate you to the <a href="type-system.html#inner-and-nested-type-contexts">type system</a> section of the specification.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: inner classes cannot be declared in <a href="declarations.html#classifier-declaration">objects</a>.</span></p>
</div>
</blockquote>
<h5 id="inheritance-delegation">Inheritance delegation</h5>
<div class="paragraph">
<p><span class="sentence">In a classifier (an object or a class) declaration <span class="math inline">\(C\)</span>, any supertype <span class="math inline">\(I\)</span> inheritance may be <em>delegated to</em> an arbitrary value <span class="math inline">\(v\)</span> if:</span></p>
</div>
<ul>
<li><span class="sentence">The supertype <span class="math inline">\(I\)</span> is an interface type;</span></li>
<li><span class="sentence"><span class="math inline">\(v\)</span> has type <span class="math inline">\(T\)</span> such that <span class="math inline">\(T &lt;: I\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The inheritance delegation uses a syntax similar to <a href="declarations.html#delegated-property-declaration">property delegation</a> using the <code>by</code> keyword, but is specified in the classifier declaration header and is a very different concept. </span><span class="sentence">If inherited using delegation, each method <span class="math inline">\(M\)</span> of <span class="math inline">\(I\)</span> (whether they have a default implementation or not) is delegated to the corresponding method of <span class="math inline">\(v\)</span> as if it was overridden in <span class="math inline">\(C\)</span> with all the parameter values directly passed to the corresponding method in <span class="math inline">\(v\)</span>, unless the body of <span class="math inline">\(C\)</span> itself has a suitable override of <span class="math inline">\(M\)</span> (see the <a href="inheritance.html#overriding">method overriding</a> section).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The particular means on how <span class="math inline">\(v\)</span> is stored inside the classifier object is platform-defined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Due to the <a href="declarations.html#classifier-initialization">initialization order of a classifier object</a>, the expression used to construct <span class="math inline">\(v\)</span> can not access any of the classifier object properties or methods excluding the parameters of the primary constructor.</span></p>
</div>
<h5 id="abstract-classes">Abstract classes</h5>
<div class="paragraph">
<p><span class="sentence">A <a href="declarations.html#class-declaration">class declaration</a> can be marked <code>abstract</code>. </span><span class="sentence">Such classes <em>cannot</em> be instantiated directly; they are used as superclasses for other classes or objects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Abstract classes may contain one or more abstract members: members without implementation, which should be implemented in a subtype of this abstract class.</span></p>
</div>
<h4 id="data-class-declaration">Data class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A data class <span class="math inline">\(\operatorname{\mathit{dataClass}}\)</span> is a special kind of class, which represents a product type constructed from a number of data properties <span class="math inline">\((\operatorname{\mathit{dp}}_1, \ldots, \operatorname{\mathit{dp}}_m)\)</span>, described in its primary constructor. </span><span class="sentence">Non-property constructor parameters are not allowed in the primary constructor of a data class. </span><span class="sentence">As such, data classes allow Kotlin to reduce the boilerplate and generate a number of additional data-relevant functions.</span></p>
</div>
<ul>
<li><span class="sentence"><code>equals() / hashCode() / toString()</code> functions compliant with <a href="built-in-types-and-their-semantics.html#kotlin.any-1">their contracts</a>:</span>
<ul>
<li><span class="sentence"><code>equals(that)</code> returns true iff:</span>
<ul>
<li><span class="sentence"><code>that</code> has the same runtime type as <code>this</code>;</span></li>
<li><span class="sentence"><code>this.prop == that.prop</code> returns <code>true</code> for every data property <code>prop</code>;</span></li>
</ul></li>
<li><span class="sentence"><code>hashCode()</code> returns the same numbers for objects <code>A</code> and <code>B</code> if they are equal w.r.t. the generated <code>equals</code>;</span></li>
<li><span class="sentence"><code>toString</code> returns a string representations which is guaranteed to include the class name along with all the data properties’ string representations.</span></li>
</ul></li>
<li><span class="sentence">A <code>copy()</code> function for shallow object copying with the following properties:</span>
<ul>
<li><span class="sentence">It has the same number of parameters as the primary constructor with the same names and types;</span></li>
<li><span class="sentence">It calls the primary constructor with the corresponding parameters at the corresponding positions;</span></li>
<li><span class="sentence">It has defaults for all the parameters defaulting to the value of the corresponding property in <code>this</code> object.</span></li>
</ul></li>
<li><span class="sentence">A number of <code>componentN()</code> functions for <a href="declarations.html#local-property-declaration">destructuring declaration</a>:</span>
<ul>
<li><span class="sentence">For the data property at position <span class="math inline">\(N\)</span> (<strong>starting from 1</strong>), the generated <code>component</code><span class="math inline">\(N\)</span> function has the same type as this property and returns the value of this property;</span></li>
<li><span class="sentence">It has an <code>operator</code> modifier, allowing it to be used in <a href="declarations.html#local-property-declaration">destructuring declarations</a>;</span></li>
<li><span class="sentence">The number of these functions is the same as the number of data properties.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">All these functions consider only data properties <span class="math inline">\(\{\operatorname{\mathit{dp}}_i\}\)</span>; e.g., your data class may include regular property declarations in its body, however, they will <em>not</em> be considered in the <code>equals()</code> implementation or have a <code>componentN()</code> generated for them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are several rules as to how these generated functions may be explicified or inherited.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: a generated function is explicified, if its implementation is provided explicitly in the body of the data class. </span><span class="sentence">A generated function is inherited, if its implementation is taken from a supertype of the data class.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The declarations of <code>equals</code>, <code>hashCode</code> and <code>toString</code> may be explicified similarly to how overriding works in normal classes. </span><span class="sentence">If a correct explicit implementation is available, no function is generated. </span><span class="sentence">Other functions (<code>copy</code>, <code>componentN</code>) <strong>cannot</strong> be explicified.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The declarations of <code>equals</code>, <code>hashCode</code> and <code>toString</code> may be inherited from the base class, if it provides a <code>final</code> version with a <a href="declarations.html#function-signature">matching signature</a>. </span><span class="sentence">If a correct inherited implementation is available, no function is generated. </span><span class="sentence">Other functions (<code>copy</code>, <code>componentN</code>) <strong>cannot</strong> be inherited.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In addition, for every generated function, if any of the base types provide an open function with a <a href="declarations.html#function-signature">matching signature</a>, it is automatically overridden by the generated function as if it was generated with an <code>override</code> modifier.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: base classes may also have functions that have a conflicting signature with the same function name. </span><span class="sentence">As expected, these cases result in override or overload conflicts the same way they would with a normal class declaration.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Data classes have the following restrictions:</span></p>
</div>
<ul>
<li><span class="sentence">Data classes are closed and cannot be <a href="inheritance.html#inheritance">inherited</a> from;</span></li>
<li><span class="sentence">Data classes must have a primary constructor with property constructor parameters only, which become data properties for the data class;</span></li>
<li><span class="sentence">There must be at least one data property in the primary constructor;</span></li>
<li><span class="sentence">Data properties cannot be specified as <code>vararg</code> constructor arguments.</span></li>
</ul>
<h4 id="enum-class-declaration">Enum class declaration</h4>
<div class="paragraph">
<p><span class="sentence">Enum class <span class="math inline">\(E\)</span> is a special kind of class with the following properties:</span></p>
</div>
<ul>
<li><span class="sentence">It has a number of predefined values that are declared in the class itself (<em>enum entries</em>);</span></li>
<li><span class="sentence">No other values of this class can be constructed;</span></li>
<li><span class="sentence">It implicitly inherits the built-in class <a href="built-in-types-and-their-semantics.html#kotlin.enum"><code>kotlin.Enum&lt;E&gt;</code></a> (and cannot have any other base classes);</span></li>
<li><span class="sentence">It it implicitly final and cannot be inherited from;</span></li>
<li><span class="sentence">It has special syntax to accommodate for the properties described above.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Enum class body uses special kind of syntax (see grammar) to declare enum entries in addition to all other declarations inside the class body. </span><span class="sentence">Enum entries have their own bodies that may contain their own declarations, similar to <a href="declarations.html#classifier-declaration">object declarations</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an enum class can have zero enum entries. </span><span class="sentence">This makes objects of this class impossible to construct.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Every enum entry of class <code>E</code> implicitly overrides members of <code>kotlin.Enum&lt;E&gt;</code> in the following way:</span></p>
</div>
<ul>
<li><div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">public</span> <span class="kw">final</span> <span class="kw">val</span> <span class="va">name</span>: <span class="kw">String</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">defined to be the same as the name of the entry as declared in code;</span></p>
</div></li>
<li><div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">public</span> <span class="kw">final</span> <span class="kw">val</span> <span class="va">ordinal</span>: <span class="kw">Int</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">defined to be the ordinal of the entry, e.g. the position of this entry in the list of entries, starting with 0;</span></p>
</div></li>
<li><div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">public</span> <span class="kw">override</span> <span class="kw">final</span> <span class="kw">fun</span> <span class="fu">compareTo</span>(<span class="va">other</span>: <span class="dt">E</span>): <span class="dt">Int</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">(a member of <code>kotlin.Comparable&lt;E&gt;</code>) defined by default to compare entries by their ordinals, but may be overridden to have different behaviour both in the enum class declaration and in entry declarations;</span></p>
</div></li>
<li><div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">public</span> <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">toString</span>(): <span class="dt">String</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">(a member of <code>kotlin.Any</code>) defined by default to return the entry name, but may be overridden to have different behaviour both in the enum class declaration and in entry declarations.</span></p>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In addition to these, every enum class type <code>E</code> has the following <strong>static</strong> member functions declared implicitly:</span></p>
</div>
<ul>
<li><div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">public</span> <span class="kw">final</span> static <span class="kw">fun</span> <span class="fu">valueOf</span>(<span class="va">value</span>: <span class="dt">String</span>): <span class="dt">E</span></a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">returning an object corresponding to the entry with the name equal to <code>value</code> parameter of the call;</span></p>
</div></li>
<li><div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">public</span> <span class="kw">final</span> static <span class="kw">fun</span> <span class="fu">values</span>(): <span class="dt">kotlin</span>.<span class="fu">Array</span>&lt;<span class="dt">E</span>&gt;</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">returning an <a href="type-system.html#array-types">array</a> of all possible enum values. </span><span class="sentence">Every invocation of this function returns a new array to disallow changing its contents.</span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: <code>static</code> is not a valid Kotlin keyword and is only used here for clarity</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: these static member functions are handled differently by the <a href="overload-resolution.html#overload-resolution">overload resolution</a>.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin standard library introduces another function to access all enum values for a specific enum class called <code>kotlin.enumValues&lt;T&gt;</code>. </span><span class="sentence">Please refer to the standard library documentation for details.</span></p>
</div>
</blockquote>
<h4 id="annotation-class-declaration">Annotation class declaration</h4>
<div class="paragraph">
<p><span class="sentence">Annotations class is a special kind of class that is used to declare <a href="annotations.html#annotations">annotations</a>. </span><span class="sentence">Annotation classes have the following properties:</span></p>
</div>
<ul>
<li><span class="sentence">They cannot have any secondary constructors;</span></li>
<li><span class="sentence">All the primary constructor parameters must use the property syntax;</span></li>
<li><span class="sentence">They implicitly inherit <code>kotlin.Annotation</code> class (and cannot have any other base classes);</span></li>
<li><span class="sentence">They cannot implement interfaces;</span></li>
<li><span class="sentence">They are implicitly closed and cannot be inherited from;</span></li>
<li><span class="sentence">They may not have any member functions, properties not declared in the primary constructor or any overriding declarations;</span></li>
<li><span class="sentence">They cannot have companion objects;</span></li>
<li><span class="sentence">They cannot have nested classes;</span></li>
<li><span class="sentence">They cannot have type parameters;</span></li>
<li><span class="sentence">The types of primary constructor parameters are limited to:</span>
<ul>
<li><span class="sentence"><code>kotlin.String</code>;</span></li>
<li><span class="sentence"><code>kotlin.KClass</code>;</span></li>
<li><span class="sentence"><a href="type-system.html#built-in-types">Built-in number types</a>;</span></li>
<li><span class="sentence">Other annotation types;</span></li>
<li><span class="sentence">Arrays of any other allowed type.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Annotation classes cannot be constructed directly, but their primary constructors are used when specifying <a href="annotations.html#annotations">code annotations</a> for other entities.</span></p>
</div>
<h4 id="interface-declaration">Interface declaration</h4>
<div class="paragraph">
<p><span class="sentence">Interfaces differ from classes in that they cannot be directly instantiated in the program, they are meant as a way of describing a contract which should be satisfied by the interface’s subtypes. </span><span class="sentence">In other aspects they are similar to classes, therefore we shall specify their declarations by specifying their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An interface cannot have a class as its supertype;</span></li>
<li><span class="sentence">An interface cannot have a constructor;</span></li>
<li><span class="sentence">Interface properties cannot have initializers or backing fields;</span></li>
<li><span class="sentence">Interface properties cannot be delegated;</span></li>
<li><span class="sentence">An interface cannot have inner classes (but can have nested classes and companion objects);</span></li>
<li><span class="sentence">An interface and all its members are implicitly open;</span></li>
<li><span class="sentence">All interface member properties and functions are implicitly public;</span>
<ul>
<li><span class="sentence">Trying to declare a non-public member property or function in an interface is an compile-time error.</span></li>
</ul></li>
</ul>
<h5 id="functional-interface-declaration">Functional interface declaration</h5>
<div class="paragraph">
<p><span class="sentence">A <em>functional interface</em> is an interface with a <strong>single</strong> abstract function and no other abstract properties or functions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A function interface declaration is marked as <code>fun interface</code>. </span><span class="sentence">It has the following additional restrictions compared to regular <a href="declarations.html#interface-declaration">interface declarations</a>.</span></p>
</div>
<ul>
<li><span class="sentence">A functional interface can have only one abstract member function, which must be non-parameterized;</span></li>
<li><span class="sentence">A functional interface cannot have any abstract member properties;</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A functional interface has an associated <a href="type-system.html#function-types">function type</a>, which is the same as the function type of its single abstract member function.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: the associated function type of a functional interface is different from the type of said functional interface.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If one needs an object of a functional interface type, they can use the regular ways of implementing an interface, either via an [anonymous object declaration] or as a complete <a href="declarations.html#classifier-declaration">class</a>. </span><span class="sentence">However, as functional interface essentially represents a single function, Kotlin supports the following additional ways of providing a functional interface implementation from function values (expressions with function type).</span></p>
</div>
<ul>
<li><span class="sentence">If a lambda literal <code>L</code> is preceded with a functional interface name <code>T</code>, and the type of <code>L</code> is a subtype of the associated function type of <code>T</code>, this expression creates an instance of <code>T</code> with lambda literal <code>L</code> used as its abstract member function implementation.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">fun</span> <span class="kw">interface</span> <span class="fu">FI</span> {</a>
<a class="sourceLine" id="cb11-2" title="2">     <span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">s</span>: <span class="dt">Int</span>): <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-3" title="3">}</a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="kw">fun</span> <span class="fu">foo</span>() {</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="kw">val</span> <span class="va">fi</span> = FI { it }</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="kw">val</span> <span class="va">fi2</span> = FI { s: <span class="kw">Int</span> -&gt; s + <span class="dv">42</span> }</a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="kw">val</span> <span class="va">fi3</span> = FI { s: Number -&gt; s.toInt() }</a>
<a class="sourceLine" id="cb11-9" title="9">}</a></code></pre></div>
</blockquote>
<ul>
<li><span class="sentence">If an expression <code>L</code> is used as an argument of functional type <code>T</code> in a <a href="expressions.html#function-calls-and-property-access">function call</a>, and the type of <code>L</code> is a subtype of the associated function type of <code>T</code>, this argument is considered as an instance of <code>T</code> with expression <code>L</code> used as its abstract member function implementation.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">fun</span> <span class="kw">interface</span> <span class="fu">FI</span> {</a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">s</span>: <span class="dt">Int</span>): <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-3" title="3">}</a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="kw">fun</span> <span class="fu">doIt</span>(<span class="va">fi</span>: <span class="dt">FI</span>) {}</a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="kw">fun</span> <span class="fu">foo</span>() {</a>
<a class="sourceLine" id="cb12-8" title="8">    doIt { it }</a>
<a class="sourceLine" id="cb12-9" title="9">    doIt { s: <span class="kw">Int</span> -&gt; s + <span class="dv">42</span> }</a>
<a class="sourceLine" id="cb12-10" title="10">    doIt { s: Number -&gt; s.toInt() }</a>
<a class="sourceLine" id="cb12-11" title="11"></a>
<a class="sourceLine" id="cb12-12" title="12">    doIt(<span class="kw">fun</span>(<span class="va">s</span>): <span class="dt">Int</span> { <span class="kw">return</span> s; })</a>
<a class="sourceLine" id="cb12-13" title="13"></a>
<a class="sourceLine" id="cb12-14" title="14">    <span class="kw">val</span> <span class="va">l</span> = { s: Number -&gt; s.toInt() }</a>
<a class="sourceLine" id="cb12-15" title="15"></a>
<a class="sourceLine" id="cb12-16" title="16">    doIt(l)</a>
<a class="sourceLine" id="cb12-17" title="17">}</a></code></pre></div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Informally: this feature is known as “Single Abstract Method” (SAM) conversion.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: in Kotlin version 1.3 and earlier, SAM conversion was not available for Kotlin functional interfaces. </span><span class="sentence">It was, however, available on Kotlin/JVM for Java functional interfaces.</span></p>
</div>
</blockquote>
<h4 id="object-declaration">Object declaration</h4>
<div class="paragraph">
<p><span class="sentence">Object declarations are similar to class declaration in that they introduce a new classifier type, but, unlike class or interface declarations, they also introduce a value of this type in the same declaration. </span><span class="sentence">No other values of this type may be declared, making object a single existing value of its type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note:This is similar to <em>singleton pattern</em> common to object-oriented programming in introducing a type which includes a single global value.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Similarly to interfaces, we shall specify object declarations by highlighting their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An object can only be declared in a declaration scope;</span></li>
<li><span class="sentence">An object type cannot be used as a supertype for other types;</span></li>
<li><span class="sentence">An object cannot have an explicit primary or secondary constructor;</span></li>
<li><span class="sentence">An object cannot have a companion object;</span></li>
<li><span class="sentence">An object may not have inner classes;</span></li>
<li><span class="sentence">An object cannot be parameterized, i.e., cannot have type parameters.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an object is assumed to implicitly have a default parameterless primary constructor.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this section is about declaration of <em>named</em> objects. </span><span class="sentence">Kotlin also has a concept of <em>anonymous</em> objects, or object literals, which are similar to their named counterparts, but are expressions rather than declarations and, as such, are described in the <a href="expressions.html#object-literals">corresponding section</a>.</span></p>
</div>
</blockquote>
<h4 id="classifier-initialization">Classifier initialization</h4>
<div class="paragraph">
<p><span class="sentence">When creating a class or object instance via one of its constructors <span class="math inline">\(ctor\)</span>, it is initialized in a particular order, which we describe here.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A primary <span class="math inline">\(pctor\)</span> or secondary constructor <span class="math inline">\(ctor\)</span> has a corresponding superclass constructor <span class="math inline">\(sctor\)</span> defined as follows.</span></p>
</div>
<ul>
<li><span class="sentence">For primary constructor <span class="math inline">\(pctor\)</span>, a corresponding superclass constructor <span class="math inline">\(sctor\)</span> is the one from the supertype specifier list;</span></li>
<li><span class="sentence">For secondary constructor <span class="math inline">\(ctor\)</span>, a corresponding supertype constructor <span class="math inline">\(sctor\)</span> is the one ending the constructor delegation chain of <span class="math inline">\(ctor\)</span>;</span></li>
<li><span class="sentence">If an explicit superclass constructor is not available, <code>Any()</code> is implicitly used.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">When a classifier type is initialized using a particular secondary constructor <span class="math inline">\(ctor\)</span> delegated to primary constructor <span class="math inline">\(pctor\)</span> which, in turn, is delegated to the corresponding superclass constructor <span class="math inline">\(sctor\)</span>, the following happens, in this <em>initialization order</em>:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(pctor\)</span> is invoked using the specified parameters, initializing all the properties declared by its property parameters <em>in the order of appearance in the constructor declaration</em>;</span></li>
<li><span class="sentence">The superclass object is initialized as if created by invoking <span class="math inline">\(sctor\)</span> with the specified parameters;</span></li>
<li><span class="sentence">Interface delegation expressions are invoked and the result of each is stored in the object to allow for interface delegation, <em>in the order of appearance of delegation declarations in the supertype specifier list</em>;</span></li>
<li><span class="sentence">Each property initialization code as well as the initialization blocks in the class body are invoked <em>in the order of appearance in the class body</em>;</span></li>
<li><span class="sentence"><span class="math inline">\(ctor\)</span> body is invoked using the specified parameters.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that if an <code>init</code>-block appears between two property declarations in the class body, its body is invoked between the initialization code of these two properties.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The initialization order stays the same if any of the entities involved are omitted, in which case the corresponding step is also omitted (e.g., if the object is created using the primary constructor, the body of the secondary one is not invoked).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If any step in the initialization order creates a loop, it is considered to be undefined behavior.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If any of the properties are accessed before they are initialized w.r.t initialization order (e.g., if a method called in an initialization block accesses a property declared <em>after</em> the initialization block), the value of the property is undefined.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this can also happen if a property is captured in a lambda expression used in some way during subsequent initialization steps.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">open</span> <span class="kw">class</span> Base(<span class="kw">val</span> <span class="va">v</span>: <span class="dt">Any?</span>) {</a>
<a class="sourceLine" id="cb13-2" title="2">    init {</a>
<a class="sourceLine" id="cb13-3" title="3">        println(<span class="st">&quot;2: $this&quot;</span>)</a>
<a class="sourceLine" id="cb13-4" title="4">    }</a>
<a class="sourceLine" id="cb13-5" title="5">}</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="kw">class</span> Init(<span class="kw">val</span> <span class="va">a</span>: <span class="dt">Number</span> /* (<span class="va">1</span>) */) : <span class="dt">Base</span>(<span class="va">0xC0FFEE</span>) /* (<span class="va">2</span>) */ {</a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9">    init {</a>
<a class="sourceLine" id="cb13-10" title="10">        println(<span class="st">&quot;3: $this&quot;</span>) <span class="co">/* (3) */</span></a>
<a class="sourceLine" id="cb13-11" title="11">    }</a>
<a class="sourceLine" id="cb13-12" title="12"></a>
<a class="sourceLine" id="cb13-13" title="13">    <span class="kw">constructor</span>(v: <span class="kw">Int</span>) : <span class="kw">this</span>(v <span class="kw">as</span> Number) {</a>
<a class="sourceLine" id="cb13-14" title="14">        println(<span class="st">&quot;10: $this&quot;</span>) <span class="co">/* (10) */</span></a>
<a class="sourceLine" id="cb13-15" title="15">    }</a>
<a class="sourceLine" id="cb13-16" title="16"></a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="kw">val</span> <span class="va">b</span>: <span class="kw">String</span> = a.toString() <span class="co">/* (4) */</span></a>
<a class="sourceLine" id="cb13-18" title="18"></a>
<a class="sourceLine" id="cb13-19" title="19">    init {</a>
<a class="sourceLine" id="cb13-20" title="20">        println(<span class="st">&quot;5: $this&quot;</span>) <span class="co">/* (5) */</span></a>
<a class="sourceLine" id="cb13-21" title="21">    }</a>
<a class="sourceLine" id="cb13-22" title="22"></a>
<a class="sourceLine" id="cb13-23" title="23">    <span class="kw">var</span> <span class="va">c</span>: Any? = <span class="st">&quot;b is $b&quot;</span> <span class="co">/* (6) */</span></a>
<a class="sourceLine" id="cb13-24" title="24"></a>
<a class="sourceLine" id="cb13-25" title="25">    init {</a>
<a class="sourceLine" id="cb13-26" title="26">        println(<span class="st">&quot;7: $this&quot;</span>) <span class="co">/* (7) */</span></a>
<a class="sourceLine" id="cb13-27" title="27">    }</a>
<a class="sourceLine" id="cb13-28" title="28"></a>
<a class="sourceLine" id="cb13-29" title="29">    <span class="kw">val</span> <span class="va">d</span>: <span class="kw">Double</span> = <span class="fl">42.0</span> <span class="co">/* (8) */</span></a>
<a class="sourceLine" id="cb13-30" title="30"></a>
<a class="sourceLine" id="cb13-31" title="31">    init {</a>
<a class="sourceLine" id="cb13-32" title="32">        println(<span class="st">&quot;9: $this&quot;</span>) <span class="co">/* (9) */</span></a>
<a class="sourceLine" id="cb13-33" title="33">    }</a>
<a class="sourceLine" id="cb13-34" title="34"></a>
<a class="sourceLine" id="cb13-35" title="35">    <span class="kw">override</span> <span class="kw">fun</span> <span class="fu">toString</span>(): <span class="dt">String</span> {</a>
<a class="sourceLine" id="cb13-36" title="36">        <span class="kw">return</span> <span class="st">&quot;Init(a=$a, b=&#39;$b&#39;, c=$c, d=$d)&quot;</span></a>
<a class="sourceLine" id="cb13-37" title="37">    }</a>
<a class="sourceLine" id="cb13-38" title="38">}</a>
<a class="sourceLine" id="cb13-39" title="39"></a>
<a class="sourceLine" id="cb13-40" title="40"><span class="kw">fun</span> <span class="fu">main</span>() {</a>
<a class="sourceLine" id="cb13-41" title="41">    Init(<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb13-42" title="42">    <span class="co">// 2: Init(a=null, b=&#39;null&#39;, c=null, d=0.0)</span></a>
<a class="sourceLine" id="cb13-43" title="43">    <span class="co">// 3: Init(a=5, b=&#39;null&#39;, c=null, d=0.0)</span></a>
<a class="sourceLine" id="cb13-44" title="44">    <span class="co">// 5: Init(a=5, b=&#39;5&#39;, c=null, d=0.0)</span></a>
<a class="sourceLine" id="cb13-45" title="45">    <span class="co">// 7: Init(a=5, b=&#39;5&#39;, c=b is 5, d=0.0)</span></a>
<a class="sourceLine" id="cb13-46" title="46">    <span class="co">// 9: Init(a=5, b=&#39;5&#39;, c=b is 5, d=42.0)</span></a>
<a class="sourceLine" id="cb13-47" title="47">    <span class="co">// 10: Init(a=5, b=&#39;5&#39;, c=b is 5, d=42.0)</span></a>
<a class="sourceLine" id="cb13-48" title="48">    </a>
<a class="sourceLine" id="cb13-49" title="49">    <span class="co">// Here we can see how the undefined values for</span></a>
<a class="sourceLine" id="cb13-50" title="50">    <span class="co">//   uninitialized properties may leak outside</span></a>
<a class="sourceLine" id="cb13-51" title="51">}</a></code></pre></div>
</blockquote>
<h3 id="function-declaration">Function declaration</h3>
<div id="grammar-rule-functionDeclaration-pasted-2" class="grammar-rule">
<dl>
<dt><strong><em>functionDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="syntax.html#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'fun'</code><br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-receiverType">receiverType</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-type">type</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionBody-pasted-3" class="grammar-rule">
<dl>
<dt><strong><em>functionBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="syntax.html#grammar-rule-block">block</a></em><br />
| (<code>'='</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Function declarations assign names to functions — blocks of code which may be called by passing them a number of arguments. </span><span class="sentence">Functions have special <em>function types</em> which are covered in more detail <a href="type-system.html#function-types">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A simple function declaration consists of four main parts:</span></p>
</div>
<ul>
<li><span class="sentence">Name <span class="math inline">\(f\)</span>;</span></li>
<li><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 [= v_1], \ldots, p_n: P_n [= v_n])\)</span>;</span></li>
<li><span class="sentence">Return type <span class="math inline">\(R\)</span>;</span></li>
<li><span class="sentence">Body <span class="math inline">\(b\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and has a function type <span class="math inline">\(f : (p_1: P_1, \ldots, p_n: P_n) \rightarrow R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 [= v_1], \ldots, p_n: P_n [= v_n])\)</span> describes function parameters — inputs needed to execute the declared function. </span><span class="sentence">Each parameter <span class="math inline">\(p_i: P_i = v_i\)</span> introduces <span class="math inline">\(p_i\)</span> as a name of value with type <span class="math inline">\(P_i\)</span> available inside function body <span class="math inline">\(b\)</span>; therefore, parameters are final and cannot be changed inside the function. </span><span class="sentence">A function may have zero or more parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameter may include a default value <span class="math inline">\(v_i\)</span>, which is used if the corresponding argument is not specified in function invocation; <span class="math inline">\(v_i\)</span> must be an expression which evaluates to type <span class="math inline">\(V &lt;: P_i\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Return type <span class="math inline">\(R\)</span>, if omitted, is calculated as follows.</span></p>
</div>
<ul>
<li><span class="sentence">If function body <span class="math inline">\(b\)</span> is present in the expression form and it may be inferred to have a valid type <span class="math inline">\(B : B \not \equiv \operatorname{\texttt{kotlin.Nothing}}\)</span>, <span class="math inline">\(R \equiv B\)</span>.</span></li>
<li><span class="sentence">If function body <span class="math inline">\(b\)</span> is present in the block form, <span class="math inline">\(R \equiv \operatorname{\texttt{kotlin.Unit}}\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In other cases return type <span class="math inline">\(R\)</span> cannot be omitted and must be specified explicitly.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As type <code>kotlin.Nothing</code> has a <a href="built-in-types-and-their-semantics.html#kotlin.nothing-1">special meaning</a> in Kotlin type system, it must be specified explicitly, to avoid spurious <code>kotlin.Nothing</code> function return types.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Function body <span class="math inline">\(b\)</span> is optional; if it is omitted, a function declaration creates an <em>abstract</em> function, which does not have an implementation. </span><span class="sentence">This is allowed only inside an <a href="inheritance.html#abstract-classes-1">abstract class</a>. </span><span class="sentence">If a function body <span class="math inline">\(b\)</span> is present, it should evaluate to type <span class="math inline">\(B\)</span> which should satisfy <span class="math inline">\(B &lt;: R\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO([Kotlin 1.3+] <code>expect</code> and <code>external</code> functions also do not have implementations)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized function declaration consists of five main parts.</span></p>
</div>
<ul>
<li><span class="sentence">Name <span class="math inline">\(f\)</span>;</span></li>
<li><span class="sentence">Type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span>;</span></li>
<li><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span>;</span></li>
<li><span class="sentence">Return type <span class="math inline">\(R\)</span>;</span></li>
<li><span class="sentence">Body <span class="math inline">\(b\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple function declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="declarations.html#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h4 id="function-signature">Function signature</h4>
<div class="paragraph">
<p><span class="sentence">In some cases we need to establish whether one function declaration <em>matches</em> another, e.g., for checking <a href="inheritance.html#overriding">overridability</a>. </span><span class="sentence">To do that, we compare <em>function signatures</em>, which consist of the following.</span></p>
</div>
<ul>
<li><span class="sentence">Name <span class="math inline">\(f\)</span>;</span></li>
<li><span class="sentence">Type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span> (if present);</span></li>
<li><span class="sentence">Parameter list <span class="math inline">\(P_1, \ldots, P_n\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Two function signatures <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are considered <em>matching</em>, if the following is true.</span></p>
</div>
<ul>
<li><span class="sentence">Name of <span class="math inline">\(A\)</span> is the same as the name of <span class="math inline">\(B\)</span>;</span></li>
<li><span class="sentence">Formal parameter types of <span class="math inline">\(A\)</span> are pairwise equal to the formal parameter types of <span class="math inline">\(B\)</span> w.r.t. possible type parameter substitutions;</span></li>
<li><span class="sentence">If the number of type parameters is the same, type parameters of <span class="math inline">\(A\)</span> must be pairwise <a href="type-system.html#subtyping">equivalent</a> to the type parameters of <span class="math inline">\(B\)</span>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: a platform implementation may change which function signatures are considered matching, depending on the platform’s specifics.</span></p>
</div>
</blockquote>
<h4 id="named-positional-and-default-parameters">Named, positional and default parameters</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>named</em> parameters out-of-the-box, meaning one can bind an argument to a parameter in function invocation not by its position, but by its name, which is equal to the argument name.</span></p>
</div>
<div class="sourceCode" id="cb14"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Double</span>, <span class="va">s</span>: <span class="dt">String</span>): <span class="dt">Double</span> = a + b + s.toDouble()</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb14-4" title="4">    println(bar(b = <span class="fl">42.0</span>, a = <span class="dv">5</span>, s = <span class="st">&quot;13&quot;</span>))</a>
<a class="sourceLine" id="cb14-5" title="5">}</a></code></pre></div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: it is prohibited to bind the same named parameter to an argument several times, such invocations should result in a compile-time error.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">All the names of named parameters are resolved at compile-time, meaning that performing a call with a parameter name not used at declaration-site is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If one wants to mix named and positional arguments, the argument list must conform to the following form: <span class="math inline">\(PoN_1, \ldots, PoN_M, N_1, \ldots, N_Q\)</span>, where <span class="math inline">\(PoN_i\)</span> is an i-th argument in either positional or named form, <span class="math inline">\(N_j\)</span> is a named argument irregardless of its position.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: in Kotlin version 1.3 and earlier, <span class="math inline">\(PoN_i\)</span> were restricted to positional arguments only.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If one needs to provide a named argument to a <a href="declarations.html#variable-length-parameters">variable length parameter</a>, it can be achieved via either regular named argument <code>arg = arr</code> or a spread operator expression form <code>arg = *arr</code>. </span><span class="sentence">In both cases type of <code>arr</code> must be a subtype of <a href="type-system.html#array-types"><span class="math inline">\(\operatorname{\text{ATS}}(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{out\,}}T))\)</span></a> for a variable length parameter of type <span class="math inline">\(T\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: in Kotlin version 1.3 and earlier, only the spread operator expression form for named variable length arguments was supported.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports <em>default</em> parameters — parameters which have a default value used in function invocation, if the corresponding argument is missing. </span><span class="sentence">Note that default parameters cannot be used to provide a value for positional argument <em>in the middle</em> of the positional argument list; allowing this would create an ambiguity of which argument for position <span class="math inline">\(i\)</span> is the correct one: explicit one provided by the developer or implicit one from the default value.</span></p>
</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span> = 1, <span class="va">b</span>: <span class="dt">Double</span> = 42.0, <span class="va">s</span>: <span class="dt">String</span> = <span class="st">&quot;Hello&quot;</span>): <span class="dt">Double</span> =</a>
<a class="sourceLine" id="cb15-2" title="2">    a + b + s.toDouble()</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="co">// Valid call, all default parameters used</span></a>
<a class="sourceLine" id="cb15-6" title="6">    println(bar())</a>
<a class="sourceLine" id="cb15-7" title="7">    <span class="co">// Valid call, defaults for `b` and `s` used</span></a>
<a class="sourceLine" id="cb15-8" title="8">    println(bar(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb15-9" title="9">    <span class="co">// Valid call, default for `b` used</span></a>
<a class="sourceLine" id="cb15-10" title="10">    println(bar(<span class="dv">2</span>, s = <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb15-11" title="11"></a>
<a class="sourceLine" id="cb15-12" title="12">    <span class="co">// Invalid call, default for `b` cannot be used</span></a>
<a class="sourceLine" id="cb15-13" title="13">    println(bar(<span class="dv">2</span>, <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb15-14" title="14">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">In summary, argument list should have the following form:</span></p>
</div>
<ul>
<li><span class="sentence">Zero or more arguments in either positional or named form;</span></li>
<li><span class="sentence">Zero or more named arguments.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Missing arguments are bound to their default values, if they exist.</span></p>
</div>
<h4 id="variable-length-parameters">Variable length parameters</h4>
<div class="paragraph">
<p><span class="sentence">One of the parameters may be designated as being variable length (aka <em>vararg</em>). </span><span class="sentence">A parameter list <span class="math inline">\((p_1, \ldots, \text{vararg }p_i: P_i = v_i, \ldots, p_n)\)</span> means a function may be called with any number of arguments in the i-th position. </span><span class="sentence">These arguments are represented inside function body <span class="math inline">\(b\)</span> as a value <span class="math inline">\(p_i\)</span> of type, which is the result of <a href="type-system.html#array-types"><em>array type specialization</em></a> of type <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{out\,}}P_i)\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: we also consider variable length parameters to have such types for the purposes of type inference and named parameters. </span><span class="sentence">TODO(Something else?)</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter is not last in the parameter list, all subsequent arguments in the function invocation should be specified as named arguments.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter has a default value, it should be an expression which evaluates to a value of type, which is the result of <a href="type-system.html#array-types"><em>array type specialization</em></a> of type <span class="math inline">\(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{out\,}}P_i)\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A value of type <span class="math inline">\(Q &lt;: \operatorname{\text{ATS}}(\operatorname{\texttt{kotlin.Array}}(\operatorname{\texttt{out\,}}P_i))\)</span> may be <em>unpacked</em> to a variable length parameter in function invocation using <a href="expressions.html#spread-operator-expressions">spread operator</a>; in this case array elements are considered to be separate arguments in the variable length parameter position.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that, for variable length parameters corresponding to specialized array types, unpacking is possible only for these specialized versions; for a variable length parameter of type <code>Int</code>, for example, unpacking is valid only for <code>IntArray</code>, and not for <code>Array&lt;Int&gt;</code>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A function invocation may include several spread operator expressions corresponding to the vararg parameter.</span></p>
</div>
<h4 id="extension-function-declaration">Extension function declaration</h4>
<div class="paragraph">
<p><span class="sentence">An <em>extension function declaration</em> is similar to a standard function declaration, but introduces an additional special function parameter, the <em>receiver parameter</em>. </span><span class="sentence">This parameter is designated by specifying the receiver type (the type before <code>.</code> in function name), which becomes the type of this receiver parameter. </span><span class="sentence">This parameter is not named and must always be supplied (either explicitly or implicitly), e.g. it cannot be a variable-argument parameter, have a default value, etc.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Calling such a function is special because the receiver parameter is not supplied as an argument of the call, but as the <a href="overload-resolution.html#receivers"><em>receiver</em></a> of the call, be it implicit or explicit. </span><span class="sentence">This parameter is available inside the scope of the function as the implicit receiver or <code>this</code>-expression, while nested scopes may introduce additional receivers that take precedence over this one. </span><span class="sentence">See <a href="overload-resolution.html#receivers">the receiver section</a> for details. </span><span class="sentence">This receiver is also available (as usual) in nested scope using labeled <code>this</code> syntax using the name of the declared function as the label.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For more information on how a particular receiver for each call is chosen, please refer to the <a href="overload-resolution.html#overload-resolution">overloading section</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when declaring extension functions inside classifier declarations, this receiver takes precedence over the classifier object, which is usually the current receiver inside nested functions</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For all other purposes, extension functions are not different from non-extension functions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb16"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">foo</span>() { println(<span class="kw">this</span> + <span class="dv">1</span>) } <span class="co">// this has type Int</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="fl">2.f</span>oo() <span class="co">// prints &quot;3&quot;</span></a>
<a class="sourceLine" id="cb16-5" title="5">}</a>
<a class="sourceLine" id="cb16-6" title="6"></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">class</span> Bar {</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="kw">fun</span> <span class="fu">foo</span>() { println(<span class="kw">this</span>) } <span class="co">// this has type Bar</span></a>
<a class="sourceLine" id="cb16-9" title="9">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">foo</span>() { println(<span class="kw">this</span>) } <span class="co">// this has type Int</span></a>
<a class="sourceLine" id="cb16-10" title="10">}</a></code></pre></div>
<h4 id="inlining">Inlining</h4>
<div class="paragraph">
<p><span class="sentence">A function may be declared <code>inline</code> using a special <code>inline</code> modifier. </span><span class="sentence">This allows the compiler to inline the function at call-site, replacing the call with the body of the function with arguments mapped to corresponding parameters. </span><span class="sentence">It is unspecified whether inlining will actually be performed, however.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Declaring a function <code>inline</code> has two additional effects:</span></p>
</div>
<ul>
<li><span class="sentence">It allows type parameters of the function to be declared <code>reified</code>, making them <a href="runtime-type-information.html#runtime-available-types">runtime-available</a> and allowing usage of specific expressions involving these parameters, such as <a href="expressions.html#type-checking-expression">type checks</a> and <a href="expressions.html#class-literals">class literals</a>. </span><span class="sentence">Calling such a function is only allowed in a context where a particular type argument provided for this type parameter is also a runtime-available type.</span></li>
<li><span class="sentence">Any parameter of this function of a <a href="type-system.html#function-types">function type</a> is treated as <em>inlined</em> parameter unless it has one of two special modifiers: <code>crossinline</code> or <code>noinline</code>. </span><span class="sentence">If a particular argument corresponding to inline parameter is a <a href="expressions.html#lambda-literals">lambda literal</a>, this lambda literal is considered <em>inlined</em> and, in particular, affects the way the <a href="expressions.html#return-expressions">return expressions</a> are handled in its body. </span><span class="sentence">See the corresponding section for details.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Inlined parameters are not allowed to escape the scope of the function body, meaning that they cannot be stored in variables, returned from the function or captured by other values. </span><span class="sentence">They may only be called inside the function body.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Crossinline parameters may not be stored or returned from the function, but may be captured (for example, by <a href="expressions.html#object-literals">object literals</a> or other non-inlined lambda literals).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Noinline parameters may be treated as any other values.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Particular platforms may introduce additional restrictions or guarantees for the inlining mechanism.</span></p>
</div>
<h4 id="tail-recursion-optimization">Tail recursion optimization</h4>
<div class="paragraph">
<p><span class="sentence">A function may be declared <em>tail-recursive</em> by using a special <code>tailrec</code> modifier. </span><span class="sentence">A tail-recursive function that contains a recursive call to itself may be optimized to a non-recursive form by a particular platform in order to avoid problems of recursion such as a possibility of stack overflows possible on some platforms.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In order to be applicable for such an optimization, the function must adhere to tail recursive form: for all paths containing recursive calls the result of the recursive call must also be the result of the function. </span><span class="sentence">If a function declaration is marked with the <code>tailrec</code> modifier, but is not actually applicable for the optimization, it must produce a compile-time warning.</span></p>
</div>
<h3 id="property-declaration">Property declaration</h3>
<div id="grammar-rule-propertyDeclaration-pasted-4" class="grammar-rule">
<dl>
<dt><strong><em>propertyDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="syntax.html#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'val'</code> | <code>'var'</code>)<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-receiverType">receiverType</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
({<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} (<em><a href="syntax.html#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> | <em><a href="syntax.html#grammar-rule-variableDeclaration">variableDeclaration</a></em>))<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} ((<code>'='</code> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-expression">expression</a></em>) | <em><a href="syntax.html#grammar-rule-propertyDelegate">propertyDelegate</a></em>)]<br />
[(<em><a href="syntax.html#grammar-rule-NL">NL</a></em> {<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}) <code>';'</code>]<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
(([<em><a href="syntax.html#grammar-rule-getter">getter</a></em>] [{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} [<em><a href="syntax.html#grammar-rule-semi">semi</a></em>] <em><a href="syntax.html#grammar-rule-setter">setter</a></em>]) | ([<em><a href="syntax.html#grammar-rule-setter">setter</a></em>] [{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} [<em><a href="syntax.html#grammar-rule-semi">semi</a></em>] <em><a href="syntax.html#grammar-rule-getter">getter</a></em>]))</span>
</dd>
</dl>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(brief property intro and classification)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Property declarations are used to create read-only (<code>val</code>) or mutable (<code>var</code>) entities in their respective scope. </span><span class="sentence">Properties may also have custom getter or setter — functions which are used to read or write the property value.</span></p>
</div>
<h4 id="read-only-property-declaration">Read-only property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration <code>val x: T = e</code> introduces <code>x</code> as a name of the result of <code>e</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration may include a custom <a href="declarations.html#getters-and-setters">getter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb17"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">val</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb17-2" title="2">    <span class="kw">get</span>() { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation. </span><span class="sentence">Both the right-hand value <code>e</code>, the type <code>T</code> and the getter are optional, however, at least one of them must be specified. </span><span class="sentence">More so, if both the type of <code>e</code> and the return type of the getter cannot be <a href="type-inference.html#type-inference">inferred</a> (or, in case of the getter, specified explicitly), the type <code>T</code> must be specified explicitly. </span><span class="sentence">In case both <code>e</code> and <code>T</code> are specified, the type of <code>e</code> must be a subtype of <code>T</code> (see <a href="type-system.html#subtyping">subtyping</a> for more details).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: we never actually say how getters are similar/different to normal functions and, henceforth, how the inference works</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The initializer expression <code>e</code>, if given, serves as the starting value for the property backing field (see <a href="declarations.html#getters-and-setters">getters and setters section</a> for details) and is evaluated when the property is created. </span><span class="sentence">Properties that are not allowed to have backing fields (see <a href="declarations.html#getters-and-setters">getters and setters section</a> for details) are also not allowed to have initializer expressions.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: although a property with an initializer expression looks similar to an <a href="statements.html#assignments">assignment</a>, it is different in several key ways: first, a read-only property cannot be assigned, but may have an initializer expression; second, the initializer expression never invokes the property setter, but assigns the property backing field value directly.</span></p>
</div>
</blockquote>
<h4 id="mutable-property-declaration">Mutable property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration <code>var x: T = e</code> introduces <code>x</code> as a name of a mutable variable with type <code>T</code> and initial value equals to the result of <code>e</code>. </span><span class="sentence">The rules regarding the right-hand value <code>e</code> and the type <code>T</code> match those of a read-only property declaration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration may include a custom <a href="declarations.html#getters-and-setters">getter</a> and/or custom <a href="declarations.html#getters-and-setters">setter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb18"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="kw">set</span>(value: TS) { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation when read from and to the setter invocation when written to.</span></p>
</div>
<h4 id="local-property-declaration">Local property declaration</h4>
<div class="paragraph">
<p><span class="sentence">If a property declaration is local, it creates a local entity which follows most of the same rules as the ones for regular property declarations. </span><span class="sentence">However, local property declarations cannot have custom getters or setters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Local property declarations also support <a href="operator-overloading.html#destructuring-declarations"><em>destructuring</em> declaration</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb19"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">val</span> (<span class="va">a</span>: T, b: U, c: V, ...) = e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">which is a syntactic sugar for the following expansion</span></p>
</div>
<div class="sourceCode" id="cb20"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">val</span> <span class="va">a</span>: T = e.component1()</a>
<a class="sourceLine" id="cb20-2" title="2"><span class="kw">val</span> <span class="va">b</span>: U = e.component2()</a>
<a class="sourceLine" id="cb20-3" title="3"><span class="kw">val</span> <span class="va">c</span>: V = e.component3()</a>
<a class="sourceLine" id="cb20-4" title="4">...</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>componentN()</code> should be a valid operator function available on the result of <code>e</code>. </span><span class="sentence">Some of the entries in the destructuring declaration may be replaced with an <em>ignore marker</em> <code>_</code>, which signifies that no variable is declared and no <code>componentN()</code> function is called.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As with regular property declaration, type specification is optional, in which case the type is inferred from the corresponding <code>componentN()</code> function. </span><span class="sentence">Destructuring declarations cannot use getters, setters or delegates and must be initialized in-place.</span></p>
</div>
<h4 id="getters-and-setters">Getters and setters</h4>
<div class="paragraph">
<p><span class="sentence">As mentioned before, a property declaration may include a custom getter and/or custom setter (together called <em>accessors</em>) in the form of</span></p>
</div>
<div class="sourceCode" id="cb21"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb21-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="kw">set</span>(anyValidArgumentName: TS): RT { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">These functions have the following requirements</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(TG \equiv T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(TS \equiv T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(RT \equiv \mathtt{kotlin.Unit}\)</span>;</span></li>
<li><div class="paragraph">
<p><span class="sentence">Types <span class="math inline">\(TG\)</span>, <span class="math inline">\(TS\)</span> and <span class="math inline">\(RT\)</span> are optional and may be omitted from the declaration;</span></p>
</div></li>
<li><span class="sentence">Read-only properties may have a custom getter, but not a custom setter;</span></li>
<li><div class="paragraph">
<p><span class="sentence">Mutable properties may have any combination of a custom getter and a custom setter</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">Setter argument may have any valid identifier as argument name.</span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Regular coding convention recommends <code>value</code> as the name for the setter argument</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">One can also omit the accessor body, in which case a <em>default</em> implementation is used (also known as default accessor).</span></p>
</div>
<div class="sourceCode" id="cb22"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb22-2" title="2">    <span class="kw">get</span></a>
<a class="sourceLine" id="cb22-3" title="3">    <span class="kw">set</span></a></code></pre></div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This notation is usually used if you need to change some aspects of an accessor (i.e., its visibility) without changing the default implementation.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow one to customize how the property is accessed, and may need access to the property’s <em>backing field</em>, which is responsible for actually storing the property data. </span><span class="sentence">It is accessed via the special <code>field</code> property available inside accessor body, which follows these conventions</span></p>
</div>
<ul>
<li><span class="sentence">For a property declaration of type <code>T</code>, <code>field</code> has the same type <code>T</code></span></li>
<li><span class="sentence"><code>field</code> is read-only inside getter body</span></li>
<li><span class="sentence"><code>field</code> is mutable inside setter body</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, the backing field is created for a property only in the following cases</span></p>
</div>
<ul>
<li><span class="sentence">A property has no custom accessors;</span></li>
<li><span class="sentence">A property has a default accessor;</span></li>
<li><span class="sentence">A property has a custom accessor, and it uses <code>field</code> property;</span></li>
<li><span class="sentence">A mutable property has a custom getter or setter, but not both.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In all other cases a property has no backing field. </span><span class="sentence">Properties without backing fields are not allowed to have initializer expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read/write access to the property is replaced with getter/setter invocation respectively.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow for some modifiers available for function declarations (for example, they may be declared <code>inline</code>, see grammar for details).</span></p>
</div>
<h4 id="delegated-property-declaration">Delegated property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A delegated read-only property declaration <code>val x: T by e</code> introduces <code>x</code> as a name for the <em>delegation</em> result of property <code>x</code> to the entity <code>e</code> or to the delegatee of <code>e</code> provided by <a href="declarations.html#provide-delegate"><code>provideDelegate</code></a>. </span><span class="sentence">For the former, one may consider these properties as regular properties with a special <em>delegating</em> <a href="declarations.html#getters-and-setters">getters</a>:</span></p>
</div>
<div class="sourceCode" id="cb23"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">val</span> <span class="va">x</span>: T <span class="kw">by</span> e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">is the same as</span></p>
</div>
<div class="sourceCode" id="cb24"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">val</span> <span class="va">x</span>$delegate = e</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="kw">val</span> <span class="va">x</span>: T</a>
<a class="sourceLine" id="cb24-3" title="3">    <span class="kw">get</span>(): T = x$delegate.getValue(thisRef, ::x)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Here every access to such property (<code>x</code> in this case) becomes an <a href="operator-overloading.html#operator-overloading">overloadable</a> form which is expanded into the following:</span></p>
</div>
<div class="sourceCode" id="cb25"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb25-1" title="1">e.getValue(thisRef, property)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>e</code> is the delegating entity; the compiler needs to make sure that this is accessible in any place <code>x</code> is accessible;</span></li>
<li><span class="sentence"><code>getValue</code> is a suitable operator function available on <code>e</code>;</span></li>
<li><span class="sentence"><code>thisRef</code> is the <a href="overload-resolution.html#receivers">receiver</a> object for the property. </span><span class="sentence">This argument is <code>null</code> for local properties;</span></li>
<li><span class="sentence"><code>property</code> is an object of the type <code>kotlin.KProperty&lt;*&gt;</code> that contains information relevant to <code>x</code> (for example, its name, see standard library documentation for details).</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A delegated mutable property declaration <code>var x: T by e</code> introduces <code>x</code> as a name of a mutable entity with type <code>T</code>, access to which is <em>delegated</em> to the entity <code>e</code> or to the delegatee of <code>e</code> provided by <a href="declarations.html#provide-delegate"><code>provideDelegate</code></a>. </span><span class="sentence">As before, one may view these properties as regular properties with special <em>delegating</em> <a href="declarations.html#getters-and-setters">getters and setters</a>:</span></p>
</div>
<div class="sourceCode" id="cb26"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T <span class="kw">by</span> e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">is the same as</span></p>
</div>
<div class="sourceCode" id="cb27"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">val</span> <span class="va">x</span>$delegate = e</a>
<a class="sourceLine" id="cb27-2" title="2"><span class="kw">var</span> <span class="va">x</span>: T</a>
<a class="sourceLine" id="cb27-3" title="3">    <span class="kw">get</span>(): T = x$delegate.getValue(thisRef, ::x)</a>
<a class="sourceLine" id="cb27-4" title="4">    <span class="kw">set</span>(value: T) { x$delegate.setValue(thisRef, ::x, value) }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Read access is handled the same way as for a delegated read-only property. </span><span class="sentence">Any write access to <code>x</code> (using, for example, an assignment operator <code>x = y</code>) becomes an overloadable form with the following expansion:</span></p>
</div>
<div class="sourceCode" id="cb28"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb28-1" title="1">e.setValue(thisRef, property, y)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>e</code> is the delegating entity; the compiler needs to make sure that this is accessible in any place <code>x</code> is accessible;</span></li>
<li><span class="sentence"><code>getValue</code> is a suitable operator function available on <code>e</code>;</span></li>
<li><span class="sentence"><code>thisRef</code> is the <a href="overload-resolution.html#receivers">receiver</a> object for the property. </span><span class="sentence">This argument is <code>null</code> for local properties;</span></li>
<li><span class="sentence"><code>property</code> is an object of the type <code>kotlin.KProperty&lt;*&gt;</code> that contains information relevant to <code>x</code> (for example, its name, see standard library documentation for details);</span></li>
<li><span class="sentence"><code>y</code> is the value <code>x</code> is assigned to. </span><span class="sentence">In case of complex assignments (see the <a href="statements.html#assignments">assignment</a> section), as they are all overloadable forms, first the assignment expansion is performed, and after that, the expansion of the delegated property using normal assignment.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The type of a delegated property may be omitted at the declaration site, meaning that it may be <a href="type-inference.html#type-inference">inferred</a> from the delegating function itself, as it is with regular getters and setters. </span><span class="sentence">If this type is omitted, it is inferred as if it was assigned the value of its expansion. </span><span class="sentence">If this inference fails, it is a compile-time error.</span></p>
</div>
<div id="provide-delegate">
<div class="paragraph">
<p><span class="sentence">If the delegate expression has a suitable operator function called <code>provideDelegate</code>, a <em>provided</em> delegate is used instead. </span><span class="sentence">The provided delegate is accessed using the following expansion:</span></p>
</div>
<div class="sourceCode" id="cb29"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">val</span> <span class="va">x</span>: T <span class="kw">by</span> e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">is the same as</span></p>
</div>
<div class="sourceCode" id="cb30"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">val</span> <span class="va">x</span>$delegate = e.provideDelegate(thisRef, ::x)</a>
<a class="sourceLine" id="cb30-2" title="2"><span class="kw">val</span> <span class="va">x</span>: T</a>
<a class="sourceLine" id="cb30-3" title="3">    <span class="kw">get</span>(): T = x$delegate.getValue(thisRef, ::x)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">and</span></p>
</div>
<div class="sourceCode" id="cb31"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T <span class="kw">by</span> e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">is the same as</span></p>
</div>
<div class="sourceCode" id="cb32"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">val</span> <span class="va">x</span>$delegate = e.provideDelegate(thisRef, ::x)</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="kw">val</span> <span class="va">x</span>: T</a>
<a class="sourceLine" id="cb32-3" title="3">    <span class="kw">get</span>(): T = x$delegate.getValue(thisRef, ::x)</a>
<a class="sourceLine" id="cb32-4" title="4">    <span class="kw">set</span>(value) { x$delegate.setValue(thisRef, ::x, value) }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>provideDelegate</code> is a suitable operator function available using the receiver <code>e</code>, while <code>getValue</code> and <code>setValue</code> work the same way they do with normal property delegation. </span><span class="sentence">As is the case with<code>setValue</code> and <code>getValue</code>, <code>thisRef</code> is a reference to the receiver of the property or <code>null</code> for local properties, but there is also a special case: for extension properties <code>thisRef</code> supplied to <code>provideDelegate</code> is <code>null</code>, while <code>thisRef</code> provided to <code>getValue</code> and <code>setValue</code> is the actual receiver. </span><span class="sentence">This is due to the fact that, during the creation of the property, no receiver is available.</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">For both provided and standard delegates, the generated delegate value is placed in the same context as its corresponding property. </span><span class="sentence">This means that for a class member property it will be a synthetic member, for a local property it is a local value in the same scope as the property and for top-level (both extension and non-extension) properties it will be a top-level value. </span><span class="sentence">This affects this value’s lifetime in the same way normal value lifetime works.</span></p>
</div>
<h4 id="extension-property-declaration">Extension property declaration</h4>
<div class="paragraph">
<p><span class="sentence">An <em>extension property declaration</em> is similar to a standard property declaration, but, very much alike an <a href="declarations.html#extension-function-declaration">extension function</a>, introduces an additional parameter to the property called <em>the receiver parameter</em>. </span><span class="sentence">This is different from usual property declarations, that do not have any parameters. </span><span class="sentence">There are other differences from standard property declarations:</span></p>
</div>
<ul>
<li><span class="sentence">Extension properties cannot have initializers;</span></li>
<li><span class="sentence">Extension properties cannot have backing fields;</span></li>
<li><span class="sentence">Extension properties cannot have default accessors.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, on can say that extension properties have no state of their own. </span><span class="sentence">Only properties that use other objects’ storage facilities and/or uses constant data can be extension properties.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Aside from these differences, extension properties are similar to regular properties, but, when accessing such a property one always need to supply a <a href="overload-resolution.html#receivers"><em>receiver</em></a>, implicit or explicit. </span><span class="sentence">Like for regular properties, the type of the receiver must be a subtype of the receiver parameter, and the value that is supplied as the receiver is bound to the receiver parameter. </span><span class="sentence">For more information on how a particular receiver for each access is chosen, please refer to the <a href="overload-resolution.html#overload-resolution">overloading section</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The receiver parameter can be accessed inside getter and setter scopes of the property as the implicit receiver or <code>this</code>. </span><span class="sentence">It may also be accessed inside nested scopes using <a href="expressions.html#this-expressions">labeled <code>this</code> syntax</a> using the name of the property declared as the label. </span><span class="sentence">For delegated properties, the value passed into the operator functions <code>getValue</code> and <code>setValue</code> as the receiver is the value of the receiver parameter, rather than the value of the outer classifier. </span><span class="sentence">This is also true for local extension properties: while regular local properties are passed <code>null</code> as the first argument of these operator functions, local extension properties are passed the value of the receiver argument instead.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when declaring extension properties inside classifier declarations, this receiver takes precedence over the classifier object, which is usually the current receiver inside nested properties</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For all other purposes, extension properties are not different from non-extension properties.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb33"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">val</span> <span class="va">Int</span>.foo: <span class="kw">Int</span> <span class="kw">get</span>() = <span class="kw">this</span> + <span class="dv">1</span></a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb33-4" title="4">    println(<span class="fl">2.f</span>oo.foo) <span class="co">// prints &quot;4&quot;</span></a>
<a class="sourceLine" id="cb33-5" title="5">}</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="kw">class</span> Bar {</a>
<a class="sourceLine" id="cb33-8" title="8">    <span class="kw">val</span> <span class="va">foo</span> <span class="kw">get</span>() = <span class="kw">this</span> <span class="co">// returns type Bar</span></a>
<a class="sourceLine" id="cb33-9" title="9">    <span class="kw">val</span> <span class="va">Int</span>.foo <span class="kw">get</span>() = <span class="kw">this</span> <span class="co">// returns type Int</span></a>
<a class="sourceLine" id="cb33-10" title="10">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(More examples (delegation, at least))</span></p>
</div>
</div>
<h4 id="property-initialization">Property initialization</h4>
<div class="paragraph">
<p><span class="sentence">All non-abstract properties must be definitely initialized before their first use. </span><span class="sentence">To guarantee this, Kotlin compiler uses a number of analyses which are described in more detail <a href="control--and-data-flow-analysis.html#control--and-data-flow-analysis">here</a>.</span></p>
</div>
<h4 id="constant-properties">Constant properties</h4>
<div class="paragraph">
<p><span class="sentence">A property may be declared <strong>constant</strong>, meaning that its value is known during compilation, by using the special <code>const</code> modifier. </span><span class="sentence">In order to be declared <code>const</code>, a property must meet the following requirements:</span></p>
</div>
<ul>
<li><span class="sentence">Its type is one of the following:</span>
<ul>
<li><span class="sentence">One of the <a href="built-in-types-and-their-semantics.html#built-in-integer-types-1">the built-in integral types</a>;</span></li>
<li><span class="sentence">One of the <a href="built-in-types-and-their-semantics.html#built-in-floating-point-arithmetic-types">the built-in floating types</a>;</span></li>
<li><span class="sentence"><code>kotlin.Boolean</code>;</span></li>
<li><span class="sentence"><code>kotlin.Char</code>;</span></li>
<li><span class="sentence"><code>kotlin.String</code>;</span></li>
</ul></li>
<li><span class="sentence">It is declared in the top-level scope or inside <a href="declarations.html#classifier-declaration">an object declaration</a>;</span></li>
<li><span class="sentence">It has an initializer expression and this initializer expression can be evaluated at compile-time. </span><span class="sentence">Integer literals and string interpolation expressions without evaluated expressions, as well as built-in arithmetic/comparison operations and string concatenation operations on those are such expressions, as well as other constant properties, but it is implementation-defined which other expressions qualify for this;</span></li>
<li><span class="sentence">It does not have getters, setters or delegation specifiers.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb34"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb34-1" title="1"><span class="co">// Correct constant properties</span></a>
<a class="sourceLine" id="cb34-2" title="2">const <span class="kw">val</span> <span class="va">answer</span> = <span class="dv">2</span> * <span class="dv">21</span></a>
<a class="sourceLine" id="cb34-3" title="3">const <span class="kw">val</span> <span class="va">msg</span> = <span class="st">&quot;Hello World!&quot;</span></a>
<a class="sourceLine" id="cb34-4" title="4">const <span class="kw">val</span> <span class="va">calculated</span> = answer + <span class="dv">45</span></a>
<a class="sourceLine" id="cb34-5" title="5"></a>
<a class="sourceLine" id="cb34-6" title="6"><span class="co">// Incorrect constant property</span></a>
<a class="sourceLine" id="cb34-7" title="7">const <span class="kw">val</span> <span class="va">emptyStringHashCode</span> = <span class="st">&quot;&quot;</span>.hashCode()</a></code></pre></div>
</blockquote>
<h4 id="late-initialized-properties">Late-initialized properties</h4>
<div class="paragraph">
<p><span class="sentence">A mutable member property can be declared with a special <code>lateinit</code> modifier, effectively turning off the <a href="declarations.html#property-initialization">property initialization checks</a> for it. </span><span class="sentence">Such a property is called late-initialized and may be used for values that are supposed to be initialized not during object construction, but during some other time (for example, a special initialization function). </span><span class="sentence">This means, among other things, that it is the responsibility of the programmer to guarantee that the property is initialized before its usage.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A property may be declared late-initialized if:</span></p>
</div>
<ul>
<li><span class="sentence">It has no custom getters, setters or delegation;</span></li>
<li><span class="sentence">It is a member or a top-level property;</span></li>
<li><span class="sentence">It is mutable;</span></li>
<li><span class="sentence">It has declared non-nullable type which is also not one of the following types:</span>
<ul>
<li><span class="sentence">One of the <a href="built-in-types-and-their-semantics.html#built-in-integer-types-1">built-in integer types</a>;</span></li>
<li><span class="sentence">One of the <a href="built-in-types-and-their-semantics.html#built-in-floating-point-arithmetic-types">built-in floating types</a>;</span></li>
<li><span class="sentence"><a href="built-in-types-and-their-semantics.html#kotlin.boolean"><code>kotlin.Boolean</code></a>;</span></li>
<li><span class="sentence"><a href="built-in-types-and-their-semantics.html#kotlin.char"><code>kotlin.Char</code></a>.</span></li>
</ul></li>
</ul>
<h3 id="type-alias">Type alias</h3>
<div id="grammar-rule-typeAlias-pasted-5" class="grammar-rule">
<dl>
<dt><strong><em>typeAlias</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="syntax.html#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'typealias'</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>} <em><a href="syntax.html#grammar-rule-typeParameters">typeParameters</a></em>]<br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<code>'='</code><br />
{<em><a href="syntax.html#grammar-rule-NL">NL</a></em>}<br />
<em><a href="syntax.html#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Type alias introduces an alternative name for the specified type and supports both simple and parameterized types. </span><span class="sentence">If type alias is parameterized, its type parameters must be <a href="type-system.html#type-parameters">unbounded</a>. </span><span class="sentence">Another restriction is that recursive type aliases are forbidden — the type alias name cannot be used in its own right-hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">At the moment, Kotlin supports only top-level type aliases. </span><span class="sentence">The scope where it is accessible is defined by its <a href="declarations.html#declaration-visibility"><em>visibility modifiers</em></a>.</span></p>
</div>
<h3 id="declarations-with-type-parameters">Declarations with type parameters</h3>
<div class="paragraph">
<p><span class="sentence">Most declarations may be introduced as <em>generic</em>, introducing type parameters that must be explicitly specified or <a href="type-inference.html#type-inference">inferred</a> when the corresponding declaration is used. </span><span class="sentence">For declarations that introduce new types this mechanism provides the means of introducing a <a href="type-system.html#parameterized-classifier-types">parameterized type</a>. </span><span class="sentence">Please refer to the corresponding section for details.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type parameters may be used as types inside the scope introduced by the declaration. </span><span class="sentence">When such a declaration is used, the parameters are substituted by types available inside the scope the declaration is used in.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The following declarations are not allowed to have type parameters:</span></p>
</div>
<ul>
<li><span class="sentence">Non-extension property declarations;</span></li>
<li><span class="sentence">Object declarations (including companion object declarations);</span></li>
<li><span class="sentence">Constructor declarations;</span></li>
<li><span class="sentence">Getters and setters of property declarations;</span></li>
<li><span class="sentence">Enum class declarations;</span></li>
<li><span class="sentence">Annotation class declarations;</span></li>
<li><span class="sentence">Classifier declarations inheriting from <code>kotlin.Throwable</code>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Type parameters are allowed to specify <em>subtyping restrictions</em> on them in the form <code>T : U</code>, meaning <span class="math inline">\(T &lt;: U\)</span> where <span class="math inline">\(T\)</span> is a type parameter and <span class="math inline">\(U\)</span> is some other type available in the scope the declaration is declared in. </span><span class="sentence">These either are written directly at the parameter placement syntax or using a special <code>where</code> syntax. </span><span class="sentence">Any number of restrictions is allowed on a single type, however, there are some limitations on the allowed subtyping restriction shape.</span></p>
</div>
<ul>
<li><span class="sentence">For a given type parameter <code>T</code>, only one restriction <code>T : U</code> can have <code>U</code> to be another type parameter;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These restrictions are turned into corresponding <a href="kotlin-type-constraints.html#kotlin-type-constraints">type constraints</a> when the type parameters are substituted with types and are employed during <a href="type-inference.html#type-inference">type inference</a> and <a href="overload-resolution.html#overload-resolution">overload resolution</a> of any usage of the corresponding declaration. </span><span class="sentence">See the corresponding sections for details.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type parameters do not introduce <a href="runtime-type-information.html#runtime-available-types">runtime-available types</a> unless declared <code>reified</code>.</span></p>
</div>
<h4 id="type-parameter-variance">Type parameter variance</h4>
<div class="paragraph">
<p><span class="sentence">The <a href="type-system.html#mixed-site-variance">declaration-site variance</a> of a particular type parameter for a classifier declaration is specified using special keywords <code>in</code> (for covariant parameters) and <code>out</code> (for contravariant parameters). </span><span class="sentence">If the variance is not specified, the parameter is implicitly declared invariant. </span><span class="sentence">See <a href="type-system.html#mixed-site-variance">the type system section</a> for details.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A type parameter is <strong>used in covariant position</strong> in the following cases:</span></p>
</div>
<ul>
<li><span class="sentence">It is used as an argument in another generic type and the corresponding parameter in that type is covariant;</span></li>
<li><span class="sentence">It is the return type of a function;</span></li>
<li><span class="sentence">It is a type of a property.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A type parameter is <strong>used in contravariant position</strong> in the following cases:</span></p>
</div>
<ul>
<li><span class="sentence">It is used as an argument in another generic type and the corresponding parameter in that type is contravariant;</span></li>
<li><span class="sentence">It is a type of an parameter of a function;</span></li>
<li><span class="sentence">It is a type of a mutable property.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A type parameter is used in an invariant position if it is used as an argument in another generic type and the corresponding parameter in that type is invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A usage of a contravariant type parameter in a covariant or invariant position, as well as usage of a covariant type parameter in a contravariant or invariant position, results in <strong>variance conflict</strong> and a compiler error, unless the containing declaration is private to the type parameter owner (in which case its visibility is restricted, see the <a href="declarations.html#declaration-visibility">visibility</a> section for details).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This restrictions may be lifted in particular cases by <a href="annotations.html#annotations">annotating</a> the corresponding type parameter usage with a special built-in annotation <code>kotlin.UnsafeVariance</code>. </span><span class="sentence">By supplying this annotation the author of the code explicitly declares that safety features that variance checks provide are not needed in this particular declarations.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: account for more complex cases</span></p>
</div>
</div>
<h4 id="reified-type-parameters">Reified type parameters</h4>
<div class="paragraph">
<p><span class="sentence">Type parameters of inline function declarations (and only those) can be declared <code>reified</code> using the corresponding keyword. </span><span class="sentence">A reified type parameter is a <a href="runtime-type-information.html#runtime-available-types">runtime-available</a> type inside the function scope, see the corresponding section for details. </span><span class="sentence">Reified type parameters can only be substituted by other <a href="runtime-type-information.html#runtime-available-types">runtime-available types</a> when using such functions.</span></p>
</div>
<h3 id="declaration-visibility">Declaration visibility</h3>
<div class="paragraph">
<p><span class="sentence">Each declaration has a visibility property relative to the scope it is declared in. </span><span class="sentence">By default, all the declarations are <code>public</code>, meaning that they can be accessed from any other scope their outer scope can be accessed from. </span><span class="sentence">The only exception to this rule are <a href="inheritance.html#overriding">overriding declarations</a> that by default inherit the visibility from the declaration they override. </span><span class="sentence">Declarations may be also marked <code>public</code> explicitly.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations marked as <code>private</code> can only be accessed from the same scope they are declared in. </span><span class="sentence">For example, all <code>private</code> top-level declarations in a file may only be accessed by code from the same file.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Some <code>private</code> declarations are special in that they have an even more restricted visibility, called “<code>private</code> to <code>this</code>”. </span><span class="sentence">These include declarations that are allowed to lift certain <a href="type-system.html#mixed-site-variance">variance</a> rules in their types as long as they are never accessed outside <code>this</code> object, meaning that they can be accessed using <code>this</code> as the receiver, but are not visible on other instances of the same class even in the methods of this class. </span><span class="sentence">For example, for a class declaration <span class="math inline">\(C\)</span> with type parameter <span class="math inline">\(T\)</span> it is not allowed to introduce declarations involving <span class="math inline">\(T\)</span> with conflicting variance, unless they are declared <code>private</code>. </span><span class="sentence">That is, if <span class="math inline">\(T\)</span> is declared as covariant, any declarations with a type using <span class="math inline">\(T\)</span> in a contravariant position (including properties with type <span class="math inline">\(T\)</span> itself if they are mutable) and if <span class="math inline">\(T\)</span> is declared as contravariant, any declarations with a type using <span class="math inline">\(T\)</span> in a covariant position (including properties with type <span class="math inline">\(T\)</span> itself) are forbidden, unless they are declared using <code>private</code> visibility, in which case they are instead treated as “<code>private</code> to <code>this</code>”.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the above does not account for <code>@UnsafeVariance</code> annotation that lifts any variance restrictions on type parameters</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: examples</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations marked as <code>internal</code> may only be accessed from the same <a href="packages-and-imports.html#modules">module</a>, treated as <code>public</code> from inside the module and as <code>private</code> from outside the module.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations in classifier declaration scope can also be declared <code>protected</code>, meaning that they can only be accessed from the same classifier type as well as any types <a href="inheritance.html#inheritance">inheriting</a> from this type regardless of the scope they are declared in.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There is a partial order of <em>weakness</em> between different visibility modifiers:</span></p>
</div>
<ul>
<li><span class="sentence"><code>protected</code> and <code>internal</code> are weaker than <code>private</code>;</span></li>
<li><span class="sentence"><code>public</code> is weaker than <code>protected</code> and <code>internal</code>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: there is a certain restriction regarding <code>inline</code> functions that have a different visibility from entities they access. </span><span class="sentence">In particular, an <code>inline</code> function cannot access entities with a stronger visibility (i.e. </span><span class="sentence"><code>public inline</code> function accessing a <code>private</code> property). </span><span class="sentence">There is one exception to this: a <code>public inline</code> function can access <code>internal</code> entities which are marked with a special builtin <a href="annotations.html#annotations">annotation</a> <code>@PublishedApi</code>.</span></p>
</div>
</blockquote>
</body>
</html>
